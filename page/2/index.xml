<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图拉国营噄茶馆</title>
    <link>https://winterorch.github.io/</link>
    <description>Recent content on 图拉国营噄茶馆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</copyright>
    <lastBuildDate>Wed, 30 Jun 2021 00:12:58 +0630</lastBuildDate>
    
        <atom:link href="https://winterorch.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
        <link>https://winterorch.github.io/posts/leetcode-jianzhi-059/</link>
        <pubDate>Tue, 01 Jun 2021 17:45:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-jianzhi-059/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-jianzhi-059/ -&lt;h1 id=&#34;剑指-offer-59---i-滑动窗口的最大值httpsleetcode-cncomproblemshua-dong-chuang-kou-de-zui-da-zhi-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/&#34;&gt;剑指 Offer 59 - I. 滑动窗口的最大值&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt; 和滑动窗口的大小 &lt;code&gt;k&lt;/code&gt;，请找出所有滑动窗口里的最大值。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:&lt;/p&gt;
&lt;p&gt;滑动窗口的位置                最大值&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1  3  -1] -3  5  3  6  7       3
1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以假设 &lt;em&gt;k&lt;/em&gt; 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解一-单调队列&#34;&gt;题解一 单调队列&lt;/h3&gt;
&lt;p&gt;要求滑动窗口内的最大值，首先想到的是双向队列，一边推窗一边保持最大元素在队首。由于要确保窗口长度，队列中存的是下标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;maxSlidingWindow&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] res = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt; - k + 1];
    Deque&amp;lt;Integer&amp;gt; deque = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!deque.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekFirst&lt;/span&gt;() == i - k) {
            deque.&lt;span style=&#34;color:#658b00&#34;&gt;removeFirst&lt;/span&gt;();
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!deque.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; nums[deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekLast&lt;/span&gt;()] &amp;lt; nums[i]) {
            deque.&lt;span style=&#34;color:#658b00&#34;&gt;removeLast&lt;/span&gt;();
        }
        deque.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(i);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i &amp;gt;= k - 1) {
            res[i - k + 1] = nums[deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekFirst&lt;/span&gt;()];
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;题解二--双向遍历&#34;&gt;题解二  双向遍历&lt;/h3&gt;
&lt;p&gt;如果通过固定队列长度可以来限制搜索范围，通过双向遍历也可以。不依靠队列的话有个问题，最大值会不断传播，如果 [0] 处是数组最大值，这一最大值可以一直传播到队尾。那我们必须进行适当的划分，让最大值最远传播 k 个数字（包含自己）。&lt;/p&gt;
&lt;p&gt;我们直接将队列分成一段段长为 &lt;code&gt;k&lt;/code&gt; 的区间，每一段区间中，第一次遍历取得前半段（&lt;code&gt;[0.. i % k]&lt;/code&gt;）上的最大值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; ++i) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % k == 0) {
        prefixMax[i] = nums[i];
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        prefixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(prefixMax[i - 1], nums[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后从后向前进行一次遍历，取得后半段（&lt;code&gt;[i % k .. k - 1]&lt;/code&gt;）上的最大值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = n - 1; i &amp;gt;= 0; --i) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i == n - 1 || (i + 1) % k == 0) {
        suffixMax[i] = nums[i];
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        suffixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i + 1], nums[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，我们要取以 &lt;code&gt;i&lt;/code&gt; 为起点长度为 &lt;code&gt;k&lt;/code&gt; 的窗口的最大值，实际要取的就是当前区间上 &lt;code&gt;[i % k .. k - 1]&lt;/code&gt; 上的最大值，和下一区间 &lt;code&gt;[0 .. (i - 1 + k) % k]&lt;/code&gt; 上的最大值。&lt;/p&gt;
&lt;p&gt;完整答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;maxSlidingWindow&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (n == 0) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[0];
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] prefixMax = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] suffixMax = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % k == 0) {
            prefixMax[i] = nums[i];
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            prefixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(prefixMax[i - 1], nums[i]);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = n - 1; i &amp;gt;= 0; --i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i == n - 1 || (i + 1) % k == 0) {
            suffixMax[i] = nums[i];
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            suffixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i + 1], nums[i]);
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] ans = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n - k + 1];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt;= n - k; ++i) {
        ans[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i], prefixMax[i + k - 1]);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-jianzhi-059/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>计算机网络 应用层</title>
        <link>https://winterorch.github.io/posts/computer_network-application_layer/</link>
        <pubDate>Mon, 31 May 2021 23:04:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/computer_network-application_layer/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/computer_network-application_layer/ -&lt;h3 id=&#34;常用端口及协议&#34;&gt;&lt;strong&gt;常用端口及协议&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;应用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;协议&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;端口号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;传输层&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;域名解析&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DNS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;53&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP/TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;长度超过 512 字节时使用 TCP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;动态主机配置协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DHCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;67/68&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简单网络管理协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SNMP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;161/162&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20/21&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;控制连接 21，数据连接 20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;远程终端协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TELNET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超文本传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;80&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简单邮件传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SMTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;邮件读取协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;POP3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;110&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网际报文存取协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IMAP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;143&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超文本传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTPS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;443&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;域名系统&#34;&gt;&lt;strong&gt;域名系统&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;DNS ( Domain Name System ) 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。&lt;/p&gt;
&lt;p&gt;域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_01.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;dns-使用-udptcp&#34;&gt;DNS 使用 UDP/TCP&lt;/h4&gt;
&lt;p&gt;DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这样 DNS 服务器负载更低，响应更快，不过这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。一般在两种情况下会使用 TCP 进行传输：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域传送&lt;/p&gt;
&lt;p&gt;辅域名服务器会定时（一般三小时）向主域名服务器查询变动，如有变动则需要区域传送来同步数据，这一过程数据量很大，且对可靠性有一定要求，因此使用 TCP&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一种比较少见的情况——客户端可以指定向 DNS 服务器查询时用 TCP，但很多 DNS 服务器都配置为仅支持 UDP 查询。&lt;/p&gt;
&lt;h4 id=&#34;dns-缓存&#34;&gt;DNS 缓存&lt;/h4&gt;
&lt;p&gt;DNS 有多级缓存，按离浏览器距离，有浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;文件传送协议&#34;&gt;&lt;strong&gt;文件传送协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;FTP ( File Transfer Protocol ) 使用 TCP 进行连接，它需要两个连接来传送一个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。&lt;/li&gt;
&lt;li&gt;数据连接：用来传送一个文件数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_03.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;动态主机配置协议&#34;&gt;&lt;strong&gt;动态主机配置协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;自动配置 IP 地址等信息，DHCP ( Dynamic Host Configuration Protocol ) 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。&lt;/p&gt;
&lt;p&gt;DHCP 工作过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。&lt;/li&gt;
&lt;li&gt;DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。&lt;/li&gt;
&lt;li&gt;如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。&lt;/li&gt;
&lt;li&gt;DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_04.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;远程登录协议&#34;&gt;&lt;strong&gt;远程登录协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。&lt;/p&gt;
&lt;p&gt;TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;电子邮件协议&#34;&gt;&lt;strong&gt;电子邮件协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。&lt;/p&gt;
&lt;p&gt;邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_05.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SMTP&lt;/p&gt;
&lt;p&gt;SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_06.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;POP3&lt;/p&gt;
&lt;p&gt;POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IMAP&lt;/p&gt;
&lt;p&gt;IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;http--https&#34;&gt;&lt;strong&gt;HTTP / HTTPS&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;原因&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1XX&lt;/td&gt;
&lt;td&gt;Informational（信息性）&lt;/td&gt;
&lt;td&gt;接收的请求正在处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2XX&lt;/td&gt;
&lt;td&gt;Success（成功）&lt;/td&gt;
&lt;td&gt;请求正常处理完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3XX&lt;/td&gt;
&lt;td&gt;Redirection（重定向）&lt;/td&gt;
&lt;td&gt;需要进行附加操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4XX&lt;/td&gt;
&lt;td&gt;Client Error（客户端错误）&lt;/td&gt;
&lt;td&gt;服务器无法处理请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5XX&lt;/td&gt;
&lt;td&gt;Server Error（服务器错误）&lt;/td&gt;
&lt;td&gt;服务器处理请求出错&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;HTTP/1.1 起默认使用长连接，用以保持连接特性，并支持请求的流水线 (Pipelining) 处理。实现长连接需要客户端和服务端都支持长连接。使用长连接的 HTTP 协议会在响应头加入这行代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;Connection:keep-alive
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;网页打开后，客户端与服务器间用于传输 HTTP 数据的 TCP 连接不会关闭，再次访问服务器时会继续使用。连接的保持时间由服务器设定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 本身是无状态协议，因此 Session 机制通过服务端记录用户状态。服务端为特定用户创建特定 Session 后用以标识和跟踪用户。&lt;/p&gt;
&lt;p&gt;大部分情况下，服务端通过在 Cookie 中附加 Session ID 来跟踪，并将 Session 存在缓存或数据库中。如果 Cookie 被禁用，也可以利用 URL 重写附在 URL 路径后面。&lt;/p&gt;
&lt;p&gt;不过诸如 Spring Security 等安全框架中采用 Token 认证，服务器通过&lt;code&gt;Payload&lt;/code&gt;、&lt;code&gt;Header&lt;/code&gt;和一个密钥(&lt;code&gt;secret&lt;/code&gt;)创建令牌（&lt;code&gt;Token&lt;/code&gt;）并将 &lt;code&gt;Token&lt;/code&gt; 发送给客户端，客户端将 &lt;code&gt;Token&lt;/code&gt; 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 &lt;code&gt;Authorization&lt;/code&gt;字段中：&lt;code&gt; Authorization: Bearer Token&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展：HTTP 协议的优化&lt;/p&gt;
&lt;p&gt;参考阅读材料： &lt;a href=&#34;https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?&#34;&gt;https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTTP1.1 引入了更多缓存控制策略，并允许对某个资源的部分请求，新增了 24 个错误状态响应码，请求和响应消息都支持 Host 头域（这使得多个主机可以共享一个IP，一台物理服务器从而可以存在多个虚拟主机），最重要的——支持了&lt;strong&gt;长连接&lt;/strong&gt;和请求的&lt;strong&gt;流水线处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2012年 Google 提出 SPDY 方案，通过多路复用 (Multiplexing) 提高 TCP 连接利用率（因为浏览器一般对同一域名有最大连接数限制），为每个 &lt;code&gt;Request&lt;/code&gt; 设置优先级（展示内容可以优先加载，优化了用户体验），加了首部压缩协议，并强制使用 HTTPS 保障安全，服务端也可以主动推动（例如客户端请求 &lt;code&gt;style.css&lt;/code&gt; 文件时，服务端可以将相关的 &lt;code&gt;style.js&lt;/code&gt; 也推送过去）。&lt;/p&gt;
&lt;p&gt;SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTPS 运行在 SSL/TLS 上，而 SSL/TLS 运行在 TCP 上，所有传输内容都经过对称加密，对称密钥用服务器方的证书进行了非对称加密。因此 HTTPS 消耗服务器资源比 HTTP 多。&lt;/p&gt;
&lt;p&gt;CA ( Certification Authority ) 负责签发证书，并且能够验证域名所属——通过 DNS 记录或指定 URI 下放置的特殊文件供 CA 通过外网访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果网站证书被 CA 私自发给了第三方，那第三方就能够利用证书实施中间人攻击了，因此 CA 信用非常重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;web-页面请求过程&#34;&gt;&lt;strong&gt;Web 页面请求过程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;也算是比较常见的面试题吧&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DHCP 配置主机信息&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:FF，将广播到与交换机连接的所有设备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ARP 解析 MAC 地址&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;DNS 解析域名&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;HTTP 请求页面 (TCP、HTTP)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/computer_network-application_layer/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Java 抽象类</title>
        <link>https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/</link>
        <pubDate>Sun, 30 May 2021 20:01:58 +0530</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/ -&lt;h3 id=&#34;语法&#34;&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;抽象类中可以存在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造方法&lt;/li&gt;
&lt;li&gt;抽象方法&lt;/li&gt;
&lt;li&gt;非抽象方法&lt;/li&gt;
&lt;li&gt;成员变量&lt;/li&gt;
&lt;li&gt;静态成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：除了不能被实例化，抽象类几乎具有普通类的所有特性。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;注意点&#34;&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;抽象类&lt;strong&gt;不能被实例化&lt;/strong&gt;，如果试图实例化抽象类，编译无法通过&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类中&lt;strong&gt;可以有构造方法&lt;/strong&gt;，但是构造方法不能为抽象方法，其中原因见 [为什么构造函数不能为抽象]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;抽象类及其实现的构造方法也必须遵循一般继承中的构造方法规范，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类实例化对象时，如果子类构造方法没有显式调用父类构造方法，默认调用 &lt;code&gt;super()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子类要使用父类有参构造方法，使用 &lt;code&gt;super(...)&lt;/code&gt; 形式，且 &lt;code&gt;super()&lt;/code&gt; 必须是子类构造方法中第一行语句&lt;/li&gt;
&lt;li&gt;父类没有不带参构造方法（只定义了有参构造方法而没有定义无参的），子类构造方法中必须显示调用父类其它构造方法，否则编译不过&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类中的&lt;strong&gt;静态方法也不能为抽象方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类中的抽象方法&lt;strong&gt;只能声明&lt;/strong&gt;，&lt;strong&gt;不能有具体实现&lt;/strong&gt;，这与接口不同（接口方法在 JDK 1.8 后也可以有默认实现），具体原因见  [为什么抽象方法不能有实现而接口方法可以]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;有端联想&#34;&gt;&lt;strong&gt;有端联想&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;抽象类总结了几个比较有嚼劲的问题&lt;/p&gt;
&lt;h4 id=&#34;1-为什么构造函数不能为抽象&#34;&gt;1. 为什么构造函数不能为抽象&lt;/h4&gt;
&lt;p&gt;Java 抽象函数 和 C++ 虚函数 是等价概念，因此这里直接从 C++ 的角度找答案了。结论就是——构造函数从语言和逻辑来看都不能为虚函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从内存结构角度来看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚函数对应虚函数表 vtable ，表为类所有，但虚函数表指针为每个对象所有，在构造函数运行时进行空间分配，因此构造函数无法在未创建虚表指针的情况下调用虚表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从语言逻辑角度来看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构造函数目的是初始化实例，我们知道抽象类和虚基类都没有实例化的需求，将构造函数定义为虚函数是没有意义的。&lt;/p&gt;
&lt;p&gt;可以先回顾一下虚函数的作用过程——通过指针或者引用来调用虚函数的时候能够调用到子类的对应成员函数。而构造函数是在创建对象时自动调用的，调用这一函数的指针或引用所对应的对象还不存在，也就决定了构造函数不能是虚函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-为什么抽象方法不能有实现而接口方法可以&#34;&gt;2. 为什么抽象方法不能有实现而接口方法可以&lt;/h4&gt;
&lt;p&gt;JDK 1.8 以前两者都不能有实现，这对接口的实现造成了一些麻烦，因为很多时候我们希望接口方法能有一些默认实现，从而减少其实现类中的重复代码；更多的时候，我们实现接口也并不需要用到其中所有方法，但没有默认实现导致我们不得不在实现一个接口时实现其中所有方法（因此出现了很多用于适配接口与实现类的 &lt;code&gt;Adapter&lt;/code&gt; 类），哪怕根本不会用到。综上，JDK 1.8 以后接口也可以有默认实现了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这其实让我联想到数据库设计范式对数据库粒度的苛求。按照规范来说，如果有类在实现接口过程中存在用不到的方法，那说明接口的粒度仍不够小——对行为的定义不够细，但从另一方面来讲，追求完美的接口粒度又会使代码晦涩难懂，且不够灵活。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是抽象类中从一开始就不存在这个问题——因为抽象类并不只能包含抽象方法，还能包含普通方法，而 Java 中普通方法本身就是“虚函数”，允许子类重写。那么如果想要一个默认实现，直接写普通方法就行了。Java 语言设计抽象类的目的本就是方便代码重用，但在设计接口之初并没有把这一需求囊括进来。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;抽象方法&lt;/strong&gt;，仅用于标识子类&lt;strong&gt;必须实现&lt;/strong&gt;的方法（&lt;!-- raw HTML omitted --&gt;有一种特殊情况除外，就是&lt;strong&gt;子类也是抽象类&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;）。&lt;/p&gt;
- https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>JVM GC</title>
        <link>https://winterorch.github.io/posts/java-jvm-ram_and_gc/</link>
        <pubDate>Wed, 17 Mar 2021 22:03:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-jvm-ram_and_gc/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-jvm-ram_and_gc/ -&lt;h3 id=&#34;一垃圾收集算法&#34;&gt;一、垃圾收集算法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;下面这张图中存在 Permanent Space ，因此明显是基于 JDK 1.8 以前版本画的，在之后版本，元空间取代了永久代成为了 HotSpot 对方法区的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/java-jvm-ram_and_gc_01.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;跟据 &lt;code&gt;Object&lt;/code&gt; 生命周期分为三个层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Young Generation&lt;/li&gt;
&lt;li&gt;Old Generation&lt;/li&gt;
&lt;li&gt;Permanent Generation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Young Generation 包括 Eden 区和两个存活区（From 和 To），采用“停止-复制（Stop-and-copy）”清理法。大部分对象在 Eden 区域分配，一次新生代垃圾回收后如果对象还存活，则升1岁进入 &lt;code&gt;s0&lt;/code&gt; 或 &lt;code&gt;s1&lt;/code&gt; ，清理 Eden 和使用过的一块 Survivor。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证内存利用率有 90%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Eden 区满时执行 Minor GC 清理可销毁对象，将不可销毁的迁移至其中一个存活区，而将另一个存活区直接清空，下一次 GC 时两个存活区角色交换，交换次数超过 15 （&lt;code&gt;MaxTenuringThreshold&lt;/code&gt;）的进入 Old Generation。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;复制算法（young代GC算法）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该算法会将内存区域分为两个大小一样的区域。GC回收时，遍历当前使用区域，只将正在引用的对象复制到另一个区域，因此复制成本较低，且复制过程中还会进行内存整理，不会出现“碎片”问题。缺点就是：需要两个大小一样的内存区域和生命周期短的对象。所以该算法不适合大内存对象和长生命周期的对象，适用于young代的SO/S1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hotspot 的动态年龄阈值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hotspot遍历对象时按年龄从小到大对其所占用大小进行累积，当累积的某个年龄大小超过了 &lt;code&gt;survivor&lt;/code&gt; 区一半，取年龄与 &lt;code&gt;MaxTenuringThreshold&lt;/code&gt; 中更小的作为新年龄阈值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Old Generation 通过“标记-整理”算法，标记处仍存活对象，并将所有存活对象向一端移动以保证内存连续，清理掉剩余部分内存。当进入的对象超过剩余空间大小，则触发 Full GC。“标记-整理”好处是不需要额外内存区域。&lt;/p&gt;
&lt;p&gt;Permanent Generation 主要存放字节码、字符串常量池、静态变量、可持久化数据等。每次发生 Full GC 时，同时也会销毁 Permanent Generation 中的可销毁对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;永久代&lt;/strong&gt;实际上是HotSpot JVM对JVM方法区的实现。由于永久代内存经常不够或发生内存泄露，造成OOM(PermGen)，从JDK8开始废弃了永久代，替换为了&lt;strong&gt;本地内存&lt;/strong&gt;(native memory) 中的 Metaspace。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;元空间&lt;/strong&gt;与永久代最大区别在于它不在虚拟机中，而是使用&lt;!-- raw HTML omitted --&gt;本地内存&lt;!-- raw HTML omitted --&gt;。两者都是对JVM规范中方法区的实现，用于存储类的信息、常量池、方法数据、方法代码等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串常量从JDK1.7开始由永久代转移到堆中(Java heap space)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images2015.cnblogs.com/blog/584866/201704/584866-20170426154633834-741444326.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二经典垃圾收集器&#34;&gt;二、经典垃圾收集器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/440ec4093732dc8fe7a3092666f15a7f2c4303b97499a517562e5f868fa6c967/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63363235626161302d646465362d343439652d393364662d6333613637663266343330662e6a7067&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HotSpot 中的&lt;strong&gt;安全点&lt;/strong&gt;一般设置在方法调用、循环跳转、异常跳转等地方，只在安全点位置建立根节点枚举，强制到大安全点后才暂停，进行垃圾收集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HotSpot 中有7个垃圾收集器，连线表示可以配合使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h5 id=&#34;serial&#34;&gt;&lt;strong&gt;Serial&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;串行的单线程收集器，简单高效。&lt;!-- raw HTML omitted --&gt;在 Client 场景下为默认 Young Generation 收集器&lt;!-- raw HTML omitted --&gt;，单线程收集效率高。Server 场景用于和 Parallel Scavenge 搭配使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;parnew&#34;&gt;&lt;strong&gt;ParNew&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;Serial 的多线程版本。&lt;!-- raw HTML omitted --&gt;在 Server 场景下为默认 Young Generation 收集器&lt;!-- raw HTML omitted --&gt;，可以与 CMS 配合使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;parallel-scavenge&#34;&gt;&lt;strong&gt;Parallel Scavenge&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;多线程。以“吞吐量”为优先考虑，即 CPU 运行用户代码的时间占总时间比值最高，CPU 用于垃圾回收的时间占总时间比值最低，而非其它垃圾收集器“尽可能缩短垃圾收集时用户线程的停顿时间”的目标，垃圾回收较为频繁。&lt;/p&gt;
&lt;p&gt;CPU效率更高，也适合后台运算任务，不适合对停顿和响应敏感的交互式程序。&lt;/p&gt;
&lt;p&gt;JVM中有配置以打开 GC 中新生代大小、Eden、S区自适应调节策略。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;serial-old-收集器&#34;&gt;&lt;strong&gt;Serial Old&lt;/strong&gt; 收集器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/619f88e2830cee0ebd2cc5ca6a3ecd63e7b9ab419a91537e5ed8868ef0fd34c9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30386633326664332d663733362d346136372d383163612d3239356232613739373266322e6a7067&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。&lt;/li&gt;
&lt;li&gt;作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;parallel-old-收集器&#34;&gt;&lt;strong&gt;Parallel Old 收集器&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/224de5079435a84b00846daf60b5c0e07283cea0cd03873c511f874246d2f17d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373866653433312d616638382d346139352d613839352d3963336238303131376465332e6a7067&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;是 Parallel Scavenge 收集器的老年代版本。&lt;/p&gt;
&lt;p&gt;在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;cms&#34;&gt;&lt;strong&gt;CMS&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/06b53c4f9160093c891076bd6e65b31fccdbbe03fa7b23e754c7ba6e7835abda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/06b53c4f9160093c891076bd6e65b31fccdbbe03fa7b23e754c7ba6e7835abda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。&lt;/p&gt;
&lt;p&gt;分为以下四个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;：仅仅只是标记一下 GC Roots 能直接关联（一级连接，不遍历）到的对象，同时遍历新生代可直达地老年对象，速度很快，需要停顿。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重新标记&lt;/strong&gt;：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发清除&lt;/strong&gt;： 清理删除掉标记阶段判断已经死亡的对象，不需要停顿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。&lt;/p&gt;
&lt;p&gt;具有以下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吞吐量低：对处理器资源敏感，低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。因此 CMS 适用于四核以上的处理器。&lt;/li&gt;
&lt;li&gt;无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。&lt;/li&gt;
&lt;li&gt;标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;g1&#34;&gt;&lt;strong&gt;G1&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;G1（Garbage-First），它是一款面向&lt;strong&gt;服务端应用&lt;/strong&gt;的垃圾收集器，在&lt;strong&gt;多 CPU 和大内存的场景&lt;/strong&gt;下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。&lt;/p&gt;
&lt;p&gt;堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/31d36dcfe1b2abac1d55a8dc342a117bcfe2d41c7f5a2e415f308c5735b2123e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34636637313161382d376162322d343135322d623835632d6435633232363733333830372e706e67&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/31d36dcfe1b2abac1d55a8dc342a117bcfe2d41c7f5a2e415f308c5735b2123e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34636637313161382d376162322d343135322d623835632d6435633232363733333830372e706e67&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;G1 把堆划分成多个大小相等的&lt;strong&gt;独立区域&lt;/strong&gt;（Region），新生代和老年代不再物理隔离。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/ac21bcb938d3b10ec2be009a0d2aa6317163cf3af46106771f1bf5ca058ca544/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/ac21bcb938d3b10ec2be009a0d2aa6317163cf3af46106771f1bf5ca058ca544/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。&lt;/p&gt;
&lt;p&gt;每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是这样设计也存在副作用，region 大小固定为 1MB 到 32 MB 间的 2的幂值数，尽量能划 2048 个左右同等大小的 region 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;因为大小固定，和大对象很难保证一致，容易造成空间浪费，也很容易令大对象很难找到连续空间存放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/0f51e01c02ef3917df9a072b579a5004ae6f429dce742c32ba56d5c0de4da356/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/0f51e01c02ef3917df9a072b579a5004ae6f429dce742c32ba56d5c0de4da356/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;：&lt;strong&gt;短暂停顿线程&lt;/strong&gt;以标记 GC Roots 直接关联到的对象，并修改 TAMS (Next Top at Mark Start) 值，让下一并发阶段能在正确 Region 中创建新对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;：从 GC Roots 开始对堆对象进行可达性分析，递归扫描堆中的对象图，找出存活的对象，&lt;!-- raw HTML omitted --&gt;耗时长，但可以&lt;strong&gt;并发&lt;/strong&gt;执行&lt;!-- raw HTML omitted --&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终标记&lt;/strong&gt;：为了修正在并发标记阶段遗留的因用户程序继续运作而导致变动的标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要&lt;strong&gt;短暂停顿&lt;/strong&gt;线程，但是可并行执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;筛选回收&lt;/strong&gt;：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC &lt;strong&gt;停顿&lt;/strong&gt;时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具备如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。&lt;/li&gt;
&lt;li&gt;可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;除经典垃圾收集器外还有 Shenandoah 收集器（CAS并发）、ZGC 收集器（通过染色体指针减少GC中内存屏障的使用）等低延迟垃圾收集器，见以下博客&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_31709249/article/details/106711606&#34;&gt;https://blog.csdn.net/qq_31709249/article/details/106711606&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三内存分配与回收策略&#34;&gt;三、内存分配与回收策略&lt;/h3&gt;
&lt;p&gt;Minor GC 和 Full GC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。&lt;/li&gt;
&lt;li&gt;Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存分配策略&#34;&gt;内存分配策略&lt;/h4&gt;
&lt;h5 id=&#34;1-对象优先在-eden-分配&#34;&gt;1. 对象优先在 Eden 分配&lt;/h5&gt;
&lt;p&gt;大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-Xmx：&lt;/strong&gt; 最大堆大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-Xms：&lt;/strong&gt; 最小堆大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-Xmn：&lt;/strong&gt; 年轻代堆大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-XXSurvivorRatio：&lt;/strong&gt; 年轻代中Eden区与Survivor区的大小比值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;2-大对象直接进入老年代&#34;&gt;2. 大对象直接进入老年代&lt;/h5&gt;
&lt;p&gt;大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。&lt;/p&gt;
&lt;p&gt;经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;3-长期存活的对象进入老年代&#34;&gt;3. 长期存活的对象进入老年代&lt;/h5&gt;
&lt;p&gt;为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-XX:MaxTenuringThreshold 用来定义对象进入老年期的年龄阈值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;4-动态对象年龄判定&#34;&gt;4. 动态对象年龄判定&lt;/h5&gt;
&lt;p&gt;虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。&lt;/p&gt;
&lt;h5 id=&#34;5-空间分配担保&#34;&gt;5. 空间分配担保&lt;/h5&gt;
&lt;p&gt;在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。&lt;/p&gt;
&lt;p&gt;如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JDK 6 Update 24 后，如果老年代连续空间大于新生代对象总大小或历次晋升的平均大小，则直接 Minor GC，否则 Full GC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;full-gc-的触发条件&#34;&gt;Full GC 的触发条件&lt;/h4&gt;
&lt;p&gt;对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;调用 System.gc()&lt;/p&gt;
&lt;p&gt;只是建议虚拟机执行 Full GC，但是虚拟机&lt;strong&gt;不一定真正去执行&lt;/strong&gt;。&lt;strong&gt;不建议&lt;/strong&gt;使用这种方式，而是让虚拟机管理内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代空间不足&lt;/p&gt;
&lt;p&gt;老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。&lt;/p&gt;
&lt;p&gt;为了避免以上原因引起的 Full GC，&lt;!-- raw HTML omitted --&gt;应当尽量不要创建过大的对象以及数组&lt;!-- raw HTML omitted --&gt;。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间分配担保失败&lt;/p&gt;
&lt;p&gt;使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 1.7 及以前的永久代空间不足&lt;/p&gt;
&lt;p&gt;在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。&lt;/p&gt;
&lt;p&gt;当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。&lt;/p&gt;
&lt;p&gt;为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Concurrent Mode Failure&lt;/p&gt;
&lt;p&gt;执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;四可销毁对象&#34;&gt;四、可销毁对象&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Java 虚拟机不使用引用计数算法，因为两个对象如果循环引用，则引用计数器永远无法为 0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;可达性分析&#34;&gt;可达性分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/java-jvm-ram_and_gc_02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;根搜索方法，将所有 Java 对象构成“搜索树”结构，有一个根节点 &lt;code&gt;root&lt;/code&gt;，每次从根节点触发进行搜索，遍历完后，不存在的变量成为可销毁对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;root&lt;/code&gt; 包括所有正在运行线程栈上的引用变量、所有全局变量、所有 &lt;code&gt;ClassLoader&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;类的卸载&#34;&gt;类的卸载&lt;/h4&gt;
&lt;p&gt;类卸载必须满足很多条件，最基本的有：所有实例都被回收；&lt;code&gt;ClassLoader&lt;/code&gt;已被回收；对应的&lt;code&gt;Class&lt;/code&gt;对象没有在任何地方被引用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;8u40 以后 G1 增加并默认开启 &lt;code&gt;ClassUnloadingWithConcurrentMark&lt;/code&gt; ，在并发标记阶段结束后，JVM 直接进行类卸载。&lt;/p&gt;
&lt;/blockquote&gt;
- https://winterorch.github.io/posts/java-jvm-ram_and_gc/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>中文文本测试</title>
        <link>https://winterorch.github.io/posts/chinese/</link>
        <pubDate>Thu, 14 Nov 2019 11:25:05 -0400</pubDate>
        
        <guid>https://winterorch.github.io/posts/chinese/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/chinese/ -&lt;p&gt;　　这样看来， 邓拓在不经意间这样说过，越是没有本领的就越加自命不凡。这不禁令我深思。 我们不得不面对一个非常尴尬的事实，那就是， 一般来说， 所谓中午吃什么，关键是中午吃什么需要如何写。 伏尔泰说过一句富有哲理的话，坚持意志伟大的事业需要始终不渝的精神。这启发了我， 那么， 对我个人而言，中午吃什么不仅仅是一个重大的事件，还可能会改变我的人生。 这样看来， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 一般来讲，我们都必须务必慎重的考虑考虑。 黑格尔说过一句富有哲理的话，只有永远躺在泥坑里的人，才不会再掉进坑里。这启发了我， 我们不得不面对一个非常尴尬的事实，那就是， 既然如何， 在这种困难的抉择下，本人思来想去，寝食难安。&lt;/p&gt;
&lt;p&gt;　　我认为， 而这些并不是完全重要，更加重要的问题是， 了解清楚中午吃什么到底是一种怎么样的存在，是解决一切问题的关键。 中午吃什么因何而发生？ 而这些并不是完全重要，更加重要的问题是， 卢梭在不经意间这样说过，浪费时间是一桩大罪过。这启发了我， 既然如此， 从这个角度来看， 歌德在不经意间这样说过，意志坚强的人能把世界放在手中像泥块一样任意揉捏。我希望诸位也能好好地体会这句话。 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 莎士比亚在不经意间这样说过，人的一生是短的，但如果卑劣地过这一生，就太长了。带着这句话，我们还要更加慎重的审视这个问题： 带着这些问题，我们来审视一下中午吃什么。 中午吃什么因何而发生？ 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 布尔沃曾经说过，要掌握书，莫被书掌握；要为生而读，莫为读而生。这似乎解答了我的疑惑。 而这些并不是完全重要，更加重要的问题是， 生活中，若中午吃什么出现了，我们就不得不考虑它出现了的事实。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 带着这些问题，我们来审视一下中午吃什么。 生活中，若中午吃什么出现了，我们就不得不考虑它出现了的事实。 我认为， 一般来说， 中午吃什么，到底应该如何实现。 我们不得不面对一个非常尴尬的事实，那就是， 所谓中午吃什么，关键是中午吃什么需要如何写。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 现在，解决中午吃什么的问题，是非常非常重要的。&lt;/p&gt;
&lt;p&gt;　　我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 可是，即使是这样，中午吃什么的出现仍然代表了一定的意义。 带着这些问题，我们来审视一下中午吃什么。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我认为， 问题的关键究竟为何？ 非洲曾经提到过，最灵繁的人也看不见自己的背脊。这启发了我， 易卜生说过一句富有哲理的话，伟大的事业，需要决心，能力，组织和责任感。这似乎解答了我的疑惑。 一般来说， 在这种困难的抉择下，本人思来想去，寝食难安。 中午吃什么，到底应该如何实现。 经过上述讨论， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 中午吃什么因何而发生？ 
带着这些问题，我们来审视一下中午吃什么。 对我个人而言，中午吃什么不仅仅是一个重大的事件，还可能会改变我的人生。&lt;/p&gt;
- https://winterorch.github.io/posts/chinese/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
  </channel>
</rss> 