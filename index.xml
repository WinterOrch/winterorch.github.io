<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图拉国营噄茶馆</title>
    <link>https://winterorch.github.io/</link>
    <description>Recent content on 图拉国营噄茶馆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</copyright>
    <lastBuildDate>Wed, 30 Jun 2021 00:12:58 +0630</lastBuildDate>
    
        <atom:link href="https://winterorch.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Redis - 常用数据类型</title>
        <link>https://winterorch.github.io/posts/redis-data_structure/</link>
        <pubDate>Wed, 30 Jun 2021 00:12:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/redis-data_structure/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/redis-data_structure/ -&lt;p&gt;以下示例代码部分源自 [小专栏] &lt;a href=&#34;https://xiaozhuanlan.com/topic/6845397012&#34;&gt;&lt;strong&gt;剖析面试最常见问题之Redis&lt;/strong&gt;&lt;/a&gt; .&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#658b00&#34;&gt;type&lt;/span&gt; name		&lt;span style=&#34;color:#228b22&#34;&gt;#查看当前 key 的类型&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;string&#34;&gt;String&lt;/h3&gt;
&lt;p&gt;string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 &lt;strong&gt;简单动态字符串&lt;/strong&gt;（simple dynamic string，&lt;strong&gt;SDS&lt;/strong&gt;）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常用命令:&lt;/strong&gt; &lt;code&gt;set,get,strlen,exists,dect,incr,setex&lt;/code&gt; 等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt; ：大多数需要缓存的场景、需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;127.0.0.1:6379&amp;gt; &lt;span style=&#34;color:#658b00&#34;&gt;set&lt;/span&gt; key value &lt;span style=&#34;color:#228b22&#34;&gt;#设置 key-value 类型的值&lt;/span&gt;
OK
127.0.0.1:6379&amp;gt; get key &lt;span style=&#34;color:#228b22&#34;&gt;# 根据 key 获得对应的 value&lt;/span&gt;
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; exists key  &lt;span style=&#34;color:#228b22&#34;&gt;# 判断某个 key 是否存在&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; strlen key &lt;span style=&#34;color:#228b22&#34;&gt;# 返回 key 所储存的字符串值的长度。&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;5&lt;/span&gt;
127.0.0.1:6379&amp;gt; del key &lt;span style=&#34;color:#228b22&#34;&gt;# 删除某个 key 对应的值&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; get key
(nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;作计数器用 （字符串的内容为整数的时候可以使用）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;127.0.0.1:6379&amp;gt; &lt;span style=&#34;color:#658b00&#34;&gt;set&lt;/span&gt; number &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
OK
127.0.0.1:6379&amp;gt; incr number &lt;span style=&#34;color:#228b22&#34;&gt;# 将 key 中储存的数字值增一&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
127.0.0.1:6379&amp;gt; get number
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;2&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; decr number &lt;span style=&#34;color:#228b22&#34;&gt;# 将 key 中储存的数字值减一&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; get number
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;设置过期对所有数据类型都适用&#34;&gt;&lt;strong&gt;设置过期（对所有数据类型都适用）&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;127.0.0.1:6379&amp;gt; expire key  &lt;span style=&#34;color:#b452cd&#34;&gt;60&lt;/span&gt; &lt;span style=&#34;color:#228b22&#34;&gt;# 数据在 60s 后过期&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; setex key &lt;span style=&#34;color:#b452cd&#34;&gt;60&lt;/span&gt; value &lt;span style=&#34;color:#228b22&#34;&gt;# 数据在 60s 后过期 (setex:[set] + [ex]pire)&lt;/span&gt;
OK
127.0.0.1:6379&amp;gt; ttl key &lt;span style=&#34;color:#228b22&#34;&gt;# 查看数据还有多久过期&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;56&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h3 id=&#34;ziplist-压缩列表&#34;&gt;ZipList 压缩列表&lt;/h3&gt;
&lt;p&gt;压缩列表本质是字节数组，可以包含任意多个元素，每个元素可以是字节数组或整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://image-static.segmentfault.com/230/743/2307433878-5c0e7ad049f11_articlex&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;zlbytes&lt;/code&gt;：字节长度，占4字节，因此ZipList最长 $2^{32} - 1$ 字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zltail&lt;/code&gt;：为元素相对起始地址的偏移量，占4字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zllen&lt;/code&gt;：列表元素数目，占2字节，当数目超过 $2^{16}-1$ 时字段无效，只能通过遍历获取数目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;entryX&lt;/code&gt;：若干元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zlend&lt;/code&gt;：结尾字节，&lt;code&gt;0xFF&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h3 id=&#34;list-链表&#34;&gt;List 链表&lt;/h3&gt;
&lt;p&gt;当列表中存储数据量较大，列表通过双向循环链表实现。可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常用命令:&lt;/strong&gt; &lt;code&gt;rpush,lpop,lpush,rpop,lrange、llen&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景:&lt;/strong&gt; 发布与订阅或者说消息队列、慢查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;实现队列&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;127.0.0.1:6379&amp;gt; rpush myList value1 &lt;span style=&#34;color:#228b22&#34;&gt;# 向 list 的头部（右边）添加元素&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; rpush myList value2 value3 &lt;span style=&#34;color:#228b22&#34;&gt;# 向list的头部（最右边）添加多个元素&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;
127.0.0.1:6379&amp;gt; lpop myList &lt;span style=&#34;color:#228b22&#34;&gt;# 将 list的尾部(最左边)元素取出&lt;/span&gt;
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; lrange myList &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#228b22&#34;&gt;# 查看对应下标的list列表， 0 为 start,1为 end&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value3&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; lrange myList &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; -1 &lt;span style=&#34;color:#228b22&#34;&gt;# 查看列表中的所有元素，-1表示倒数第一&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value3&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;实现栈&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;127.0.0.1:6379&amp;gt; rpush myList2 value1 value2 value3
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;
127.0.0.1:6379&amp;gt; rpop myList2 &lt;span style=&#34;color:#228b22&#34;&gt;# 将 list的头部(最右边)元素取出&lt;/span&gt;
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value3&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;通过 &lt;code&gt;lrange&lt;/code&gt; 查看对应下标范围的列表元素：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;127.0.0.1:6379&amp;gt; rpush myList value1 value2 value3
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;
127.0.0.1:6379&amp;gt; lrange myList &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#228b22&#34;&gt;# 查看对应下标的list列表， 0 为 start,1为 end&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; lrange myList &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; -1 &lt;span style=&#34;color:#228b22&#34;&gt;# 查看列表中的所有元素，-1表示倒数第一&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
3) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value3&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过 &lt;code&gt;lrange&lt;/code&gt; 命令，你可以基于 list 实现分页查询，性能非常高！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过 &lt;code&gt;llen&lt;/code&gt; 查看链表长度：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;127.0.0.1:6379&amp;gt; llen myList
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h3 id=&#34;hash-无序散列表&#34;&gt;Hash 无序散列表&lt;/h3&gt;
&lt;p&gt;存储&lt;strong&gt;键值对&lt;/strong&gt;。当数据量较小，使用ZipList存储，否则使用&lt;strong&gt;散列表&lt;/strong&gt;(使用MurmurHash2作为哈希函数)。&lt;/p&gt;
&lt;p&gt;当负载因子大于1，触发扩容，将散列表扩大为2倍。当负载因子小于0.1，触发缩容，缩小为实际负载的2倍大小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常用命令：&lt;/strong&gt; &lt;code&gt;hset,hmset,hexists,hget,hgetall,hkeys,hvals&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景:&lt;/strong&gt; 系统中对象数据的存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;127.0.0.1:6379&amp;gt; hset userInfoKey name &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;guide&amp;#34;&lt;/span&gt; description &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dev&amp;#34;&lt;/span&gt; age &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;24&amp;#34;&lt;/span&gt;
OK
127.0.0.1:6379&amp;gt; hexists userInfoKey name &lt;span style=&#34;color:#228b22&#34;&gt;# 查看 key 对应的 value中指定的字段是否存在。&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; hget userInfoKey name &lt;span style=&#34;color:#228b22&#34;&gt;# 获取存储在哈希表中指定字段的值。&lt;/span&gt;
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;guide&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; hget userInfoKey age
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;24&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; hgetall userInfoKey &lt;span style=&#34;color:#228b22&#34;&gt;# 获取在哈希表中指定 key 的所有字段和值&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;guide&amp;#34;&lt;/span&gt;
3) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;
4) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dev&amp;#34;&lt;/span&gt;
5) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;
6) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;24&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; hkeys userInfoKey &lt;span style=&#34;color:#228b22&#34;&gt;# 获取 key 列表&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;description&amp;#34;&lt;/span&gt;
3) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;age&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; hvals userInfoKey &lt;span style=&#34;color:#228b22&#34;&gt;# 获取 value 列表&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;guide&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dev&amp;#34;&lt;/span&gt;
3) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;24&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; hset userInfoKey name &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;GuideGeGe&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#228b22&#34;&gt;# 修改某个字段对应的值&lt;/span&gt;
127.0.0.1:6379&amp;gt; hget userInfoKey name
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;GuideGeGe&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h4 id=&#34;set-无序集合&#34;&gt;Set 无序集合&lt;/h4&gt;
&lt;p&gt;集合中的元素没有先后顺序，不允许重复数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常用命令：&lt;/strong&gt; &lt;code&gt;sadd,spop,smembers,sismember,scard,sinterstore,sunion&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景:&lt;/strong&gt; 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;127.0.0.1:6379&amp;gt; sadd mySet value1 value2 &lt;span style=&#34;color:#228b22&#34;&gt;# 添加元素进去&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
127.0.0.1:6379&amp;gt; sadd mySet value1 &lt;span style=&#34;color:#228b22&#34;&gt;# 不允许有重复元素&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
127.0.0.1:6379&amp;gt; smembers mySet &lt;span style=&#34;color:#228b22&#34;&gt;# 查看 set 中所有的元素&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; scard mySet &lt;span style=&#34;color:#228b22&#34;&gt;# 查看 set 的长度&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
127.0.0.1:6379&amp;gt; sismember mySet value1 &lt;span style=&#34;color:#228b22&#34;&gt;# 检查某个元素是否存在set 中，只能接收单个元素&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; sadd mySet2 value2 value3
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
127.0.0.1:6379&amp;gt; sinterstore mySet3 mySet mySet2 &lt;span style=&#34;color:#228b22&#34;&gt;# 获取 mySet 和 mySet2 的交集并存放在 mySet3 中&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; smembers mySet3
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h4 id=&#34;sortedset-有序集合&#34;&gt;SortedSet 有序集合&lt;/h4&gt;
&lt;p&gt;存储键值对，有序集合的值被称为分值(score)，必须为浮点数。SortedSet 是唯一既可以跟据成员访问，又可以跟据分值以及分值排列顺序访问元素的结构。有点像是 Java 中 HashMap 和 TreeSet 的结合体。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常用命令：&lt;/strong&gt; &lt;code&gt;zadd,zcard,zscore,zrange,zrevrange,zrem&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景：&lt;/strong&gt; 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;127.0.0.1:6379&amp;gt; zadd myZset 3.0 value1 &lt;span style=&#34;color:#228b22&#34;&gt;# 添加元素到 sorted set 中 3.0 为权重&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; zadd myZset 2.0 value2 1.0 value3 &lt;span style=&#34;color:#228b22&#34;&gt;# 一次添加多个元素&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
127.0.0.1:6379&amp;gt; zcard myZset &lt;span style=&#34;color:#228b22&#34;&gt;# 查看 sorted set 中的元素数量&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;
127.0.0.1:6379&amp;gt; zscore myZset value1 &lt;span style=&#34;color:#228b22&#34;&gt;# 查看某个 value 的权重&lt;/span&gt;
&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;3&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; zrange  myZset &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; -1 &lt;span style=&#34;color:#228b22&#34;&gt;# 顺序输出某个范围区间的元素，0 -1 表示输出所有元素&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value3&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
3) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; zrange  myZset &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#228b22&#34;&gt;# 顺序输出某个范围区间的元素，0 为 start  1 为 stop&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value3&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
127.0.0.1:6379&amp;gt; zrevrange  myZset &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#228b22&#34;&gt;# 逆序输出某个范围区间的元素，0 为 start  1 为 stop&lt;/span&gt;
1) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value1&amp;#34;&lt;/span&gt;
2) &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;value2&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h3 id=&#34;bitmap&#34;&gt;bitmap&lt;/h3&gt;
&lt;p&gt;适用只需要一个 bit 位来表示某个元素对应值或者状态的情况，如是否签到、是否登录等 Java 中使用 &lt;code&gt;bool&lt;/code&gt; 的场景，加之 &lt;code&gt;bitmap&lt;/code&gt; 可以统计设为 1 的位的数量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用命令：&lt;/strong&gt; &lt;code&gt;setbit&lt;/code&gt; 、&lt;code&gt;getbit&lt;/code&gt; 、&lt;code&gt;bitcount&lt;/code&gt;、&lt;code&gt;bitop&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;# SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位&lt;/span&gt;
127.0.0.1:6379&amp;gt; setbit mykey &lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
127.0.0.1:6379&amp;gt; setbit mykey &lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; getbit mykey &lt;span style=&#34;color:#b452cd&#34;&gt;7&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
127.0.0.1:6379&amp;gt; setbit mykey &lt;span style=&#34;color:#b452cd&#34;&gt;6&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
127.0.0.1:6379&amp;gt; setbit mykey &lt;span style=&#34;color:#b452cd&#34;&gt;8&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# 通过 bitcount 统计被被设置为 1 的位的数量。&lt;/span&gt;
127.0.0.1:6379&amp;gt; bitcount mykey
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;用户 ID 经常可以被用来作 &lt;code&gt;bitmap&lt;/code&gt;  上的 &lt;code&gt;offset&lt;/code&gt;，从而可以轻松统计“&amp;hellip;的用户个数”。&lt;/p&gt;
&lt;p&gt;相应的，位操作 &lt;code&gt;BITOP operation destkey key [key ...]&lt;/code&gt; ，支持 &lt;code&gt;AND&lt;/code&gt; &lt;code&gt;OR&lt;/code&gt; &lt;code&gt;NOT&lt;/code&gt; &lt;code&gt;XOR&lt;/code&gt; 四种操作中任意一种参数。&lt;/p&gt;
&lt;p&gt;初始化数据：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;127.0.0.1:6379&amp;gt; setbit &lt;span style=&#34;color:#b452cd&#34;&gt;20210308&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
127.0.0.1:6379&amp;gt; setbit &lt;span style=&#34;color:#b452cd&#34;&gt;20210308&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
127.0.0.1:6379&amp;gt; setbit &lt;span style=&#34;color:#b452cd&#34;&gt;20210309&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;统计 20210308~20210309 总活跃用户数: 1&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;127.0.0.1:6379&amp;gt; bitop and desk1 &lt;span style=&#34;color:#b452cd&#34;&gt;20210308&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;20210309&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; bitcount desk1
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;统计 20210308~20210309 在线活跃用户数: 2&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;127.0.0.1:6379&amp;gt; bitop or desk2 &lt;span style=&#34;color:#b452cd&#34;&gt;20210308&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;20210309&lt;/span&gt;
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;
127.0.0.1:6379&amp;gt; bitcount desk2
(integer) &lt;span style=&#34;color:#b452cd&#34;&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;实际上，如果需要统计日活、月活用户这种，Redis 有一个非常对口的数据结构——HyperLoglog，原理其实类似于布隆滤波器，也是一个哈希过滤器，有一定的误警率，因此一般用于统计日活用户数量之类对精确度没有很高要求的数据。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h3 id=&#34;乐观锁&#34;&gt;乐观锁&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;对应数据库中的 &lt;code&gt;version&lt;/code&gt; 设计&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;watch money		&lt;span style=&#34;color:#228b22&#34;&gt;#使用 watch 当作乐观锁操作&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;被监视数据，如果在事务对其执行操作前被其它线程修改，则在调用 &lt;code&gt;exec&lt;/code&gt; 时会执行失败&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;unwatch		&lt;span style=&#34;color:#228b22&#34;&gt;# 失败，乐观锁已经失效&lt;/span&gt;

watch money		&lt;span style=&#34;color:#228b22&#34;&gt;# 添加新的乐观锁&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
- https://winterorch.github.io/posts/redis-data_structure/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Redis - 面试常见问题</title>
        <link>https://winterorch.github.io/posts/redis-common_questions/</link>
        <pubDate>Tue, 29 Jun 2021 15:30:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/redis-common_questions/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/redis-common_questions/ -&lt;p&gt;常见的内存数据库包括 Memcached 和 Redis。后者相较之下在 k/v 类型数据基础上提供了 list, set, zset, hash 等数据结构存储，并且可扩展性强，能够通过插件增加更多；同时具有容灾机制，支持数据持久化，也有原生集群模式，支持发布订阅模型、Lua 脚本、事务；并且支持更多编程语言，单线程模型更加高效。总而言之功能很强，应用很广。&lt;/p&gt;
&lt;h3 id=&#34;1--简要介绍&#34;&gt;1.  简要介绍&lt;/h3&gt;
&lt;p&gt;Redis 是用 C 开发的内存数据库，非关系型数据库，读写速度快，广泛应用于缓存，也可以做分布式锁、消息队列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis6.0 之前都是&lt;strong&gt;单线程处理&lt;/strong&gt;，仅在4.0增加了对大键值对删除操作的“异步处理”&lt;/li&gt;
&lt;li&gt;服务器&lt;strong&gt;内存使用完&lt;/strong&gt;之后，将不用的数据存到磁盘上&lt;/li&gt;
&lt;li&gt;过期数据的&lt;strong&gt;删除策略&lt;/strong&gt;包括惰性删除与定期删除&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2--缓存的作用&#34;&gt;2.  缓存的作用&lt;/h3&gt;
&lt;p&gt;访问数据库从硬盘中读取，过程较慢。如果用户访问数据为高频数据且不会经常改变，则可以存在缓存中，速度快。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3--删除策略&#34;&gt;3.  删除策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只在取出 &lt;code&gt;key&lt;/code&gt; 的时候才对数据进行过期检查。CPU负担小，但会残留很多过期 &lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定期删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;周期性取一批 &lt;code&gt;key&lt;/code&gt; 执行删除过期 &lt;code&gt;key&lt;/code&gt; 操作，通过限制删除操作执行时长和频率来减少删除操作对 CPU 影响&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;删除策略并不能清理所有过期 &lt;code&gt;key&lt;/code&gt; ，过期 &lt;code&gt;key&lt;/code&gt; 还需要&lt;strong&gt;内存淘汰机制&lt;/strong&gt;解决。&lt;/p&gt;
&lt;p&gt;除了缓解内存消耗，设置过期时间也可以用于满足业务需要，比如验证码、登录Token的有效时间。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;4--内存淘汰机制&#34;&gt;4.  内存淘汰机制&lt;/h3&gt;
&lt;p&gt;跟据从中挑选淘汰数据的数据集不同，分为三大类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从&lt;strong&gt;已设置过期时间的数据集&lt;/strong&gt;中 &lt;code&gt;volatile&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;volatile-lru&lt;/code&gt; (least recently used)&lt;/p&gt;
&lt;p&gt;移除&lt;strong&gt;最近最少使用&lt;/strong&gt;的 &lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;volatile-ttl&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移除&lt;strong&gt;将要过期&lt;/strong&gt;的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;volatile-random&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移除&lt;strong&gt;随机&lt;/strong&gt;选择的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;volatile-lfu&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(4.0新增) 移除&lt;strong&gt;最不经常使用&lt;/strong&gt;的数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从**数据集（所有）**中 &lt;code&gt;allkeys&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;allkeys-lru&lt;/code&gt; (least recently used)&lt;/p&gt;
&lt;p&gt;移除&lt;strong&gt;最近最少使用&lt;/strong&gt;的 &lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;allkeys-random&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移除&lt;strong&gt;随机&lt;/strong&gt;选择的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;allkeys-lfu&lt;/code&gt; (least frequently used)&lt;/p&gt;
&lt;p&gt;(4.0新增) 移除&lt;strong&gt;最不经常使用&lt;/strong&gt;的 &lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不进行数据淘汰 &lt;code&gt;no&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;no-eviction&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;内存不足以容纳新写入数据就直接报错&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;image-20210424145306210.png&#34; alt=&#34;image-20210424145306210&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，Redis通过一个过期字典（类似HashTable）来保存数据过期时间，对应内存淘汰机制中 &lt;code&gt;server.db[i].expires&lt;/code&gt; 。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;5--持久化机制&#34;&gt;5.  持久化机制&lt;/h3&gt;
&lt;p&gt;为了保证Redis挂掉后再重启数据可以进行恢复，需要将内存数据写入硬盘。两种持久化机制分别是快照 (&lt;strong&gt;snapshotting, RDB&lt;/strong&gt;) 和只追加文件 (&lt;strong&gt;append-only file, AOF&lt;/strong&gt;) 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RDB 记录的是内存快照，AOF 记录的是执行过的所有命令。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快照持久化是 Redis 默认采用的持久化方式，可以将快照复制到其他服务器从而创建具相同数据的服务器副本，在 Redis.conf 配置文件中默认有此下配置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;save &lt;span style=&#34;color:#b452cd&#34;&gt;900&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;1&lt;/span&gt;           &lt;span style=&#34;color:#228b22&#34;&gt;#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。&lt;/span&gt;
save &lt;span style=&#34;color:#b452cd&#34;&gt;300&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;10&lt;/span&gt;          &lt;span style=&#34;color:#228b22&#34;&gt;#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。&lt;/span&gt;
save &lt;span style=&#34;color:#b452cd&#34;&gt;60&lt;/span&gt; &lt;span style=&#34;color:#b452cd&#34;&gt;10000&lt;/span&gt;        &lt;span style=&#34;color:#228b22&#34;&gt;#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。&lt;/span&gt;
&lt;span style=&#34;color:#228b22&#34;&gt;# 大部分情况下，15分钟够用，只保留这一条即可&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;RDB提供了三种机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;save&lt;/code&gt; 命令将阻塞服务器主线程直到 RDB 完成 （不推荐）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bgsave&lt;/code&gt; 命令 &lt;code&gt;fork()&lt;/code&gt; 一个子线程在后台异步进行快照操作，&lt;strong&gt;同样会阻塞&lt;/strong&gt;，但只发生在 &lt;code&gt;fork()&lt;/code&gt; 阶段，时间较短。RDB 快照持久化期间父进程修改的数据不会被保存。&lt;/li&gt;
&lt;li&gt;自动，通过配置完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;appendonly yes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。&lt;/p&gt;
&lt;p&gt;在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;appendfsync everysec&lt;/code&gt; 比较好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：写入性能非常高；即时日志文件过大出现后台重写也不会影响客户端读写（&lt;code&gt;fork()&lt;/code&gt;新线程进行重写）；记录方式可读，适合用作紧急恢复&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：日志文件更大，且会带来持续IO，对QPS影响更大&lt;/p&gt;
&lt;h5 id=&#34;总结&#34;&gt;总结&lt;/h5&gt;
&lt;p&gt;Redis 重启时优先载入 AOF，因为 AOF 数据集一般更加完整，但 RDB 更适合用于备份数据库，快速重启，且没有 AOF 潜在 BUG&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;6--redis-60-之前为什么不使用多线程&#34;&gt;6.  Redis 6.0 之前为什么不使用多线程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;单线程开发、维护容易&lt;/li&gt;
&lt;li&gt;Redis性能瓶颈在内存和网络，CPU瓶颈不明显&lt;/li&gt;
&lt;li&gt;多线程带来了死锁、线程上下文切换等问题，甚至可能影响性能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6.0 后引入多线程也是为了提高网络 IO 读写性能，仅用在网络数据读写这类耗时操作上，无需担心线程安全问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;7--事务-transaction&#34;&gt;7.  事务 (Transaction)&lt;/h3&gt;
&lt;p&gt;关系型数据库的事务具备四大特性（ACID），合起来就是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;del&gt;原子性&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;确保都成功或都失败&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis &lt;strong&gt;不具备原子性&lt;/strong&gt;，因为不支持回滚，当然这也带来部分性能提升和开发便捷性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隔离性&lt;/p&gt;
&lt;p&gt;并发访问时，单用户事务不被其他事务所干扰，防止数据损坏&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis &lt;strong&gt;不具备隔离级别概念&lt;/strong&gt;，命令在事务中没有被直接执行。只有发起执行命令时才会执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;del&gt;持久性&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;事务一旦提交，对数据库中数据的改变是持久的，被持久化写到存储器中，不会被系统其它问题改变&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Redis 同样不具备，但是当 AOF 持久化模式下，并且 &lt;code&gt;appendfsync&lt;/code&gt; 选项值为 &lt;code&gt;always&lt;/code&gt; 时，事务具有耐久性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一致性&lt;/p&gt;
&lt;p&gt;执行事务前后数据保持一致，多个事务对同一数据读取的结果相同&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Redis 事务实际提供了将多个命令请求打包功能，再按顺序执行打包的所有命令，且不会被中途打断。具备 &lt;strong&gt;一次性&lt;/strong&gt;、&lt;strong&gt;顺序性&lt;/strong&gt;、&lt;strong&gt;排他性&lt;/strong&gt;，分以下两种情况：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;编译型异常中&lt;/p&gt;
&lt;p&gt;当命令出现错误，后续命令依旧可以添加到命令队列中，但所有命令都不会被执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;运行时异常中&lt;/p&gt;
&lt;p&gt;当命令出现错误，其它命令可以正常执行，只有错误命令抛出异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;8_1-缓存穿透攻击&#34;&gt;8_1. 缓存穿透攻击&lt;/h3&gt;
&lt;p&gt;黑客制造大量不存在 &lt;code&gt;key&lt;/code&gt; 的请求，导致请求直接落到数据库进行查询，没有经过缓存层。&lt;/p&gt;
&lt;p&gt;要解决这一问题，最基本是要做好参数校验，不合法的参数直接抛异常给客户端。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;缓存无效的 &lt;code&gt;key&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即时返回的空对象也将其缓存起来，同时设置过期时间&lt;/p&gt;
&lt;p&gt;但在 &lt;code&gt;key&lt;/code&gt; 变化频繁的情况下，尤其在恶意攻击中可能产生大量无效的 &lt;code&gt;key&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;布隆过滤器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先用布隆过滤器判断请求值是否存在，实际上就是哈希校验&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8_2-缓存击穿&#34;&gt;8_2. 缓存击穿&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;key&lt;/code&gt; 失效的瞬间，大量并发集中访问，直接落在数据库上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设置热点数据不过期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以解决问题，但并不好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;加互斥锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分布式锁来保证对每个 &lt;code&gt;key&lt;/code&gt; 同时只有一个线程查询后端服务，其它线程没有获得分布式锁的权限，只需要等待，从而将高并发压力转移到分布式锁&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;8_3-缓存雪崩&#34;&gt;8_3. 缓存雪崩&lt;/h3&gt;
&lt;p&gt;服务器宕机或断网形成缓存雪崩，对数据库造成压力不可预知，很可能瞬间将数据库压垮。&lt;/p&gt;
&lt;p&gt;实际上就是压力累积超过临界导致的，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增设缓存集群，&lt;strong&gt;异地多活&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;限流降级&lt;/strong&gt;，缓存失效后，通过加锁或队列来控制都数据库写缓存的线程数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据预热&lt;/strong&gt;，预访问数据，使得尽可能多的数据被加载到缓存中，但要注意设置不同的过期时间，使缓存失效的时间点尽量均匀&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;9-单线程模型&#34;&gt;9. 单线程模型&lt;/h3&gt;
&lt;p&gt;Redis 事件处理模型对应其中单线程的&lt;strong&gt;文件事件处理器&lt;/strong&gt;(File Event Handler)，因此是单线程模型。通过 IO 多路复用来监听大量连接，跟据套接字执行任务关联不同的事件处理器，不需要创建多余线程来监听连接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字&lt;/strong&gt;，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h3 id=&#34;10-常见缓存读写策略及如何保证缓存数据库数据一致&#34;&gt;10. 常见缓存读写策略及如何保证缓存数据库数据一致&lt;/h3&gt;
&lt;p&gt;缓存读写策略实际上也就是缓存和数据库间的位置关系，主要有以下三种&lt;/p&gt;
&lt;h4 id=&#34;1-旁路缓存模式-cache-aside-pattern&#34;&gt;1) 旁路缓存模式 (Cache Aside Pattern)&lt;/h4&gt;
&lt;p&gt;适用&lt;strong&gt;读请求较多&lt;/strong&gt;的场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先更新 DB 中数据&lt;/li&gt;
&lt;li&gt;直接删除 cache&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;之所以先更新 DB ，是因为 cache 的删除操作相对快很多，数据不一致的可能性大大降低。相反，如果先删除 cache，此时如果有并行请求直接从 DB 中读取数据，这一操作很可能在 DB 中数据被更新前完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;读：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 cache 中读取数据，读到直接返回&lt;/li&gt;
&lt;li&gt;读不到就从 DB 中读取并返回&lt;/li&gt;
&lt;li&gt;数据放到 cache 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点一、 首次请求数据一定不在 cache ，但是这一问题可以通过热点数据的提前缓存解决。&lt;/p&gt;
&lt;p&gt;缺点二、 写操作如果频繁，则 cache 数据被频繁删除，缓存命中率降低，缓存很大程度上被架空。在强一致场景下需要锁/分布锁保证更新 cache 时不存在线程问题；弱一致场景下可以 cache 和 DB 一起更新，cache 设置较短的过期事件以提高缓存命中率。&lt;/p&gt;
&lt;h4 id=&#34;2-读写穿透模式-readwrite-through-pattern&#34;&gt;2) 读写穿透模式 (Read/Write Through Pattern)&lt;/h4&gt;
&lt;p&gt;cache 负责将数据读取和写入 DB，作为服务端和 DB 间的中间件。然而相当难实现，因为 Redis 不提供 DB 读写功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查 cache，不存在则直接更新 DB&lt;/li&gt;
&lt;li&gt;cache 存在，则先更新 cache，cache 服务自己更新 DB（cache 和 DB 同步更新）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;读：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 cache 读数据，读到直接返回&lt;/li&gt;
&lt;li&gt;没读到就从 DB 加载到 cache，然后返回响应&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 Redis 不提供 DB 读写，这一模式实际上只是在旁路模式上进行了封装。同样具有首次请求数据不在 cache 问题。&lt;/p&gt;
&lt;h4 id=&#34;3-异步缓存写入-write-behind-pattern&#34;&gt;3) 异步缓存写入 (Write Behind Pattern)&lt;/h4&gt;
&lt;p&gt;和 读写穿透模式 相似，但只更新缓存，不直接更新 DB，用异步批量的方式来更新 DB。消息队列中消息异步写入磁盘、MySQL 的 InnoDB Buffer Pool 机制都用到这种策略。&lt;/p&gt;
&lt;p&gt;DB 的写性能非常高，适合数据频繁变化，数据一致性要求又不高的场景，如浏览量、点赞量。&lt;/p&gt;
&lt;p&gt;缺点很明显，数据一致性很难维护，cache 可能在数据异步更新前宕机。&lt;/p&gt;
&lt;h4 id=&#34;如何保证缓存数据库数据一致&#34;&gt;如何保证缓存数据库数据一致&lt;/h4&gt;
&lt;p&gt;旁路缓存模式下，可以增加 cache 更新重试机制——如果 cache 服务不可用而暂时无法删除缓存，就隔一段时间再试，多次失败就将更新失败 key 存入队列，等缓存恢复后进行删除。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h3 id=&#34;11-redis-cluster&#34;&gt;11. Redis Cluster&lt;/h3&gt;
&lt;p&gt;Redis 集群主要解决的是性能问题，在缓存数据量过大的情况下将数据分散到各台 Redis 主机上，可以看作是一种&lt;strong&gt;负载均衡&lt;/strong&gt;手段，方便业务进行横向拓展。&lt;/p&gt;
&lt;p&gt;Redis Cluster 有多个节点，是去中心化的分布式结构，每个节点都负责数据读写操作，各节点间会进行通信。通过分片 (sharding) 来进行数据管理，提供复制和故障转移功能。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;1-hash-slot&#34;&gt;1) Hash Slot&lt;/h4&gt;
&lt;p&gt;共 16384 个槽被平均分配给节点进行管理，每个节点对自己负责的槽进行读写操作。各个节点间彼此通信，知晓其它节点负责管理的槽范围。&lt;/p&gt;
&lt;p&gt;作为一个分布式系统，各结点需要互相通信来维护一份所有其它示例的状态信息，基于 Gossip 协议实现数据的最终一致性。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;2-访问流程&#34;&gt;2) 访问流程&lt;/h4&gt;
&lt;p&gt;客户端访问任意节点时，对数据 &lt;code&gt;key&lt;/code&gt; 按照 CRC16 进行 Hash 计算，然后对运算结果模 16384 ，判断槽是否在当前节点管理范围内：如果在，则执行命令，返回结果；如果不在，返回moved重定向异常，之后由客户端跟据重定向异常中目标节点信息去发送命令。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;3-迁移&#34;&gt;3) 迁移&lt;/h4&gt;
&lt;p&gt;如果节点在迁移过程中收到客户端命令，会返回 ASK 重定向异常。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;hr&gt;
&lt;h3 id=&#34;12-redis-replication&#34;&gt;12. Redis Replication&lt;/h3&gt;
&lt;p&gt;Redis 主从主要解决的是可用性问题，读吞吐量过大情况下，可以通过一主多从来提高可用性和读吞吐量，从机多少取决于读吞吐量大小。&lt;/p&gt;
&lt;p&gt;从机只能读，不能写。主机断开连接，从机仍然连接到主机，只是没有任何写操作传入，如果主机上线，从机依然可以直接获取。通过指令 &lt;code&gt;SLAVEOF no one&lt;/code&gt; 来脱离从机身份。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;1-复制&#34;&gt;1) 复制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SYNC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;每次执行 &lt;code&gt;SYNC&lt;/code&gt; ，主服务器需要 &lt;code&gt;BGSAVE&lt;/code&gt; 来生成 RDB，并发送给从服务器；从服务器载入 RDB 期间阻塞进程，无法处理请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PSYNC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;部分重同步，主服务器收到 &lt;code&gt;PSYNC&lt;/code&gt; 后返回 &lt;code&gt;+CONTINUE&lt;/code&gt; ，示意准备执行部分重同步，然后继续发送新指令以完成同步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主从服务器分别维护“&lt;strong&gt;复制偏移量&lt;/strong&gt;”，记录收到的数据长度（字节数）。通过对比主从复制偏移量可以直到是否处于一致状态。&lt;/p&gt;
&lt;p&gt;主服务器维护一个定长 FIFO 队列，作为复制积压缓冲区。主服务器将写命令发给从机，同时入队到复制积压缓冲区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果从机先前没有复制过任何主机，或执行过 &lt;code&gt;SLAVEOF no one&lt;/code&gt; ，则为了开始新复制而发送 &lt;code&gt;PSYNC ? -1&lt;/code&gt; ，请求主机进行完整重同步。主机返回 &lt;code&gt;+FULLRESYNC &amp;lt;runid&amp;gt; &amp;lt;offsetid&amp;gt;&lt;/code&gt; 示意准备完整重同步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反之，发送 &lt;code&gt;PSYNC &amp;lt;runid&amp;gt; &amp;lt;offset&amp;gt;&lt;/code&gt; ，供主机判断执行哪种同步&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;2-哨兵&#34;&gt;2) 哨兵&lt;/h4&gt;
&lt;p&gt;主从的问题在于一旦主机宕机，从机晋升，将需要人工重新配置其余所有从机，复制新的主机，并改变应用方主机地址，为此需要一个（实际上一般是多个）哨兵来干这件事。&lt;/p&gt;
&lt;p&gt;单个哨兵如果检测到主服务器宕机，不会马上进行 &lt;code&gt;failover&lt;/code&gt; ，而是认为主服务器“&lt;strong&gt;主观下线&lt;/strong&gt;”。当检测到主服务器不可用的哨兵达到一定数量，则哨兵间进行投票，决定接替的从机，切换成功后，通过发布订阅模式，让各个哨兵把监控的从服务器实现切换主机，称为“&lt;strong&gt;客观下线&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客观下线&lt;/strong&gt;后，即使原主机重新上线，也只能作为新主机的从机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：无法在线扩容，集群容量到达上限，不好在线扩容；实现哨兵模式配置有很多选择，较为复杂&lt;/p&gt;
- https://winterorch.github.io/posts/redis-common_questions/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>LeetCode 815 - 公交路线</title>
        <link>https://winterorch.github.io/posts/leetcode-815-bus_routes/</link>
        <pubDate>Sun, 27 Jun 2021 12:11:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-815-bus_routes/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-815-bus_routes/ -&lt;h1 id=&#34;leetcode-815-bus-routes&#34;&gt;[LeetCode] 815. Bus Routes&lt;/h1&gt;
&lt;p&gt;We have a list of bus routes. Each &lt;code&gt;routes[i]&lt;/code&gt; is a bus route that the i-th bus repeats forever. For example if &lt;code&gt;routes[0] = [1, 5, 7]&lt;/code&gt;, this means that the first bus (0-th indexed) travels in the sequence 1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;&amp;hellip; forever.&lt;/p&gt;
&lt;p&gt;We start at bus stop &lt;code&gt;S&lt;/code&gt; (initially not on a bus), and we want to go to bus stop &lt;code&gt;T&lt;/code&gt;. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
Output: 2
Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
Output: -1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes.length &amp;lt;= 500&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes[i].length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;All the values of &lt;code&gt;routes[i]&lt;/code&gt; are &lt;strong&gt;unique&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum(routes[i].length) &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= routes[i][j] &amp;lt; 10^6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= source, target &amp;lt; 10^6&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;顺便贴一下两年前这道题的提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Note:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes.length &amp;lt;= 500&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes[i].length &amp;lt;= 500&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= routes[i][j] &amp;lt; 10 ^ 6&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解--图压缩---最短路径算法&#34;&gt;题解  图压缩 +  最短路径算法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;类似题：&lt;a href=&#34;https://github.com/grandyang/leetcode/issues/126&#34;&gt;LeetCode 127 Word Ladder II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看一下两年前和现在对案例限制的不同就可以看出来——力抠把这道题图的成分提升了，并且告诉你了一条公交路线里不会有重复站点，最终要的是，&lt;strong&gt;明确了公交站台的数量远远高于公交线路的数量&lt;/strong&gt;&lt;del&gt;（最离谱的是最后一个案例，尼玛十几条公交线路总共经过了五六万个站，要是在城市天际线里搞这种线路，小人上班还没坐到单位就老死了好吗）&lt;/del&gt;，换句话说，如果不进行压缩，直接以公交站为结点进行 BFS ，你的图会相当大，如果压缩了，那效率上一定是有收益的。因此有必要将站台图压缩成&lt;strong&gt;公交线路的邻接图&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = routes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[][] edge = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n][n];
Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; rec = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : routes[i]) {
        List&amp;lt;Integer&amp;gt; list = rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(site, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j : list) {
            edge[i][j] = edge[j][i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
        list.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(i);
        rec.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(site, list);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样下来，在搜索过程中队列中保存的就都是公交路线号而不是站台号了，那么&lt;!-- raw HTML omitted --&gt;起点和终点&lt;!-- raw HTML omitted --&gt;也就不是站台，而是&lt;!-- raw HTML omitted --&gt;经过相应站台所有公交线路的集合&lt;!-- raw HTML omitted --&gt;了，这其实就和 127 题那个单词编辑步长特别相似了，用 BFS 应当是可以的，而且其实这里的公交都是环线，完全可以用双向 BFS 进行优化（当发现一道 BFS 题的起点和终点可以互换，换句话说图是无向的，基本都可以用上双向 BFS）。&lt;/p&gt;
&lt;p&gt;然而官答这里直接当成图来做了，直接算了个到所有（除经过起始站的之外）其它公交线路的最少转车站数，用的还是 SPFA，考虑到最后判题案例中其实充斥的都是站点繁多但实际上连通却不多的稀疏图，这样的选择反而相当高效。&lt;del&gt;所以说合适的输入案例是最有效的优化。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;虽然 OJ 里无环的情况下还是迪杰斯特拉稳妥一些，但 Leetcode 上基本 SPFA 完全没有问题，写起来还方便，直接用队列不断更新相邻结点的最小距离，一旦距离进行更新就将该结点也丢进队列里，继续更新，直到队列为空。这一算法在稀疏图中效率非常高。&lt;/p&gt;
&lt;p&gt;得到的结果里去找能到终点的最小距离就行了，整个算法理解起来非常简单。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] dis = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
Arrays.&lt;span style=&#34;color:#658b00&#34;&gt;fill&lt;/span&gt;(dis, -1);
Queue&amp;lt;Integer&amp;gt; que = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(source, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;())) {
    dis[site] = 1;
    que.&lt;span style=&#34;color:#658b00&#34;&gt;offer&lt;/span&gt;(site);
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!que.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x = que.&lt;span style=&#34;color:#658b00&#34;&gt;poll&lt;/span&gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; y = 0; y &amp;lt; n; y++) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (edge[x][y] &amp;amp;&amp;amp; dis[y] == -1) {
            dis[y] = dis[x] + 1;
            que.&lt;span style=&#34;color:#658b00&#34;&gt;offer&lt;/span&gt;(y);
        }
    }
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ret = Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MAX_VALUE&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(target, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;())) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (dis[site] != -1) {
        ret = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(ret, dis[site]);
    }
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ret == Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MAX_VALUE&lt;/span&gt; ? -1 : ret;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码总和&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;numBusesToDestination&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[][] routes, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; source, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; target) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (source == target) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = routes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[][] edge = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n][n];
    Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; rec = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : routes[i]) {
            List&amp;lt;Integer&amp;gt; list = rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(site, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j : list) {
                edge[i][j] = edge[j][i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            }
            list.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(i);
            rec.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(site, list);
        }
    }

    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] dis = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
    Arrays.&lt;span style=&#34;color:#658b00&#34;&gt;fill&lt;/span&gt;(dis, -1);
    Queue&amp;lt;Integer&amp;gt; que = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(source, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;())) {
        dis[site] = 1;
        que.&lt;span style=&#34;color:#658b00&#34;&gt;offer&lt;/span&gt;(site);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!que.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x = que.&lt;span style=&#34;color:#658b00&#34;&gt;poll&lt;/span&gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; y = 0; y &amp;lt; n; y++) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (edge[x][y] &amp;amp;&amp;amp; dis[y] == -1) {
                dis[y] = dis[x] + 1;
                que.&lt;span style=&#34;color:#658b00&#34;&gt;offer&lt;/span&gt;(y);
            }
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ret = Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MAX_VALUE&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(target, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;())) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (dis[site] != -1) {
            ret = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(ret, dis[site]);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ret == Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MAX_VALUE&lt;/span&gt; ? -1 : ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;题解---bfs&#34;&gt;题解   BFS&lt;/h3&gt;
&lt;p&gt;这里再写一个双向 BFS 。压缩部分和前面是一样的，问题是搜索部分。&lt;/p&gt;
&lt;p&gt;首先，将起点和终点（其实是经过起点和终点的所有公交线路）分别装入两个方向的 BFS 队列中，如果这里就发现有一样的，那说明有车能从起点直达终点，不用搜了，直接输出 &lt;code&gt;1&lt;/code&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[] vis = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n];
Deque&amp;lt;Integer&amp;gt; src_q, des_q;
List&amp;lt;Integer&amp;gt; tar = rec.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(source);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tar == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
    src_q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(tar);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (Integer i : tar) {
        vis[i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
    }
}
tar = rec.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(target);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tar == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
    des_q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(tar);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (Integer i : tar) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (vis[i])
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 1;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
            vis[i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来就是双向 BFS，既然是 BFS，我们每次走一步，搜一步能到的所有公交线路，如果搜到路线出现在另一方向的队列中，说明两个队列接上了，直接输出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; src_steps = 0, des_steps = 1;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!src_q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !des_q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
    Deque&amp;lt;Integer&amp;gt; front, back;
  
  	&lt;span style=&#34;color:#228b22&#34;&gt;// 每次挑元素少的队列进行 BFS，从而收缩搜索范围
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (src_q.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;gt; des_q.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
        front = des_q;
        back = src_q;
        ++des_steps;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        front = src_q;
        back = des_q;
        ++src_steps;
    }
  
  	&lt;span style=&#34;color:#228b22&#34;&gt;// 检查邻结点中有没有能到对面（即另一个方向的队列）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = front.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;(); i &amp;gt; 0; --i) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; t = front.&lt;span style=&#34;color:#658b00&#34;&gt;removeFirst&lt;/span&gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; n; ++j) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (edge[t][j] &amp;amp;&amp;amp; !vis[j]) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!vis[j]) {
                    vis[j] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
                    front.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(j);
                } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (back.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(j)) {
                        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; src_steps + des_steps;
                    }
                }
            }
        }
    }
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码总和&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;numBusesToDestination&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[][] routes, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; source, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; target) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (source == target) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = routes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[][] edge = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n][n];
    Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; rec = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : routes[i]) {
            List&amp;lt;Integer&amp;gt; list = rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(site, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j : list) {
                edge[i][j] = edge[j][i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            }
            list.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(i);
            rec.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(site, list);
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[] vis = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n];
    Deque&amp;lt;Integer&amp;gt; src_q, des_q;
    List&amp;lt;Integer&amp;gt; tar = rec.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(source);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tar == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        src_q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(tar);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (Integer i : tar) {
            vis[i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
    }
    tar = rec.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(target);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tar == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        des_q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(tar);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (Integer i : tar) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (vis[i])
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 1;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
                vis[i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; src_steps = 0, des_steps = 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!src_q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !des_q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
        Deque&amp;lt;Integer&amp;gt; front, back;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (src_q.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;gt; des_q.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
            front = des_q;
            back = src_q;
            ++des_steps;
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            front = src_q;
            back = des_q;
            ++src_steps;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = front.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;(); i &amp;gt; 0; --i) {
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; t = front.&lt;span style=&#34;color:#658b00&#34;&gt;removeFirst&lt;/span&gt;();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; n; ++j) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (edge[t][j]) {
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!vis[j]) {
                        vis[j] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
                        front.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(j);
                    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (back.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(j)) {
                            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; src_steps + des_steps;
                        }
                    }
                }
            }
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;这道题反正无论如何都绕不开图压缩了。搜索上，两种方法最终时间相差无几（指用 Leetcode 案例前提下），最小路径算法其实有些超过题目需求了，不过 SPFA 很契合这道题的场景，因此效率还是很高，加上写起来方便（重点），略优于双向 BFS。&lt;/p&gt;
- https://winterorch.github.io/posts/leetcode-815-bus_routes/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Python - PYQT 踩坑记</title>
        <link>https://winterorch.github.io/posts/python-pyqt-starter/</link>
        <pubDate>Fri, 25 Jun 2021 19:32:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/python-pyqt-starter/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/python-pyqt-starter/ -&lt;p&gt;首先要踩一下 PYQT，如果使用 Python 过程中有 GUI 方面的需求，请一定一定先看有没有 QT 之外的选择~~（就是，那个，D 开头的那个，懂我意思吧（疯狂暗示不要做 GUI 程序））~~。用过 PYQT 的都知道，QT 提供的不仅仅是 GUI 组件库，而是从线程到网络通信的一整套 &lt;code&gt;QObject&lt;/code&gt; ，个人认为对于 Python 而言这实在是过于不实际了，我觉得大多数人对于 Python 开发的期望都是每一个模块各司其职，项目能够“高内聚，低耦合”，Python 在这方面也是非常令人满意的，然而在 QT 中除外。&lt;/p&gt;
&lt;p&gt;PYQT 来源于 C++ QT，其理念就是将众多组件耦合到一起，如果你在一个团队中进行开发，这会导致——无论是图形界面方面的责任，还是业务逻辑方面的问题都会堆到你这里，成为你的压力，而如果你作为个人进行开发，这会使你写 GUI 的时候无时无刻不得顾及业务需求，两边都得顾得上，两边都得一起调。出了问题的话，非常不幸，网上能找到的 PYQT 资料非常之有限，甚至官方文档中都有大量的 &lt;code&gt;TODO&lt;/code&gt; ，且完全没有要补上的迹象，我写代码过程中基本都只能参考 QT 的官方文档，因为他实在是比 PyQt 官方提供的要友好得多。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果在确认了这些问题之后，还是要入门 PYQT，推荐几个 Github：&lt;a href=&#34;https://github.com/PyQt5/PyQt&#34;&gt;PyQt Examples&lt;/a&gt; 提供了大部分常用 GUI 组件的使用 Deemo，虽然 PyQt 对于这些组件基本都有大量复杂数倍的替代品，供你完成非常繁杂的需求，但是，没有谁想从那入手的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺便提一下，有个非常不错（指功能上）的 PyQt 音乐播放器 &lt;a href=&#34;https://github.com/feeluown/FeelUOwn&#34;&gt;FeelUOwn&lt;/a&gt; 项目。当时看到这个小项目是很感动的，非常兴奋地下下来源码，然后确信自己看的是天书——项目代码不是给人读的，PyQt 极大放大了代码可读性差的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来是正片——&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;开始-pyqt-项目你要知道这些&#34;&gt;开始 PyQt 项目，你要知道这些&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果用 PyCharm 构建 PyQt 项目，你在点下 Run/Debug 之前请务必检查一下 &lt;strong&gt;Debug 配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Run 和 Debug 图标左边那个下拉菜单，其中的 Edit Configurations，请检查一下 Configuration 下的 Excution 栏，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;确保 &lt;code&gt;Emulate terminal in output console&lt;/code&gt; 这个选项勾上&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。否则即使你的程序挂掉，控制台也不会抛出一个异常来，没有什么比程序跑不起来，甚至连哪里出了问题都无法追溯更让人头疼的事情了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;使用-qss-你要知道这些&#34;&gt;使用 QSS ，你要知道这些&lt;/h3&gt;
&lt;p&gt;QSS 看似很美好，但也是重灾区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4 id=&#34;qss-style-sheet-会自动由父框架传递给子框架&#34;&gt;&lt;strong&gt;QSS Style Sheet 会自动由父框架传递给子框架&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;什么意思呢？就是说你可能想给 &lt;code&gt;QWidget&lt;/code&gt; 设个好看的边框，于是写下这么一段内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;QWidget&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;background&lt;/span&gt;: lightGray;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;border&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;solid&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;blue&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后发现所有 &lt;code&gt;Widget&lt;/code&gt; 下所有的 &lt;code&gt;QLabel&lt;/code&gt; 都诡异地多了个框而父框架反而没有。为什么呢？因为 &lt;code&gt;QLabel&lt;/code&gt; 也是 &lt;code&gt;QWidget&lt;/code&gt; 的一种，&lt;code&gt;QWidget&lt;/code&gt; 的样式表会自动传递到它，并且生效。然而 &lt;code&gt;QWidget&lt;/code&gt; 自己却不能生效，因为 &lt;code&gt;QWidget&lt;/code&gt; 天生无法让自己的显式样式生效，它们只是用来传递给子框架的，换句话说，Qt 就这么设计的。&lt;/p&gt;
&lt;p&gt;如果想让父框架有边框之类的设置，请用 &lt;code&gt;QFrame&lt;/code&gt; ，它不仅有同样的参数而且几乎能替代 &lt;code&gt;QWidget&lt;/code&gt; 。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;请尽量使用对象的-objectname-来区分子对象的样式&#34;&gt;&lt;strong&gt;请尽量使用对象的 &lt;code&gt;objectName&lt;/code&gt; 来区分子对象的样式&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;如果你想要你的设置仅仅对最外层，或子对象中的一个生效，请这么写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;QWidget&lt;/span&gt;[&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;objectName&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;OutsidePanel&amp;#39;&lt;/span&gt;] {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;background&lt;/span&gt;: lightGray;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;border&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;solid&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;blue&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那什么是 &lt;code&gt;objectName&lt;/code&gt; 呢？它是 &lt;code&gt;QObject&lt;/code&gt; 的一个成员变量，没错，PyQt 在最不需要解耦的地方做了一次解耦，让 &lt;code&gt;objectName&lt;/code&gt; 需要单独设置。所以接下来，在这个你想让它有边框的 &lt;code&gt;QWidget&lt;/code&gt; 的构造函数中写下：&lt;code&gt;self.setObjectName(&amp;quot;OutsidePanel&amp;quot;)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;不推荐将组件的样式表颗粒化，在初始化过程中单独 &lt;code&gt;setStyleSheet()&lt;/code&gt; ，还是推荐将一整个 Panel 的样式整合成一个文件，在父框架进行设置，而避免在运行过程中还要动态加载。我认为 Qt 的设计者也是这样希望的，应当有相应的优化。&lt;/p&gt;
&lt;p&gt;关于 QSS ，网上其实能查到很多内容，比方有人说可以直接跟据对象名和 CSS 一样用 &lt;code&gt;#&lt;/code&gt; 设置对象的样式，实测并不行，推测可能是 PyQt 版本不同，能力也有所不同，很多网上提供的 QSS 属性也并不能生效。虽然 QSS 想让做 GUI 的人尽量用熟悉的方法——CSS来设计，但功能属实有限，不能达到 CSS 的效果不说，还给了有 CSS 使用经验的人过多不切实际的幻想，只能说是将 PyQt 本就有限的样式设置从 GUI 设计中部分解耦出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【未完，对 PyQt ，想吐槽的点实在是如涛涛江水一般】&lt;/p&gt;
- https://winterorch.github.io/posts/python-pyqt-starter/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Spring 依赖注入注解的区分</title>
        <link>https://winterorch.github.io/posts/java-spring-annotation-di_methods/</link>
        <pubDate>Thu, 24 Jun 2021 19:03:58 +0530</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-spring-annotation-di_methods/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-spring-annotation-di_methods/ -&lt;p&gt;Spring 支持的依赖注入有 &lt;code&gt;@Autowired&lt;/code&gt; &lt;code&gt;@Resource&lt;/code&gt; &lt;code&gt;@Inject&lt;/code&gt; 三种&lt;/p&gt;
&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;
&lt;p&gt;来自 &lt;code&gt;org.springframwork.beans.factory.annotation.Autowired&lt;/code&gt; ，装配顺序为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按 &lt;code&gt;type&lt;/code&gt; 在上下文中查找匹配的 bean&lt;/li&gt;
&lt;li&gt;如果有多个 bean，则按照 &lt;code&gt;name&lt;/code&gt; 进行匹配
&lt;ul&gt;
&lt;li&gt;如有 &lt;code&gt;@Qualifier&lt;/code&gt; ，则按指定的 name 进行匹配&lt;/li&gt;
&lt;li&gt;如没有，则按变量名进行匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;匹配不到就报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;@Autowired(required=false)&lt;/code&gt; 则注入失败不抛异常&lt;/p&gt;
&lt;h3 id=&#34;inject&#34;&gt;@Inject&lt;/h3&gt;
&lt;p&gt;Spring 环境下和 &lt;code&gt;@Autowired&lt;/code&gt; 相同，都依赖 &lt;code&gt;AutowiredAnnotationBeanPostProcess&lt;/code&gt; 进行处理，但不能 &lt;code&gt;(required=false)&lt;/code&gt;。&lt;code&gt;@Inject&lt;/code&gt; 由 JSR-330 定义，可以切换到谷歌的 DI 框架——Guice。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Inject&lt;/code&gt; 在 Java EE 包内，SE 环境需要单独引入。&lt;/p&gt;
&lt;h3 id=&#34;resource&#34;&gt;@Resource&lt;/h3&gt;
&lt;p&gt;JSR-250 定义。在 &lt;code&gt;CommonAnnotationBeanPostProcessor&lt;/code&gt; 实现处理。同样有 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt;。装配顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如同时指定 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; ，从上下文找到唯一匹配 bean 进行装配，找不到抛异常&lt;/li&gt;
&lt;li&gt;如指定 &lt;code&gt;name&lt;/code&gt; ，则到上下文找 &lt;code&gt;id&lt;/code&gt; 匹配的 bean 进行装配，找不到抛异常&lt;/li&gt;
&lt;li&gt;如指定 &lt;code&gt;type&lt;/code&gt; ，则到上下文找类型匹配的唯一 bean 进行装配，找不到或找到不唯一都会抛异常&lt;/li&gt;
&lt;li&gt;如果都没有指定，则默认按 &lt;code&gt;byName&lt;/code&gt; 方式装配，找不到再按 &lt;code&gt;byType&lt;/code&gt; 进行装配&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;IDEA 使用 &lt;code&gt;@Autowired&lt;/code&gt; 时很常见警告 Field injection is not recommended。&lt;/p&gt;
&lt;p&gt;Spring 团队建议永远使用构造方法，也就是 &lt;code&gt;c-args&lt;/code&gt; 进行依赖注入。IDEA 对这一警告的默认修改方式也是——创建一个构造器进行依赖注入。并且，跟据 Spring 团队建议，对必须的依赖，应当使用断言进行确认&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Assert.&lt;span style=&#34;color:#658b00&#34;&gt;notNull&lt;/span&gt;(svc, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;svc must not be null&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为什么不能用成员依赖注入呢？&lt;/p&gt;
&lt;p&gt;field 注入虽然简洁，但存在问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于添加依赖过于简单（加个注释），我们很容易无意识地向一个类注入大量依赖，这违反了单一职责原理，因为我们过去通过构造器进行注入，而要是你的构造器出现大量入参，那很容易意识到自己的代码结构不对劲。打个比方——原本要数着钞票买东西的，一下子变成移动支付，点一下付钱了，就容易到了月底为账单发愁，因为我们金钱意识变薄弱了。解决方法就是——继续用构造器注入，因此对于强制依赖，Spring推荐用 &lt;code&gt;c-args&lt;/code&gt; 注入。&lt;/li&gt;
&lt;li&gt;依赖注入与容器本身耦合了，即——类唯一的正常工作方式就是通过容器反射进行实例化，这就像是集成测试一样，不像个健康的类，就像一个人原本你把饭给他就能自己吃，现在非要注射进去一样。为了让类能在容器外使用，自然还是要用 &lt;code&gt;c-args&lt;/code&gt; 和 &lt;code&gt;s-args&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;属性注入不能用来注入 &lt;code&gt;final&lt;/code&gt; 变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;因此 Spring 给出建议：&lt;code&gt;constructor-based&lt;/code&gt; 和 &lt;code&gt;setter-based&lt;/code&gt; DI 可以混用，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;强制依赖就用 &lt;code&gt;constructor-based&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很好理解，类离开强制依赖就无法工作，这和构造方法职能相吻合，也能注入 &lt;code&gt;final&lt;/code&gt; 变量。构造器可以保证这些变量的值不会是 null 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选、可变依赖用 &lt;code&gt;setter-based&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setter&lt;/code&gt; 值应被用于注入非必须依赖，这些依赖可以很方便地被改变或重新注入，否则会需要大量的 null 检查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/java-spring-annotation-di_methods/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>LeetCode 752 - 打开转盘锁</title>
        <link>https://winterorch.github.io/posts/leetcode-752-open_the_lock/</link>
        <pubDate>Thu, 24 Jun 2021 15:11:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-752-open_the_lock/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-752-open_the_lock/ -&lt;h1 id=&#34;leetcode-752-open-the-lock&#34;&gt;[LeetCode] 752. Open the Lock&lt;/h1&gt;
&lt;p&gt;You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &lt;code&gt;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;&lt;/code&gt;. The wheels can rotate freely and wrap around: for example we can turn &lt;code&gt;&#39;9&#39;&lt;/code&gt; to be &lt;code&gt;&#39;0&#39;&lt;/code&gt;, or &lt;code&gt;&#39;0&#39;&lt;/code&gt; to be &lt;code&gt;&#39;9&#39;&lt;/code&gt;. Each move consists of turning one wheel one slot.&lt;/p&gt;
&lt;p&gt;The lock initially starts at &lt;code&gt;&#39;0000&#39;&lt;/code&gt;, a string representing the state of the 4 wheels.&lt;/p&gt;
&lt;p&gt;You are given a list of &lt;code&gt;deadends&lt;/code&gt; dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.&lt;/p&gt;
&lt;p&gt;Given a &lt;code&gt;target&lt;/code&gt; representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;0201&amp;quot;,&amp;quot;0101&amp;quot;,&amp;quot;0102&amp;quot;,&amp;quot;1212&amp;quot;,&amp;quot;2002&amp;quot;], target = &amp;quot;0202&amp;quot;
Output: 6
Explanation:
A sequence of valid moves would be &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;1000&amp;quot; -&amp;gt; &amp;quot;1100&amp;quot; -&amp;gt; &amp;quot;1200&amp;quot; -&amp;gt; &amp;quot;1201&amp;quot; -&amp;gt; &amp;quot;1202&amp;quot; -&amp;gt; &amp;quot;0202&amp;quot;.
Note that a sequence like &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;0001&amp;quot; -&amp;gt; &amp;quot;0002&amp;quot; -&amp;gt; &amp;quot;0102&amp;quot; -&amp;gt; &amp;quot;0202&amp;quot; would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end &amp;quot;0102&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;8888&amp;quot;], target = &amp;quot;0009&amp;quot;
Output: 1
Explanation:
We can turn the last wheel in reverse to move from &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;0009&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;8887&amp;quot;,&amp;quot;8889&amp;quot;,&amp;quot;8878&amp;quot;,&amp;quot;8898&amp;quot;,&amp;quot;8788&amp;quot;,&amp;quot;8988&amp;quot;,&amp;quot;7888&amp;quot;,&amp;quot;9888&amp;quot;], target = &amp;quot;8888&amp;quot;
Output: -1
Explanation:
We can&#39;t reach the target without getting stuck.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 4:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;0000&amp;quot;], target = &amp;quot;8888&amp;quot;
Output: -1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= deadends.length &amp;lt;= 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deadends[i].length == 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target.length == 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;target will not be in the list &lt;code&gt;deadends&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt; and &lt;code&gt;deadends[i]&lt;/code&gt; consist of digits only.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解--双向-bfs&#34;&gt;题解  双向 BFS&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;类似题：&lt;a href=&#34;https://github.com/grandyang/leetcode/issues/126&#34;&gt;LeetCode 127 Word Ladder II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到有 &lt;code&gt;deadends&lt;/code&gt; 其实就比较明显了——这是个走迷宫问题，而且因为有四位密码，所以其实是个四维迷宫。维数并不会增加解法的复杂程度，倒是会严重增加敲代码的繁琐程度。一开始是打算真的和迷宫一样，用四维数组做的，后来发现参数实在太多了，光敲一个位置就要 &lt;code&gt;mem[i0][i1][i2][i3]&lt;/code&gt; 这样来一遍，实在有点头皮发麻，改用 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 来做记忆化了。&lt;/p&gt;
&lt;p&gt;还是当作迷宫来解，因此思想是 BFS ，因为入口和出口都是唯一确定的，前后都可以作为 BFS 的起点，因此可以通过双向 BFS 来收缩搜索范围。&lt;/p&gt;
&lt;p&gt;首先把 &lt;code&gt;deadends&lt;/code&gt; 存到一个 &lt;code&gt;HashSet&lt;/code&gt; 里，方便查验。BFS 需要前后两个队列，分别维护一个记忆化搜索表，记录到 &lt;code&gt;key&lt;/code&gt; 位置的步长。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt; Deque&amp;lt;String&amp;gt; d1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(),
						  d2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
Map&amp;lt;String, Integer&amp;gt; m1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(), 
									 m2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
d1.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(s);
m1.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(s, 0);
d2.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(t);
m2.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(t, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后就是 BFS 了，一直搜到队列空为止。为了尽量收缩双向 BFS 的搜索范围，每次&lt;!-- raw HTML omitted --&gt;从更小的队列取元素进行搜索&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!d1.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !d2.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; t = -1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (d1.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;lt;= d2.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
        t = update(d1, m1, m2);
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        t = update(d2, m2, m1);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (t != -1) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; t;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次搜索要搜相邻的八个位置，也就是每一位的前后两个数字。原数字是 &lt;code&gt;char[i]&lt;/code&gt; 的话，以十为模加一或加九就行了——&lt;code&gt;(char) (&#39;0&#39; + ((chars[i] - &#39;0&#39; + offset) % 10))&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;新状态的检查包括这样一些原则——&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新位置不能是 &lt;code&gt;deadend&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新位置不能已经去过（在同一队列中），同一队列两次经过同一位置步长一定不会变短，也就不需要考虑了&lt;/li&gt;
&lt;li&gt;在满足前两个前提下，如果能在反向记忆中找到相同状态，那一定是最短路径，直接输出&lt;/li&gt;
&lt;li&gt;不在反向记忆中，就加入到当前记忆队列中，从而引起下一轮 BFS&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ori = chars[i];
chars[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;) (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + ((chars[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + offset) % 10));
String go = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(chars);
chars[i] = ori;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(go))
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go))
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go)) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt; = step + 1 + ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(go);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
}
fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(go, step + 1);
fs.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(go);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完整代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; res;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] offset = {1, 9};
Set&amp;lt;String&amp;gt; deadEnds;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;openLock_remastered&lt;/span&gt;(String[] dead, String target) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (target.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;))
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#228b22&#34;&gt;// 虽然这里 IDE 会推荐让 Arrays 来把 String[] 转换成 Collection,但这样做对速度没有好处。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;// IDE 上测出来差别不大，但到了 LeetCode 上居然能让整题多耗将近一倍时间，百思不得其解。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (String str: dead)
        deadEnds.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(str);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (deadEnds.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;))
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    Deque&amp;lt;String&amp;gt; front = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    Map&amp;lt;String, Integer&amp;gt; front_map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    Deque&amp;lt;String&amp;gt; back = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    Map&amp;lt;String, Integer&amp;gt; back_map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    front.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;);
    front_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;, 0);
    back.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(target);
    back_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(target, 0);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!front.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !back.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (front.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;lt; back.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (update(front, front_map, back_map))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt;;
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (update(back, back_map, front_map))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;update&lt;/span&gt;(Deque&amp;lt;String&amp;gt; fs, Map&amp;lt;String, Integer&amp;gt; fs_map, Map&amp;lt;String, Integer&amp;gt; ot_map) {
    String cur = fs.&lt;span style=&#34;color:#658b00&#34;&gt;pollFirst&lt;/span&gt;();
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] chars = cur.&lt;span style=&#34;color:#658b00&#34;&gt;toCharArray&lt;/span&gt;();
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; step = fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(cur);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; offset : &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;offset&lt;/span&gt;) {
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ori = chars[i];
            &lt;span style=&#34;color:#228b22&#34;&gt;// 在原 char[] 上改了，取完 String 再转回去，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// 会比 clone() 新的要快很多
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;					 chars[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;) (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + ((chars[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + offset) % 10));
					 String go = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(chars);
					 chars[i] = ori;	
          
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(go))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go)) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt; = step + 1 + ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(go);
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            }
            fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(go, step + 1);
            fs.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(go);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;题解--astar-算法&#34;&gt;题解  AStar 算法&lt;/h3&gt;
&lt;p&gt;作者：AC_OIer
链接：https://leetcode-cn.com/problems/open-the-lock/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-wyr9/&lt;/p&gt;
&lt;p&gt;可以直接根据本题规则来设计 A* 的「启发式函数」。&lt;/p&gt;
&lt;p&gt;比如对于两个状态 a 和 b 可直接计算出「理论最小转换次数」：不同字符的转换成本之和 。&lt;/p&gt;
&lt;p&gt;需要注意的是：由于我们衡量某个字符 str 的估值是以目标字符串 target 为基准，因此我们只能确保 target 出队时为「距离最短」，而不能确保中间节点出队时「距离最短」，因此我们不能单纯根据某个节点是否「曾经入队」而决定是否入队，还要结合当前节点的「最小距离」是否被更新而决定是否入队。&lt;/p&gt;
&lt;p&gt;这一点十分关键，在代码层面上体现在 map.get(str).step &amp;gt; poll.step + 1 的判断上。&lt;/p&gt;
&lt;p&gt;注意：本题用 A* 过了，但通常我们需要先「确保有解」，A* 的启发搜索才会发挥真正价值。而本题，除非 t 本身在 deadends 中，其余情况我们无法很好提前判断「是否有解」。对于无解的情况 A* 效果不如「双向 BFS」。&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Solution&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Node&lt;/span&gt; {
        String str;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; val, step;
       &lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  str : 对应字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  val : 估值（与目标字符串 target 的最小转换成本）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  step: 对应字符串是经过多少步转换而来
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        */&lt;/span&gt;
        Node(String _str, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; _val, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; _step) {
            str = _str;
            val = _val;
            step = _step;
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;f&lt;/span&gt;(String str) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ans = 0;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++) {
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; cur = str.&lt;span style=&#34;color:#658b00&#34;&gt;charAt&lt;/span&gt;(i) - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, target = t.&lt;span style=&#34;color:#658b00&#34;&gt;charAt&lt;/span&gt;(i) - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; a = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(cur, target), b = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(cur, target);
            &lt;span style=&#34;color:#228b22&#34;&gt;// 在「正向转」和「反向转」之间取 min
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; min = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(b - a, a + 10 - b);
            ans += min;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;
    }
    String s, t;
    Set&amp;lt;String&amp;gt; set = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;openLock&lt;/span&gt;(String[] ds, String _t) {
        s = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;;
        t = _t;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (s.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(t)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (String d : ds) set.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(d);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (set.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(s)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
        
        PriorityQueue&amp;lt;Node&amp;gt; q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;((a,b)-&amp;gt;a.&lt;span style=&#34;color:#658b00&#34;&gt;val&lt;/span&gt;-b.&lt;span style=&#34;color:#658b00&#34;&gt;val&lt;/span&gt;);
        Map&amp;lt;String, Node&amp;gt; map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
        Node root = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Node(s, f(s), 0);
        q.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(root);
        map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(s, root);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
            Node poll = q.&lt;span style=&#34;color:#658b00&#34;&gt;poll&lt;/span&gt;();
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] pcs = poll.&lt;span style=&#34;color:#658b00&#34;&gt;str&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;toCharArray&lt;/span&gt;();
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; step = poll.&lt;span style=&#34;color:#658b00&#34;&gt;step&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (poll.&lt;span style=&#34;color:#658b00&#34;&gt;str&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(t)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; step;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = -1; j &amp;lt;= 1; j++) {
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (j == 0) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; cur = pcs[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; next = (cur + j) % 10;
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (next == -1) next = 9;

                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] clone = pcs.&lt;span style=&#34;color:#658b00&#34;&gt;clone&lt;/span&gt;();
                    clone[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;)(next + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;);
                    String str = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(clone);

                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (set.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(str)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
                    &lt;span style=&#34;color:#228b22&#34;&gt;// 如果 str 还没搜索过，或者 str 的「最短距离」被更新，则入队
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(str) || map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(str).&lt;span style=&#34;color:#658b00&#34;&gt;step&lt;/span&gt; &amp;gt; step + 1) {
                        Node node = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Node(str, step + 1 + f(str), step + 1);
                        map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(str, node);
                        q.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(node);
                    }
                }
            }
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-752-open_the_lock/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
        <link>https://winterorch.github.io/posts/leetcode-jianzhi-056/</link>
        <pubDate>Sun, 20 Jun 2021 21:03:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-jianzhi-056/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-jianzhi-056/ -&lt;h1 id=&#34;剑指-offer-56---i-数组中数字出现的次数httpsleetcode-cncomproblemsshu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/&#34;&gt;剑指 Offer 56 - I. 数组中数字出现的次数&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2 &amp;lt;= nums.length &amp;lt;= 10000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解&#34;&gt;题解&lt;/h3&gt;
&lt;p&gt;时空复杂度已经很明显提示了，要用位运算，异或消除掉出现过两次的数字&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num : nums)
    n ^= num;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果只有一个出现一次的数字，那答案已经出来了。然而这题有两个数字 &lt;code&gt;x, y&lt;/code&gt;，得到的 &lt;code&gt;n&lt;/code&gt; 是两者的异或 &lt;code&gt;n = x ^ y&lt;/code&gt; 。因为 &lt;code&gt;x != y&lt;/code&gt; ，&lt;code&gt;n&lt;/code&gt; 必定有至少一个非零位，接下来肯定得围绕着这个非零位作文章。&lt;/p&gt;
&lt;p&gt;而这个非零位有什么用呢？它告诉我们，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 中有一个 (&lt;code&gt;x&lt;/code&gt;) 在该比特位上非零，另一个 (&lt;code&gt;y&lt;/code&gt;) 为零。前面知道，通过异或只能得出唯一一个出现一次的数字，而现在有两个数字，那思路应当是——把这两个数字区分开来，分成具有不同特点的两组，这样就能分别求出这两个数字了。而现在，这个用来区分的特点有了——在 &lt;code&gt;n&lt;/code&gt; 最低非零位上是否为零。&lt;/p&gt;
&lt;p&gt;因此，接下来要做的就是——再遍历一遍原数组，在 &lt;code&gt;n&lt;/code&gt; 最低非零位上跟据是否为零放到两个 &lt;code&gt;int&lt;/code&gt; 上去异或。&lt;/p&gt;
&lt;p&gt;完整答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;singleNumbers&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x = 0, y = 0, n = 0, m = 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num : nums)               &lt;span style=&#34;color:#228b22&#34;&gt;// 1. 遍历异或
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        n ^= num;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;((n &amp;amp; m) == 0)               &lt;span style=&#34;color:#228b22&#34;&gt;// 2. 循环左移，计算 m
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        m &amp;lt;&amp;lt;= 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num: nums) {              &lt;span style=&#34;color:#228b22&#34;&gt;// 3. 遍历 nums 分组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;((num &amp;amp; m) != 0)
            x ^= num;                 &lt;span style=&#34;color:#228b22&#34;&gt;// 4. 当 num &amp;amp; m != 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
            y ^= num;                 &lt;span style=&#34;color:#228b22&#34;&gt;// 4. 当 num &amp;amp; m == 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] {x, y};          &lt;span style=&#34;color:#228b22&#34;&gt;// 5. 返回出现一次的数字
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-jianzhi-056/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Spring下常用注释.</title>
        <link>https://winterorch.github.io/posts/java-spring-annotation-collection/</link>
        <pubDate>Wed, 16 Jun 2021 14:25:05 -0400</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-spring-annotation-collection/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-spring-annotation-collection/ -&lt;p&gt;首先，在 Spring 4.X 之后（不用 Spring Boot 的话）使用注释需要添加 aop 依赖。虽然不需要这么做了，还是有助于了解 Spring Boot 到底为我们做了什么。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-aop&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;{springframework.version}&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而且需要在 XML 中添加约束并在 &lt;code&gt;context&lt;/code&gt; 中配置扫描范围。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;beans&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;xmlns=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#658b00&#34;&gt;xmlns:xsi=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#658b00&#34;&gt;xmlns:context=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.springframework.org/schema/context&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#658b00&#34;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.springframework.org/schema/beans
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;       http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;       http://www.springframework.org/schema/context
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;       http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;

	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;context:annotation-config/&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;配置扫描范围&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&amp;lt;!--指定注解扫描包--&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;base-package=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;com.yourpackage&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来按类别整理一些最常用的注释。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;bean-的扫描&#34;&gt;&lt;strong&gt;Bean 的扫描&lt;/strong&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;：通过注释方式配置扫描范围，将其下的 &lt;code&gt;@Component&lt;/code&gt; 组件（包括&lt;code&gt;@Controller&lt;/code&gt;、&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Repository&lt;/code&gt;）纳入 IOC 容器. 只能作用于配置类，且 Spring Boot 的入口类不能被纳入到扫描范围中.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Boot 默认的扫描范围是启动类所在包开始，当前包及子包下的所有文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@ComponentScan&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cc.mrbird.demo&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebConfig&lt;/span&gt; {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;可以通过 &lt;code&gt;excludeFilters&lt;/code&gt; 来排除一些组件的扫描，通过 &lt;code&gt;@Filter&lt;/code&gt; 注释完成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@ComponentScan&lt;/span&gt;(value = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cc.mrbird.demo&amp;#34;&lt;/span&gt;,
        excludeFilters = {
          			&lt;span style=&#34;color:#228b22&#34;&gt;// 将注解为 Controller 和 Repository 的类排除
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#707a7c&#34;&gt;@Filter&lt;/span&gt;(type = FilterType.&lt;span style=&#34;color:#658b00&#34;&gt;ANNOTATION&lt;/span&gt;,
                        classes = {Controller.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;, Repository.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;}),
          			&lt;span style=&#34;color:#228b22&#34;&gt;// 排除所有 User 类（及子类、实现类）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#707a7c&#34;&gt;@Filter&lt;/span&gt;(type = FilterType.&lt;span style=&#34;color:#658b00&#34;&gt;ASSIGNABLE_TYPE&lt;/span&gt;, classes = User.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
        })
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebConfig&lt;/span&gt; {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上所示，可以跟据&lt;strong&gt;注释&lt;/strong&gt;或直接指定排除相应&lt;strong&gt;类型&lt;/strong&gt;（包括其子类、实现类）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;includeFilters&lt;/code&gt;的作用和&lt;code&gt;excludeFilters&lt;/code&gt;相反，其指定的是哪些组件需要被扫描：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@ComponentScan&lt;/span&gt;(value = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cc.mrbird.demo&amp;#34;&lt;/span&gt;,
        includeFilters = {
          			&lt;span style=&#34;color:#228b22&#34;&gt;// 仅纳入注释为 Service 的类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#707a7c&#34;&gt;@Filter&lt;/span&gt;(type = FilterType.&lt;span style=&#34;color:#658b00&#34;&gt;ANNOTATION&lt;/span&gt;, classes = Service.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
        }, useDefaultFilters = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebConfig&lt;/span&gt; {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过实现 &lt;code&gt;org.springframework.core.type.filter.TypeFilter&lt;/code&gt;接口可以自定义扫描策略，通过实现 &lt;code&gt;match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)&lt;/code&gt; 方法，返回 &lt;code&gt;true&lt;/code&gt; 说明匹配成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;bean-的注册&#34;&gt;&lt;strong&gt;Bean 的注册&lt;/strong&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Bean&lt;/code&gt;, &lt;code&gt;@Component&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Bean&lt;/code&gt;：通过注解向 IOC 容器注册默认为方法名的 Bean，也可以通过 &lt;code&gt;@Bean(&amp;quot;{name}&amp;quot;)&lt;/code&gt; 来重新命名&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebConfig&lt;/span&gt; {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Bean&lt;/span&gt;()
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; User &lt;span style=&#34;color:#008b45&#34;&gt;user&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; User(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;mrbirdy&amp;#34;&lt;/span&gt;, 18);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;实现了 &lt;code&gt;FactoryBean&amp;lt;T&amp;gt;&lt;/code&gt; 接口的 Bean 是一类特殊的 Bean&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;CherryFactoryBean&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; FactoryBean&amp;lt;Cherry&amp;gt; {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Cherry &lt;span style=&#34;color:#008b45&#34;&gt;getObject&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Cherry();
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; getObjectType() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; Cherry.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;isSingleton&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;isSingleton()&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则每次会调用 &lt;code&gt;getObject()&lt;/code&gt; 从中获取 Bean。&lt;/p&gt;
&lt;p&gt;通过加上前缀 &lt;code&gt;&amp;amp;&lt;/code&gt; 从工厂中取出对应的 Bean&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Object cherryFactoryBean = context.&lt;span style=&#34;color:#658b00&#34;&gt;getBean&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;amp;cherryFactoryBean&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Component&lt;/code&gt;：&lt;code&gt;component-scan&lt;/code&gt; 指定的扫描路径下所有被&lt;code&gt;@Controller&lt;/code&gt;、&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Repository&lt;/code&gt;和&lt;code&gt;@Component&lt;/code&gt;注解标注的类都会被纳入IOC容器中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Component&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#228b22&#34;&gt;// 相当于配置文件中 &amp;lt;bean id=&amp;#34;user&amp;#34; class=&amp;#34;当前注解的类&amp;#34;/&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;User&lt;/span&gt; {
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; String name = ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;说明该类被Spring管理。&lt;code&gt;Component&lt;/code&gt; 类的有参构造方法会被默认用作依赖注入，所以相比在成员变量上加 &lt;code&gt;@Autowire&lt;/code&gt; 来注入依赖，更合适的方法是通过构造方法注入。&lt;/p&gt;
&lt;p&gt;衍生注解：按照MVC三层架构分层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Repository&lt;/code&gt;：用于DAO层，数据库操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Service&lt;/code&gt;：用于Service层，复杂逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Controller&lt;/code&gt;：用于Controller层，接收用户请求并调用Service层返回数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连同&lt;code&gt;@Component&lt;/code&gt;，四个注解功能一样，都代表将某个类注册到Spring中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;bean-的加载&#34;&gt;Bean 的加载&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Scope&lt;/code&gt;, &lt;code&gt;@Lazy&lt;/code&gt;, &lt;code&gt;@Conditional&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Scope&lt;/code&gt;：改变组件的作用域（默认 &lt;code&gt;singleton&lt;/code&gt;）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;singleton&lt;/code&gt;：单实例（默认）,在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取（&lt;code&gt;map.get()&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;：多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt;：一个请求对应一个实例；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session&lt;/code&gt;：同一个session对应一个实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Lazy&lt;/code&gt;：懒加载（针对 &lt;code&gt;singleton&lt;/code&gt; ）&lt;/p&gt;
&lt;p&gt;懒加载的单例不会马上调用方法创建对象并注册，只有当第一次被使用时才会调用方法创建对象并加入容器中。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Conditional&lt;/code&gt;：条件加载，类似于前面 &lt;code&gt;@ComponentScan&lt;/code&gt; 中的 &lt;code&gt;Filter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;@Conditional&lt;/code&gt;注解我们可以指定组件注册的条件，即满足特定条件才将组件纳入到 IOC 容器中。&lt;/p&gt;
&lt;p&gt;在使用该注解之前，我们需要创建一个类，实现&lt;code&gt;Condition&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该接口包含一个&lt;code&gt;matches&lt;/code&gt;方法，包含两个入参:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ConditionContext&lt;/code&gt;：上下文信息；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnnotatedTypeMetadata&lt;/code&gt;：注解信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单完善一下这个实现类:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MyCondition&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; Condition {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;matches&lt;/span&gt;(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String osName = context.&lt;span style=&#34;color:#658b00&#34;&gt;getEnvironment&lt;/span&gt;().&lt;span style=&#34;color:#658b00&#34;&gt;getProperty&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;os.name&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; osName != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; osName.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Windows&amp;#34;&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着将这个条件添加到User Bean注册的地方：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Bean&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Conditional&lt;/span&gt;(MyCondition.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; User &lt;span style=&#34;color:#008b45&#34;&gt;user&lt;/span&gt;() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; User(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;mrbird&amp;#34;&lt;/span&gt;, 18);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在Windows环境下，User这个组件将被成功注册，如果是别的操作系统，这个组件将不会被注册到IOC容器中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;属性注入&#34;&gt;属性注入&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Value&lt;/code&gt;, &lt;code&gt;@ConfigurationProperties&lt;/code&gt;, &lt;code&gt;@PropertySource&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Value&lt;/code&gt;:	Property注入&lt;/p&gt;
&lt;p&gt;可以直接用在成员变量上，也可以用在Setter上&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是 &lt;code&gt;@value&lt;/code&gt;这种方式是不被推荐的，Spring 比较建议的是下面几种读取配置信息的方式。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt;: Properties 读取并与 bean 绑定&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;LibraryProperties&lt;/code&gt; 类上加了 &lt;code&gt;@Component&lt;/code&gt; 注解，我们可以像使用普通 bean 一样将其注入到类中使用。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.boot.context.properties.ConfigurationProperties&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.context.annotation.Configuration&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.stereotype.Component&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;java.util.List&lt;/span&gt;;

&lt;span style=&#34;color:#707a7c&#34;&gt;@Component&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;library&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;LibraryProperties&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String location;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; List&amp;lt;Book&amp;gt; books;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Book&lt;/span&gt; {
        String name;
        String description;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相应的配置文件内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;library:
  location: 湖北武汉加油中国加油
  books:
    - name: 天才基本法
      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。
    - name: 时间的秩序
      description: 为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。
    - name: 了不起的我
      description: 如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？ 如何走出人生的艰难时刻？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后就可以通过 &lt;code&gt;private final LibraryProperties library&lt;/code&gt; 注入 Property 对象了。&lt;/p&gt;
&lt;p&gt;题外话：&lt;code&gt;InitializingBean&lt;/code&gt; 接口下的 &lt;code&gt;afterPropertiesSet()&lt;/code&gt; 方法可以作为一个 Property 注入后的 AOP 使用，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ReadConfigPropertiesApplication&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; InitializingBean {

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; LibraryProperties library;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;ReadConfigPropertiesApplication&lt;/span&gt;(LibraryProperties library) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;library&lt;/span&gt; = library;
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
        SpringApplication.&lt;span style=&#34;color:#658b00&#34;&gt;run&lt;/span&gt;(ReadConfigPropertiesApplication.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;, args);
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;afterPropertiesSet&lt;/span&gt;() {
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(library.&lt;span style=&#34;color:#658b00&#34;&gt;getLocation&lt;/span&gt;());
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(library.&lt;span style=&#34;color:#658b00&#34;&gt;getBooks&lt;/span&gt;());    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;如果 Property类上不加 &lt;code&gt;Component&lt;/code&gt; ，就需要在 SpringBootApplication 上加 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 来注册 Bean ，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@EnableConfigurationProperties&lt;/span&gt;(ProfileProperties.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ReadConfigPropertiesApplication&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; InitializingBean {
 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; ProfileProperties profileProperties;

 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;ReadConfigPropertiesApplication&lt;/span&gt;(ProfileProperties profileProperties) {
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;profileProperties&lt;/span&gt; = profileProperties;
 }

 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
     SpringApplication.&lt;span style=&#34;color:#658b00&#34;&gt;run&lt;/span&gt;(ReadConfigPropertiesApplication.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;, args);
 }

 &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;afterPropertiesSet&lt;/span&gt;() {
     System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(profileProperties.&lt;span style=&#34;color:#658b00&#34;&gt;toString&lt;/span&gt;());
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@PropertySource&lt;/code&gt;: 有单独文件的 properties 可以通过 &lt;code&gt;@PropertySource&lt;/code&gt; 来读取&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.beans.factory.annotation.Value&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.context.annotation.PropertySource&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.stereotype.Component&lt;/span&gt;;

&lt;span style=&#34;color:#707a7c&#34;&gt;@Component&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@PropertySource&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;classpath:website.properties&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebSite&lt;/span&gt; {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Value&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;${url}&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String url;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;校验注解&#34;&gt;校验注解&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这里可以参考 &lt;a href=&#34;https://snailclimb.gitee.io/springboot-guide/#/./docs/spring-bean-validation&#34;&gt;Spring Boot 指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;JSR 提供的校验注解&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Null&lt;/code&gt; 被注释的元素必须为 null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotNull&lt;/code&gt; 被注释的元素必须不为 null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AssertTrue&lt;/code&gt; 被注释的元素必须为 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AssertFalse&lt;/code&gt; 被注释的元素必须为 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Min(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须大于等于指定的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Max(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须小于等于指定的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DecimalMin(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须大于等于指定的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DecimalMax(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须小于等于指定的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Size(max=, min=)&lt;/code&gt; 被注释的元素的大小必须在指定的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Digits (integer, fraction)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须在可接受的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Past&lt;/code&gt; 被注释的元素必须是一个过去的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Future&lt;/code&gt; 被注释的元素必须是一个将来的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pattern(regex=,flag=)&lt;/code&gt; 被注释的元素必须符合指定的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Person&lt;/span&gt; {

    &lt;span style=&#34;color:#707a7c&#34;&gt;@NotNull&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;classId 不能为空&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String classId;

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Size&lt;/span&gt;(max = 33)
    &lt;span style=&#34;color:#707a7c&#34;&gt;@NotNull&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;name 不能为空&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String name;

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Pattern&lt;/span&gt;(regexp = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;((^Man$|^Woman$|^UGM$))&amp;#34;&lt;/span&gt;, message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;sex 值不在可选范围&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#707a7c&#34;&gt;@NotNull&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;sex 不能为空&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String sex;

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Email&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;email 格式不正确&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#707a7c&#34;&gt;@NotNull&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;email 不能为空&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String email;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Hibernate Validator 提供的校验注解&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@NotBlank(message =)&lt;/code&gt; 验证字符串非 null，且长度必须大于 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Email&lt;/code&gt; 被注释的元素必须是电子邮箱地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Length(min=,max=)&lt;/code&gt; 被注释的字符串的大小必须在指定的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotEmpty&lt;/code&gt; 被注释的字符串的必须非空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Range(min=,max=,message=)&lt;/code&gt; 被注释的元素必须在合适的范围内&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;自动装配&#34;&gt;自动装配&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Autowired&lt;/code&gt;, &lt;code&gt;@Resource&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Autowired&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动装配，先&lt;code&gt;byType&lt;/code&gt;再&lt;code&gt;byName&lt;/code&gt;，如果不能唯一自动装配，则需要&lt;code&gt;@Qualifier(value=&amp;quot;xxx&amp;quot;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在成员变量上实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;User&lt;/span&gt; {
   &lt;span style=&#34;color:#707a7c&#34;&gt;@Autowired&lt;/span&gt;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Cat cat;
   &lt;span style=&#34;color:#707a7c&#34;&gt;@Autowired&lt;/span&gt;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Dog dog;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String str;

   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Cat &lt;span style=&#34;color:#008b45&#34;&gt;getCat&lt;/span&gt;() {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; cat;
  }
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Dog &lt;span style=&#34;color:#008b45&#34;&gt;getDog&lt;/span&gt;() {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; dog;
  }
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#008b45&#34;&gt;getStr&lt;/span&gt;() {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; str;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在XML中配置Bean&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;context:annotation-config/&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dog&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;com.kuang.pojo.Dog&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cat&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;com.kuang.pojo.Cat&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;com.kuang.pojo.User&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Qualifer()&lt;/code&gt;：如果bean名字不为类的默认名字，则要加&lt;code&gt;@Qualifer&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Autowired&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Qualifier&lt;/span&gt;(value = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cat2&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Cat cat;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Autowired&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Qualifier&lt;/span&gt;(value = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dog2&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Dog dog;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  
&amp;lt;/br&amp;gt;
  
- #### `@Resource`

  自动装配，先`byName`再`byType`，如果`name`属性指定，则只会按照名称进行装配.

  默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配

  ```java
  public class User {
     //如果允许对象为null，设置required = false,默认为true
     @Resource(name = &amp;quot;cat2&amp;quot;)
     private Cat cat;
     @Resource
     private Dog dog;
     private String str;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 Service 的实现类中使用，将方法标注为 SQL 事务.&lt;/p&gt;
&lt;p&gt;首先需要在入口类上加入 &lt;code&gt;@EnableTransactionManagement&lt;/code&gt; 注解以开启事务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@EnableTransactionManagement&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TransactionApplication&lt;/span&gt; {

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throws&lt;/span&gt; Exception {
        SpringApplication.&lt;span style=&#34;color:#658b00&#34;&gt;run&lt;/span&gt;(TransactionApplication.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再 &lt;code&gt;@Service&lt;/code&gt; 中标注事务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Service&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;UserServiceImpl&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; UserService {

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; UserMapper userMapper;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;UserServiceImpl&lt;/span&gt;(UserMapper userMapper) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;userMapper&lt;/span&gt; = userMapper;
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Transactional&lt;/span&gt;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUser&lt;/span&gt;(User user) {
        userMapper.&lt;span style=&#34;color:#658b00&#34;&gt;save&lt;/span&gt;(user);
        &lt;span style=&#34;color:#228b22&#34;&gt;// 测试事务回滚
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!StringUtils.&lt;span style=&#34;color:#658b00&#34;&gt;hasText&lt;/span&gt;(user.&lt;span style=&#34;color:#658b00&#34;&gt;getUsername&lt;/span&gt;())) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; RuntimeException(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username不能为空&amp;#34;&lt;/span&gt;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果生效，当用户名为空（这里用的是 &lt;code&gt;org.springframework.util&lt;/code&gt; 包下的 &lt;code&gt;hasText()&lt;/code&gt; 方法，要求字符串不为 &lt;code&gt;null&lt;/code&gt; 、长度大于0、不全为空），则会捕获到异常而进行回滚。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt; 同样利用的是 Spring 的 AOP 机制, 这里有两个坑.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意点一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;如果抛出的异常&lt;strong&gt;不是 &lt;code&gt;RuntimeException&lt;/code&gt; 或者 &lt;code&gt;Error&lt;/code&gt; ，也不是 &lt;code&gt;@Transactional&lt;/code&gt; 注解指定的回滚异常类型&lt;/strong&gt;，&lt;strong&gt;则不会进行事务回滚&lt;/strong&gt;。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;所以在自定义需要回滚的异常时，要么继承 &lt;code&gt;RuntimeException&lt;/code&gt; ，要么直接在注释上标出来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Transactional&lt;/span&gt;(rollbackFor = Exception.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUser&lt;/span&gt;(User user) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throws&lt;/span&gt; Exception {
        userMapper.&lt;span style=&#34;color:#658b00&#34;&gt;save&lt;/span&gt;(user);
        &lt;span style=&#34;color:#228b22&#34;&gt;// 测试事务回滚
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!StringUtils.&lt;span style=&#34;color:#658b00&#34;&gt;hasText&lt;/span&gt;(user.&lt;span style=&#34;color:#658b00&#34;&gt;getUsername&lt;/span&gt;())) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username不能为空&amp;#34;&lt;/span&gt;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;注意点二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们在相同 &lt;code&gt;Service&lt;/code&gt; 下的&lt;strong&gt;非事务方法中，对事务方法进行调用，事务同样不会生效&lt;/strong&gt;。如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Service&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;UserServiceImpl&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; UserService {

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; UserMapper userMapper;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;UserServiceImpl&lt;/span&gt;(UserMapper userMapper) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;userMapper&lt;/span&gt; = userMapper;
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUserTest&lt;/span&gt;(User user) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;saveUser&lt;/span&gt;(user);
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Transactional&lt;/span&gt;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUser&lt;/span&gt;(User user) {
        userMapper.&lt;span style=&#34;color:#658b00&#34;&gt;save&lt;/span&gt;(user);
        &lt;span style=&#34;color:#228b22&#34;&gt;// 测试事务回滚
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!StringUtils.&lt;span style=&#34;color:#658b00&#34;&gt;hasText&lt;/span&gt;(user.&lt;span style=&#34;color:#658b00&#34;&gt;getUsername&lt;/span&gt;())) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ParamInvalidException(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username不能为空&amp;#34;&lt;/span&gt;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为 Spring 事务控制通过 AOP 代理实现，通过代理目标对象来增强目标方法，而如果用 &lt;code&gt;this&lt;/code&gt; 调用方法，&lt;code&gt;this&lt;/code&gt; 绕过了代理类（实际上是代理类绕过原类，&lt;code&gt;this&lt;/code&gt; 无视了代理类），直接用了类本身，从而没有触发事务。&lt;/p&gt;
&lt;p&gt;要让代理类重新生效有两种方法&lt;/p&gt;
&lt;p&gt;1、 从 IOC 中获取 Bean 后再调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUserTest&lt;/span&gt;(User user) {
    UserService userService = context.&lt;span style=&#34;color:#658b00&#34;&gt;getBean&lt;/span&gt;(UserService.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;);
    userService.&lt;span style=&#34;color:#658b00&#34;&gt;saveUser&lt;/span&gt;(user);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2、 直接从 AOP 上下文取代理对象进行调用（需要引入 AOP Starter 依赖），且需要再在 SpringBoot 入口类中通过注解&lt;code&gt;@EnableAspectJAutoProxy(exposeProxy = true)&lt;/code&gt;将当前代理对象暴露到 AOP 上下文中（通过 &lt;code&gt;AopContext&lt;/code&gt; 的 &lt;code&gt;ThreadLocal&lt;/code&gt; 实现）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUserTest&lt;/span&gt;(User user) {
    UserService userService = (UserService) AopContext.&lt;span style=&#34;color:#658b00&#34;&gt;currentProxy&lt;/span&gt;();
    userService.&lt;span style=&#34;color:#658b00&#34;&gt;saveUser&lt;/span&gt;(user);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;总之是有种为了舍近求远又额外兜了一大圈的感觉，个人认为写事务就不要代入编程优雅方面的考虑了，没必要在方法单一职责上那么较真。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/java-spring-annotation-collection/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>接口与抽象类的区别</title>
        <link>https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/</link>
        <pubDate>Wed, 02 Jun 2021 20:04:58 +0130</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/ -&lt;p&gt;先简单过一下接口语法中的注意点。&lt;/p&gt;
&lt;h3 id=&#34;注意点&#34;&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口中的变量隐式指定为 &lt;code&gt;public static final&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口中的方法会被隐式指定为 &lt;code&gt;public abstract&lt;/code&gt; （JDK 1.9 后允许 private，其它修饰符会报错）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这也决定了接口中所有方法都必须被实现，当然这一要求有两种特殊的满足方式——抽象类实现接口，那么接口方法不一定要实现，可以由抽象类的子类实现；JDK 1.8 后有默认实现的接口方法也不必被实现类显式实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口不能有构造方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 1.8 后，接口可以有静态方法和方法体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 1.8 后，接口方法可以有默认方法，用 &lt;code&gt;default&lt;/code&gt; 关键字修饰&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与抽象类语法上的区别&#34;&gt;与抽象类语法上的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个类可以实现多个接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个接口可以继承多个其它接口&lt;/p&gt;
&lt;p&gt;Java 接口是对行为的抽象，一个行为本身可以看作多个行为的耦合&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Hockey&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; Sports, Event
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口与抽象类区别&#34;&gt;接口与抽象类区别&lt;/h2&gt;
&lt;p&gt;接口和抽象类语法上的不同在之前两个文档中都已经接释清楚了，这里主要看两者思想上的不同。&lt;/p&gt;
&lt;p&gt;摘取一些《Effective Java》中的说法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接口是对行为的抽象，达到 &lt;strong&gt;API 定义与实现分类&lt;/strong&gt; 的目的，因此支持多实现。甚至可以用没有任何方法的接口，作为 Marker Interface，目的仅仅是进行声明。但是用接口导出常量是不合适的使用，接口应当尽量减少细节泄露，常量应当由类保管。&lt;/p&gt;
&lt;p&gt;相较之下，抽象类的主要目的是 &lt;strong&gt;代码重用&lt;/strong&gt;，本质是不能实例化的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重点有两个——抽象类和接口的本质、目的都不同。&lt;/p&gt;
&lt;h3 id=&#34;本质&#34;&gt;本质&lt;/h3&gt;
&lt;p&gt;抽象类本质是类，因此不能多继承。C++ 允许多继承而 Java 不允许，这体现两者多态思想上的差别。我们知道 Java 继承其实叫 &lt;code&gt;extends&lt;/code&gt; ，严格来讲不叫“继承”，因为在 Java 中，继承首先是一种 &lt;code&gt;is-a&lt;/code&gt; 关系，即 &lt;code&gt;Student&lt;/code&gt; 要继承 &lt;code&gt;Person&lt;/code&gt; ，首先要满足 “&lt;code&gt;Student&lt;/code&gt; &lt;code&gt;is a&lt;/code&gt; &lt;code&gt;Person&lt;/code&gt;” 。这很好理解，按照里氏替换原则 (Liskov Substitution)，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类进行替换。因此这显然不是中文里面继承的语义，因为中文里“儿子继承父亲”，但儿子不可能是父亲，两者有本质区别。&lt;/p&gt;
&lt;p&gt;然后，Java 为什么只允许单继承就很好理解了。如果我想让 A 同时继承 B 和 C，那说明 A is B, A is C，那 B 和 C 之间自然应当满足某种继承关系，三者应当是一个继承链的关系而非继承树的关系，通过单继承也可以表示清楚，并不需要让 A 同时继承 B 和 C。更不用说 C++ 为了实现多继承，其实也带来菱形继承问题，可能造成内存浪费和数据冗余。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C++中因为允许多继承，可能会因为&lt;strong&gt;菱形继承&lt;/strong&gt;造成内存浪费和数据冗余（如两个类BC分别继承同一基类A，再从这两个类派生出一个类D时会有冗余成员），因此最好使用虚继承。虚继承下，D实例内存地址中，BC虚继承来的A部分会通过一个指针分别指向一张虚基表（准确来讲是指向其中的虚基表偏移指针的存储地址，然后通过该指针取出偏移量），从虚基表中取出从基类A虚继承来成员在D内存中的偏移地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;曾看到有博客认为 C++ 多继承机制较为合理，给出的理由是“人可以有父母，那类也应当可以多继承”。结合前文内容，这个理由显然没有什么道理，但是我认为却很好地反映了 Java 中接口的思想。我们知道，对于生物而言，父和母显然是不等价的，母完成了作为母的职责，父完成了作为父的职责，然后才有“子”，因此与其类比为继承，不如类比为接口实现更妥当，因为父、母实际上在这里归根结底是&lt;strong&gt;行为的抽象&lt;/strong&gt;，父类必须实现接口 &lt;code&gt;CanBeFather&lt;/code&gt;，母类必须实现接口 &lt;code&gt;CanBeMother&lt;/code&gt;，这是一种行为关系。这一接口在使用过程中屏蔽了其它底层细节，无论父母是什么学历、有什么资产，这一过程中都不关注，也没有影响，这便是类功能上的解耦，通过一个用来将行为抽象化的接口完成了。&lt;/p&gt;
&lt;h3 id=&#34;目的&#34;&gt;目的&lt;/h3&gt;
&lt;p&gt;目的上面其实也说了，《Effective Java》总结的很到位，接口是对行为的抽象，达到 &lt;strong&gt;API 定义与实现分类&lt;/strong&gt; 的目的。如果一个类可以有多个行为、实现多个功能，那它当然可以实现多个接口。&lt;/p&gt;
&lt;p&gt;而抽象类更多还是用来减少冗余代码，换句话说——提高代码质量、提高可读性、降低维护难度……&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-继承与里氏替换原则&#34;&gt;Java 继承与里氏替换原则&lt;/h2&gt;
&lt;p&gt;Java中子类重写父类方法时&lt;!-- raw HTML omitted --&gt;不能抛出父类中没有抛出的异常&lt;!-- raw HTML omitted --&gt;，编译会不过，不抛是完全可以的。同时，该方法在子类中的访问级别也不能低于超类中的访问级别。&lt;!-- raw HTML omitted --&gt;这两项规则确保可使用超类实例的地方也能使用子类实例，符合&lt;strong&gt;里氏替换原则&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt;只能被隐藏（静态及非静态），不能被覆盖&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态方法&lt;/strong&gt;只能被隐藏，不能覆盖&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态方法&lt;/strong&gt;只能用静态方法隐藏，&lt;strong&gt;非静态方法&lt;/strong&gt;只能用非静态方法覆盖（否则编译不过）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终方法&lt;/strong&gt;不能覆盖。私有方法（private）实际会被隐式指定为 final ，所以同样不能覆盖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象方法&lt;/strong&gt;必须覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时要注意的是关于构造方法的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类实例化对象时，如果子类构造方法没有显式调用父类构造方法，默认调用 &lt;code&gt;super()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子类要使用父类有参构造方法，使用 &lt;code&gt;super(...)&lt;/code&gt; 形式，且 &lt;code&gt;super()&lt;/code&gt; 必须是子类构造方法中第一行语句&lt;/li&gt;
&lt;li&gt;父类没有不带参构造方法，子类构造方法中必须显示调用父类其它构造方法，否则编译不过&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>计算机网络 传输层</title>
        <link>https://winterorch.github.io/posts/computer_network-transport_layer/</link>
        <pubDate>Wed, 02 Jun 2021 09:14:28 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/computer_network-transport_layer/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/computer_network-transport_layer/ -&lt;p&gt;网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tcp-与-udp-协议区别&#34;&gt;TCP 与 UDP 协议区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;连接&lt;/th&gt;
&lt;th&gt;传输可靠性&lt;/th&gt;
&lt;th&gt;传输形式&lt;/th&gt;
&lt;th&gt;传输效率&lt;/th&gt;
&lt;th&gt;所需资源&lt;/th&gt;
&lt;th&gt;应用场景&lt;/th&gt;
&lt;th&gt;首部字节&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TCP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;可靠&lt;/td&gt;
&lt;td&gt;字节流&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;多&lt;/td&gt;
&lt;td&gt;要求数据可靠性&lt;/td&gt;
&lt;td&gt;20 - 60&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;UDP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;td&gt;不可靠&lt;/td&gt;
&lt;td&gt;数据报文段&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;少&lt;/td&gt;
&lt;td&gt;要求通信效率&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tcptransmission-control-protocol&#34;&gt;TCP（Transmission Control Protocol）&lt;/h2&gt;
&lt;p&gt;TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_01.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认号&lt;/strong&gt;   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据偏移&lt;/strong&gt;   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认 ACK&lt;/strong&gt;   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步 SYN&lt;/strong&gt;   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;终止 FIN&lt;/strong&gt;   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口&lt;/strong&gt;   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一tcp-三次握手和四次挥手&#34;&gt;一、TCP 三次握手和四次挥手&lt;/h3&gt;
&lt;p&gt;可靠，TCP 协议的设计都是为了可靠无误&lt;/p&gt;
&lt;h4 id=&#34;11-三次握手&#34;&gt;1.1 三次握手&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/984872f6f3fd869be7b447fa70ace6b992fa9b599d8352b810a2d4893acb901c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/984872f6f3fd869be7b447fa70ace6b992fa9b599d8352b810a2d4893acb901c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67&#34; alt=&#34;TCP三次握手&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端–发送带有 SYN 标志的数据包–一次握手–服务端&lt;/li&gt;
&lt;li&gt;服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端&lt;/li&gt;
&lt;li&gt;客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么这么设计，可以从三次握手后双方获得的信息入手，对于发送方而言：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;自己发送正常&lt;/th&gt;
&lt;th&gt;自己接收正常&lt;/th&gt;
&lt;th&gt;对方发送正常&lt;/th&gt;
&lt;th&gt;对方接收正常&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于接收方而言：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;自己发送正常&lt;/th&gt;
&lt;th&gt;自己接收正常&lt;/th&gt;
&lt;th&gt;对方发送正常&lt;/th&gt;
&lt;th&gt;对方接收正常&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;要接收双方都能完整确认双方接收功能正常，三次握手缺一不可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;第2次握手传回了ACK，为什么还要传回SYN？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;12-四次挥手&#34;&gt;1.2 四次挥手&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;断开一个 TCP 连接则需要“四次挥手”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器-关闭与客户端的连接，发送一个FIN给客户端&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TIME_WAIT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;传达信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A: FIN&lt;/td&gt;
&lt;td&gt;A：我没有数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B：ack&lt;/td&gt;
&lt;td&gt;B：我知道你没数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B：FIN&lt;/td&gt;
&lt;td&gt;B：我没有数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A：ack&lt;/td&gt;
&lt;td&gt;A：我知道你没数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;二tcp-如何保证可靠传输&#34;&gt;二、TCP 如何保证可靠传输&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;**分块：**应用数据被分割成 TCP 认为最适合发送的数据块。&lt;/li&gt;
&lt;li&gt;**有序：**TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验和：&lt;/strong&gt; TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。&lt;/li&gt;
&lt;li&gt;**去重：**TCP 的接收端会丢弃重复的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量控制：&lt;/strong&gt; TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞控制：&lt;/strong&gt; 当网络拥塞时，减少数据的发送。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARQ协议：&lt;/strong&gt; 通过确认和超时机制实现可靠信息传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超时重传：&lt;/strong&gt; 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;21-arq&#34;&gt;2.1 ARQ&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;自动重传请求&lt;/strong&gt;（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。&lt;/p&gt;
&lt;h5 id=&#34;停止等待arq协议&#34;&gt;&lt;strong&gt;停止等待ARQ协议&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;每发完一个分组就停止发送，等待对方确认（回复ACK）。如果超时还没有收到 ACK 确认，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 简单&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 信道利用率低，等待时间长&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;连续arq协议&#34;&gt;&lt;strong&gt;连续ARQ协议&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 信道利用率高，容易实现，即使确认丢失，也不必重传。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-滑动窗口和流量控制&#34;&gt;2.2 滑动窗口和流量控制&lt;/h4&gt;
&lt;p&gt;窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。&lt;/strong&gt; 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。&lt;/p&gt;
&lt;h4 id=&#34;23-拥塞控制&#34;&gt;2.3 拥塞控制&lt;/h4&gt;
&lt;p&gt;拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。&lt;/p&gt;
&lt;p&gt;为了进行拥塞控制，TCP 发送方要维持一个 &lt;strong&gt;拥塞窗口(cwnd)&lt;/strong&gt; 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 窗口基于&lt;strong&gt;字节&lt;/strong&gt;，但这里拥塞窗口的大小单位是&lt;strong&gt;报文段&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP的拥塞控制采用了四种算法，即 &lt;strong&gt;慢开始&lt;/strong&gt; 、 &lt;strong&gt;拥塞避免&lt;/strong&gt; 、&lt;strong&gt;快重传&lt;/strong&gt; 和 &lt;strong&gt;快恢复&lt;/strong&gt;。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，谈论拥塞控制的前提是不会发生流量控制，即接收方有足够大的接收缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_03.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;慢开始：&lt;/strong&gt; 为防止立即注入大量数据导致拥塞，先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。&lt;code&gt;cwnd&lt;/code&gt; 初始值为 1，每经过一个传播轮次，&lt;code&gt;cwnd&lt;/code&gt; 加倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在慢开始阶段出现超时，将令 &lt;code&gt;ssthresh = cwnd / 2&lt;/code&gt; 并重新执行慢开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拥塞避免：&lt;/strong&gt; 拥塞避免算法的思路是让拥塞窗口 &lt;code&gt;cwnd&lt;/code&gt; 缓慢增大，即每经过一个往返时间RTT就把发送方的 &lt;code&gt;cwnd&lt;/code&gt; 加 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;快重传与快恢复：&lt;/strong&gt; 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定下一个报文段丢失，立即重传丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。&lt;/p&gt;
&lt;p&gt;例如收到三个 M&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;，则 M&lt;!-- raw HTML omitted --&gt;3&lt;!-- raw HTML omitted --&gt; 丢失，立即重传 M&lt;!-- raw HTML omitted --&gt;3&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种情况下，丢失个别报文段不认作网络拥塞，因此执行快恢复，令 &lt;code&gt;ssthresh = cwnd / 2&lt;/code&gt; ，&lt;code&gt;cwnd = ssthresh&lt;/code&gt; ，此时&lt;!-- raw HTML omitted --&gt;直接进入拥塞避免&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;慢开始和快恢复的快慢，指的是 &lt;code&gt;cwnd&lt;/code&gt; 的起始值而非增长速率。慢开始 &lt;code&gt;cwnd&lt;/code&gt; 设定为 1，而快恢复 &lt;code&gt;cwnd&lt;/code&gt; 设定为 &lt;code&gt;ssthresh&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;udpuser-datagram-protocol&#34;&gt;UDP（User Datagram Protocol）&lt;/h2&gt;
&lt;p&gt;用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_04.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。&lt;/p&gt;
- https://winterorch.github.io/posts/computer_network-transport_layer/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
  </channel>
</rss> 