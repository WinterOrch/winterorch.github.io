<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图拉国营噄茶馆</title>
    <link>https://winterorch.github.io/</link>
    <description>Recent content on 图拉国营噄茶馆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</copyright>
    <lastBuildDate>Sun, 27 Jun 2021 12:11:58 +0630</lastBuildDate>
    
        <atom:link href="https://winterorch.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>LeetCode 815 - 公交路线</title>
        <link>https://winterorch.github.io/posts/leetcode-815-bus_routes/</link>
        <pubDate>Sun, 27 Jun 2021 12:11:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-815-bus_routes/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-815-bus_routes/ -&lt;h1 id=&#34;leetcode-815-bus-routes&#34;&gt;[LeetCode] 815. Bus Routes&lt;/h1&gt;
&lt;p&gt;We have a list of bus routes. Each &lt;code&gt;routes[i]&lt;/code&gt; is a bus route that the i-th bus repeats forever. For example if &lt;code&gt;routes[0] = [1, 5, 7]&lt;/code&gt;, this means that the first bus (0-th indexed) travels in the sequence 1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;&amp;hellip; forever.&lt;/p&gt;
&lt;p&gt;We start at bus stop &lt;code&gt;S&lt;/code&gt; (initially not on a bus), and we want to go to bus stop &lt;code&gt;T&lt;/code&gt;. Travelling by buses only, what is the least number of buses we must take to reach our destination? Return -1 if it is not possible.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: routes = [[1,2,7],[3,6,7]], source = 1, target = 6
Output: 2
Explanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Example 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
Output: -1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Constraints:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes.length &amp;lt;= 500&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes[i].length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;All the values of &lt;code&gt;routes[i]&lt;/code&gt; are &lt;strong&gt;unique&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum(routes[i].length) &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= routes[i][j] &amp;lt; 10^6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= source, target &amp;lt; 10^6&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;顺便贴一下两年前这道题的提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Note:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes.length &amp;lt;= 500&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= routes[i].length &amp;lt;= 500&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= routes[i][j] &amp;lt; 10 ^ 6&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解--图压缩---最短路径算法&#34;&gt;题解  图压缩 +  最短路径算法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;类似题：&lt;a href=&#34;https://github.com/grandyang/leetcode/issues/126&#34;&gt;LeetCode 127 Word Ladder II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看一下两年前和现在对案例限制的不同就可以看出来——力抠把这道题图的成分提升了，并且告诉你了一条公交路线里不会有重复站点，最终要的是，&lt;strong&gt;明确了公交站台的数量远远高于公交线路的数量&lt;/strong&gt;&lt;del&gt;（最离谱的是最后一个案例，尼玛十几条公交线路总共经过了五六万个站，要是在城市天际线里搞这种线路，小人上班还没坐到单位就老死了好吗）&lt;/del&gt;，换句话说，如果不进行压缩，直接以公交站为结点进行 BFS ，你的图会相当大，如果压缩了，那效率上一定是有收益的。因此有必要将站台图压缩成&lt;strong&gt;公交线路的邻接图&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = routes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[][] edge = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n][n];
Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; rec = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : routes[i]) {
        List&amp;lt;Integer&amp;gt; list = rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(site, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j : list) {
            edge[i][j] = edge[j][i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
        list.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(i);
        rec.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(site, list);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样下来，在搜索过程中队列中保存的就都是公交路线号而不是站台号了，那么&lt;!-- raw HTML omitted --&gt;起点和终点&lt;!-- raw HTML omitted --&gt;也就不是站台，而是&lt;!-- raw HTML omitted --&gt;经过相应站台所有公交线路的集合&lt;!-- raw HTML omitted --&gt;了，这其实就和 127 题那个单词编辑步长特别相似了，用 BFS 应当是可以的，而且其实这里的公交都是环线，完全可以用双向 BFS 进行优化（当发现一道 BFS 题的起点和终点可以互换，换句话说图是无向的，基本都可以用上双向 BFS）。&lt;/p&gt;
&lt;p&gt;然而官答这里直接当成图来做了，直接算了个到所有（除经过起始站的之外）其它公交线路的最少转车站数，用的还是 SPFA，考虑到最后判题案例中其实充斥的都是站点繁多但实际上连通却不多的稀疏图，这样的选择反而相当高效。&lt;del&gt;所以说合适的输入案例是最有效的优化。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;虽然 OJ 里无环的情况下还是迪杰斯特拉稳妥一些，但 Leetcode 上基本 SPFA 完全没有问题，写起来还方便，直接用队列不断更新相邻结点的最小距离，一旦距离进行更新就将该结点也丢进队列里，继续更新，直到队列为空。这一算法在稀疏图中效率非常高。&lt;/p&gt;
&lt;p&gt;得到的结果里去找能到终点的最小距离就行了，整个算法理解起来非常简单。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] dis = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
Arrays.&lt;span style=&#34;color:#658b00&#34;&gt;fill&lt;/span&gt;(dis, -1);
Queue&amp;lt;Integer&amp;gt; que = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(source, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;())) {
    dis[site] = 1;
    que.&lt;span style=&#34;color:#658b00&#34;&gt;offer&lt;/span&gt;(site);
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!que.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x = que.&lt;span style=&#34;color:#658b00&#34;&gt;poll&lt;/span&gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; y = 0; y &amp;lt; n; y++) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (edge[x][y] &amp;amp;&amp;amp; dis[y] == -1) {
            dis[y] = dis[x] + 1;
            que.&lt;span style=&#34;color:#658b00&#34;&gt;offer&lt;/span&gt;(y);
        }
    }
}
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ret = Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MAX_VALUE&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(target, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;())) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (dis[site] != -1) {
        ret = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(ret, dis[site]);
    }
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ret == Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MAX_VALUE&lt;/span&gt; ? -1 : ret;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码总和&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;numBusesToDestination&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[][] routes, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; source, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; target) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (source == target) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = routes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[][] edge = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n][n];
    Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; rec = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : routes[i]) {
            List&amp;lt;Integer&amp;gt; list = rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(site, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j : list) {
                edge[i][j] = edge[j][i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            }
            list.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(i);
            rec.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(site, list);
        }
    }

    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] dis = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
    Arrays.&lt;span style=&#34;color:#658b00&#34;&gt;fill&lt;/span&gt;(dis, -1);
    Queue&amp;lt;Integer&amp;gt; que = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(source, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;())) {
        dis[site] = 1;
        que.&lt;span style=&#34;color:#658b00&#34;&gt;offer&lt;/span&gt;(site);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!que.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x = que.&lt;span style=&#34;color:#658b00&#34;&gt;poll&lt;/span&gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; y = 0; y &amp;lt; n; y++) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (edge[x][y] &amp;amp;&amp;amp; dis[y] == -1) {
                dis[y] = dis[x] + 1;
                que.&lt;span style=&#34;color:#658b00&#34;&gt;offer&lt;/span&gt;(y);
            }
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ret = Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MAX_VALUE&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(target, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;())) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (dis[site] != -1) {
            ret = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(ret, dis[site]);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ret == Integer.&lt;span style=&#34;color:#658b00&#34;&gt;MAX_VALUE&lt;/span&gt; ? -1 : ret;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;题解---bfs&#34;&gt;题解   BFS&lt;/h3&gt;
&lt;p&gt;这里再写一个双向 BFS 。压缩部分和前面是一样的，问题是搜索部分。&lt;/p&gt;
&lt;p&gt;首先，将起点和终点（其实是经过起点和终点的所有公交线路）分别装入两个方向的 BFS 队列中，如果这里就发现有一样的，那说明有车能从起点直达终点，不用搜了，直接输出 &lt;code&gt;1&lt;/code&gt; 。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[] vis = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n];
Deque&amp;lt;Integer&amp;gt; src_q, des_q;
List&amp;lt;Integer&amp;gt; tar = rec.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(source);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tar == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
    src_q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(tar);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (Integer i : tar) {
        vis[i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
    }
}
tar = rec.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(target);
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tar == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
} &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
    des_q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(tar);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (Integer i : tar) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (vis[i])
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 1;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
            vis[i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来就是双向 BFS，既然是 BFS，我们每次走一步，搜一步能到的所有公交线路，如果搜到路线出现在另一方向的队列中，说明两个队列接上了，直接输出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; src_steps = 0, des_steps = 1;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!src_q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !des_q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
    Deque&amp;lt;Integer&amp;gt; front, back;
  
  	&lt;span style=&#34;color:#228b22&#34;&gt;// 每次挑元素少的队列进行 BFS，从而收缩搜索范围
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (src_q.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;gt; des_q.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
        front = des_q;
        back = src_q;
        ++des_steps;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        front = src_q;
        back = des_q;
        ++src_steps;
    }
  
  	&lt;span style=&#34;color:#228b22&#34;&gt;// 检查邻结点中有没有能到对面（即另一个方向的队列）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = front.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;(); i &amp;gt; 0; --i) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; t = front.&lt;span style=&#34;color:#658b00&#34;&gt;removeFirst&lt;/span&gt;();
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; n; ++j) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (edge[t][j] &amp;amp;&amp;amp; !vis[j]) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!vis[j]) {
                    vis[j] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
                    front.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(j);
                } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (back.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(j)) {
                        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; src_steps + des_steps;
                    }
                }
            }
        }
    }
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码总和&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;numBusesToDestination&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[][] routes, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; source, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; target) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (source == target) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = routes.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[][] edge = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n][n];
    Map&amp;lt;Integer, List&amp;lt;Integer&amp;gt;&amp;gt; rec = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; i++) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; site : routes[i]) {
            List&amp;lt;Integer&amp;gt; list = rec.&lt;span style=&#34;color:#658b00&#34;&gt;getOrDefault&lt;/span&gt;(site, &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;());
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j : list) {
                edge[i][j] = edge[j][i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            }
            list.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(i);
            rec.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(site, list);
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[] vis = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt;[n];
    Deque&amp;lt;Integer&amp;gt; src_q, des_q;
    List&amp;lt;Integer&amp;gt; tar = rec.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(source);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tar == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        src_q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(tar);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (Integer i : tar) {
            vis[i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
    }
    tar = rec.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(target);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (tar == &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        des_q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(tar);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (Integer i : tar) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (vis[i])
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 1;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
                vis[i] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; src_steps = 0, des_steps = 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!src_q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !des_q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
        Deque&amp;lt;Integer&amp;gt; front, back;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (src_q.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;gt; des_q.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
            front = des_q;
            back = src_q;
            ++des_steps;
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            front = src_q;
            back = des_q;
            ++src_steps;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = front.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;(); i &amp;gt; 0; --i) {
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; t = front.&lt;span style=&#34;color:#658b00&#34;&gt;removeFirst&lt;/span&gt;();
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = 0; j &amp;lt; n; ++j) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (edge[t][j]) {
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!vis[j]) {
                        vis[j] = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
                        front.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(j);
                    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
                        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (back.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(j)) {
                            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; src_steps + des_steps;
                        }
                    }
                }
            }
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;这道题反正无论如何都绕不开图压缩了。搜索上，两种方法最终时间相差无几（指用 Leetcode 案例前提下），最小路径算法其实有些超过题目需求了，不过 SPFA 很契合这道题的场景，因此效率还是很高，加上写起来方便（重点），略优于双向 BFS。&lt;/p&gt;
- https://winterorch.github.io/posts/leetcode-815-bus_routes/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Python - PYQT 踩坑记</title>
        <link>https://winterorch.github.io/posts/python-pyqt-starter/</link>
        <pubDate>Fri, 25 Jun 2021 19:32:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/python-pyqt-starter/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/python-pyqt-starter/ -&lt;p&gt;首先要踩一下 PYQT，如果使用 Python 过程中有 GUI 方面的需求，请一定一定先看有没有 QT 之外的选择~~（就是，那个，D 开头的那个，懂我意思吧（疯狂暗示不要做 GUI 程序））~~。用过 PYQT 的都知道，QT 提供的不仅仅是 GUI 组件库，而是从线程到网络通信的一整套 &lt;code&gt;QObject&lt;/code&gt; ，个人认为对于 Python 而言这实在是过于不实际了，我觉得大多数人对于 Python 开发的期望都是每一个模块各司其职，项目能够“高内聚，低耦合”，Python 在这方面也是非常令人满意的，然而在 QT 中除外。&lt;/p&gt;
&lt;p&gt;PYQT 来源于 C++ QT，其理念就是将众多组件耦合到一起，如果你在一个团队中进行开发，这会导致——无论是图形界面方面的责任，还是业务逻辑方面的问题都会堆到你这里，成为你的压力，而如果你作为个人进行开发，这会使你写 GUI 的时候无时无刻不得顾及业务需求，两边都得顾得上，两边都得一起调。出了问题的话，非常不幸，网上能找到的 PYQT 资料非常之有限，甚至官方文档中都有大量的 &lt;code&gt;TODO&lt;/code&gt; ，且完全没有要补上的迹象，我写代码过程中基本都只能参考 QT 的官方文档，因为他实在是比 PyQt 官方提供的要友好得多。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果在确认了这些问题之后，还是要入门 PYQT，推荐几个 Github：&lt;a href=&#34;https://github.com/PyQt5/PyQt&#34;&gt;PyQt Examples&lt;/a&gt; 提供了大部分常用 GUI 组件的使用 Deemo，虽然 PyQt 对于这些组件基本都有大量复杂数倍的替代品，供你完成非常繁杂的需求，但是，没有谁想从那入手的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺便提一下，有个非常不错（指功能上）的 PyQt 音乐播放器 &lt;a href=&#34;https://github.com/feeluown/FeelUOwn&#34;&gt;FeelUOwn&lt;/a&gt; 项目。当时看到这个小项目是很感动的，非常兴奋地下下来源码，然后确信自己看的是天书——项目代码不是给人读的，PyQt 极大放大了代码可读性差的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来是正片——&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;开始-pyqt-项目你要知道这些&#34;&gt;开始 PyQt 项目，你要知道这些&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果用 PyCharm 构建 PyQt 项目，你在点下 Run/Debug 之前请务必检查一下 &lt;strong&gt;Debug 配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Run 和 Debug 图标左边那个下拉菜单，其中的 Edit Configurations，请检查一下 Configuration 下的 Excution 栏，&lt;!-- raw HTML omitted --&gt;&lt;strong&gt;确保 &lt;code&gt;Emulate terminal in output console&lt;/code&gt; 这个选项勾上&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。否则即使你的程序挂掉，控制台也不会抛出一个异常来，没有什么比程序跑不起来，甚至连哪里出了问题都无法追溯更让人头疼的事情了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;使用-qss-你要知道这些&#34;&gt;使用 QSS ，你要知道这些&lt;/h3&gt;
&lt;p&gt;QSS 看似很美好，但也是重灾区。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;h4 id=&#34;qss-style-sheet-会自动由父框架传递给子框架&#34;&gt;&lt;strong&gt;QSS Style Sheet 会自动由父框架传递给子框架&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;什么意思呢？就是说你可能想给 &lt;code&gt;QWidget&lt;/code&gt; 设个好看的边框，于是写下这么一段内容：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;QWidget&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;background&lt;/span&gt;: lightGray;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;border&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;solid&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;blue&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后发现所有 &lt;code&gt;Widget&lt;/code&gt; 下所有的 &lt;code&gt;QLabel&lt;/code&gt; 都诡异地多了个框而父框架反而没有。为什么呢？因为 &lt;code&gt;QLabel&lt;/code&gt; 也是 &lt;code&gt;QWidget&lt;/code&gt; 的一种，&lt;code&gt;QWidget&lt;/code&gt; 的样式表会自动传递到它，并且生效。然而 &lt;code&gt;QWidget&lt;/code&gt; 自己却不能生效，因为 &lt;code&gt;QWidget&lt;/code&gt; 天生无法让自己的显式样式生效，它们只是用来传递给子框架的，换句话说，Qt 就这么设计的。&lt;/p&gt;
&lt;p&gt;如果想让父框架有边框之类的设置，请用 &lt;code&gt;QFrame&lt;/code&gt; ，它不仅有同样的参数而且几乎能替代 &lt;code&gt;QWidget&lt;/code&gt; 。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4 id=&#34;请尽量使用对象的-objectname-来区分子对象的样式&#34;&gt;&lt;strong&gt;请尽量使用对象的 &lt;code&gt;objectName&lt;/code&gt; 来区分子对象的样式&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;如果你想要你的设置仅仅对最外层，或子对象中的一个生效，请这么写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-css&#34; data-lang=&#34;css&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;QWidget&lt;/span&gt;[&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;objectName&lt;/span&gt;=&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;OutsidePanel&amp;#39;&lt;/span&gt;] {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;background&lt;/span&gt;: lightGray;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;border&lt;/span&gt;: &lt;span style=&#34;color:#b452cd&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;px&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;solid&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;blue&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;那什么是 &lt;code&gt;objectName&lt;/code&gt; 呢？它是 &lt;code&gt;QObject&lt;/code&gt; 的一个成员变量，没错，PyQt 在最不需要解耦的地方做了一次解耦，让 &lt;code&gt;objectName&lt;/code&gt; 需要单独设置。所以接下来，在这个你想让它有边框的 &lt;code&gt;QWidget&lt;/code&gt; 的构造函数中写下：&lt;code&gt;self.setObjectName(&amp;quot;OutsidePanel&amp;quot;)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;不推荐将组件的样式表颗粒化，在初始化过程中单独 &lt;code&gt;setStyleSheet()&lt;/code&gt; ，还是推荐将一整个 Panel 的样式整合成一个文件，在父框架进行设置，而避免在运行过程中还要动态加载。我认为 Qt 的设计者也是这样希望的，应当有相应的优化。&lt;/p&gt;
&lt;p&gt;关于 QSS ，网上其实能查到很多内容，比方有人说可以直接跟据对象名和 CSS 一样用 &lt;code&gt;#&lt;/code&gt; 设置对象的样式，实测并不行，推测可能是 PyQt 版本不同，能力也有所不同，很多网上提供的 QSS 属性也并不能生效。虽然 QSS 想让做 GUI 的人尽量用熟悉的方法——CSS来设计，但功能属实有限，不能达到 CSS 的效果不说，还给了有 CSS 使用经验的人过多不切实际的幻想，只能说是将 PyQt 本就有限的样式设置从 GUI 设计中部分解耦出来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【未完，对 PyQt ，想吐槽的点实在是如涛涛江水一般】&lt;/p&gt;
- https://winterorch.github.io/posts/python-pyqt-starter/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Spring 依赖注入注解的区分</title>
        <link>https://winterorch.github.io/posts/java-spring-annotation-di_methods/</link>
        <pubDate>Thu, 24 Jun 2021 19:03:58 +0530</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-spring-annotation-di_methods/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-spring-annotation-di_methods/ -&lt;p&gt;Spring 支持的依赖注入有 &lt;code&gt;@Autowired&lt;/code&gt; &lt;code&gt;@Resource&lt;/code&gt; &lt;code&gt;@Inject&lt;/code&gt; 三种&lt;/p&gt;
&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;
&lt;p&gt;来自 &lt;code&gt;org.springframwork.beans.factory.annotation.Autowired&lt;/code&gt; ，装配顺序为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按 &lt;code&gt;type&lt;/code&gt; 在上下文中查找匹配的 bean&lt;/li&gt;
&lt;li&gt;如果有多个 bean，则按照 &lt;code&gt;name&lt;/code&gt; 进行匹配
&lt;ul&gt;
&lt;li&gt;如有 &lt;code&gt;@Qualifier&lt;/code&gt; ，则按指定的 name 进行匹配&lt;/li&gt;
&lt;li&gt;如没有，则按变量名进行匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;匹配不到就报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;@Autowired(required=false)&lt;/code&gt; 则注入失败不抛异常&lt;/p&gt;
&lt;h3 id=&#34;inject&#34;&gt;@Inject&lt;/h3&gt;
&lt;p&gt;Spring 环境下和 &lt;code&gt;@Autowired&lt;/code&gt; 相同，都依赖 &lt;code&gt;AutowiredAnnotationBeanPostProcess&lt;/code&gt; 进行处理，但不能 &lt;code&gt;(required=false)&lt;/code&gt;。&lt;code&gt;@Inject&lt;/code&gt; 由 JSR-330 定义，可以切换到谷歌的 DI 框架——Guice。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Inject&lt;/code&gt; 在 Java EE 包内，SE 环境需要单独引入。&lt;/p&gt;
&lt;h3 id=&#34;resource&#34;&gt;@Resource&lt;/h3&gt;
&lt;p&gt;JSR-250 定义。在 &lt;code&gt;CommonAnnotationBeanPostProcessor&lt;/code&gt; 实现处理。同样有 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt;。装配顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如同时指定 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; ，从上下文找到唯一匹配 bean 进行装配，找不到抛异常&lt;/li&gt;
&lt;li&gt;如指定 &lt;code&gt;name&lt;/code&gt; ，则到上下文找 &lt;code&gt;id&lt;/code&gt; 匹配的 bean 进行装配，找不到抛异常&lt;/li&gt;
&lt;li&gt;如指定 &lt;code&gt;type&lt;/code&gt; ，则到上下文找类型匹配的唯一 bean 进行装配，找不到或找到不唯一都会抛异常&lt;/li&gt;
&lt;li&gt;如果都没有指定，则默认按 &lt;code&gt;byName&lt;/code&gt; 方式装配，找不到再按 &lt;code&gt;byType&lt;/code&gt; 进行装配&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;IDEA 使用 &lt;code&gt;@Autowired&lt;/code&gt; 时很常见警告 Field injection is not recommended。&lt;/p&gt;
&lt;p&gt;Spring 团队建议永远使用构造方法，也就是 &lt;code&gt;c-args&lt;/code&gt; 进行依赖注入。IDEA 对这一警告的默认修改方式也是——创建一个构造器进行依赖注入。并且，跟据 Spring 团队建议，对必须的依赖，应当使用断言进行确认&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Assert.&lt;span style=&#34;color:#658b00&#34;&gt;notNull&lt;/span&gt;(svc, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;svc must not be null&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为什么不能用成员依赖注入呢？&lt;/p&gt;
&lt;p&gt;field 注入虽然简洁，但存在问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于添加依赖过于简单（加个注释），我们很容易无意识地向一个类注入大量依赖，这违反了单一职责原理，因为我们过去通过构造器进行注入，而要是你的构造器出现大量入参，那很容易意识到自己的代码结构不对劲。打个比方——原本要数着钞票买东西的，一下子变成移动支付，点一下付钱了，就容易到了月底为账单发愁，因为我们金钱意识变薄弱了。解决方法就是——继续用构造器注入，因此对于强制依赖，Spring推荐用 &lt;code&gt;c-args&lt;/code&gt; 注入。&lt;/li&gt;
&lt;li&gt;依赖注入与容器本身耦合了，即——类唯一的正常工作方式就是通过容器反射进行实例化，这就像是集成测试一样，不像个健康的类，就像一个人原本你把饭给他就能自己吃，现在非要注射进去一样。为了让类能在容器外使用，自然还是要用 &lt;code&gt;c-args&lt;/code&gt; 和 &lt;code&gt;s-args&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;属性注入不能用来注入 &lt;code&gt;final&lt;/code&gt; 变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;因此 Spring 给出建议：&lt;code&gt;constructor-based&lt;/code&gt; 和 &lt;code&gt;setter-based&lt;/code&gt; DI 可以混用，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;强制依赖就用 &lt;code&gt;constructor-based&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很好理解，类离开强制依赖就无法工作，这和构造方法职能相吻合，也能注入 &lt;code&gt;final&lt;/code&gt; 变量。构造器可以保证这些变量的值不会是 null 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选、可变依赖用 &lt;code&gt;setter-based&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setter&lt;/code&gt; 值应被用于注入非必须依赖，这些依赖可以很方便地被改变或重新注入，否则会需要大量的 null 检查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/java-spring-annotation-di_methods/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>LeetCode 752 - 打开转盘锁</title>
        <link>https://winterorch.github.io/posts/leetcode-752-open_the_lock/</link>
        <pubDate>Thu, 24 Jun 2021 15:11:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-752-open_the_lock/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-752-open_the_lock/ -&lt;h1 id=&#34;leetcode-752-open-the-lock&#34;&gt;[LeetCode] 752. Open the Lock&lt;/h1&gt;
&lt;p&gt;You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &lt;code&gt;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;&lt;/code&gt;. The wheels can rotate freely and wrap around: for example we can turn &lt;code&gt;&#39;9&#39;&lt;/code&gt; to be &lt;code&gt;&#39;0&#39;&lt;/code&gt;, or &lt;code&gt;&#39;0&#39;&lt;/code&gt; to be &lt;code&gt;&#39;9&#39;&lt;/code&gt;. Each move consists of turning one wheel one slot.&lt;/p&gt;
&lt;p&gt;The lock initially starts at &lt;code&gt;&#39;0000&#39;&lt;/code&gt;, a string representing the state of the 4 wheels.&lt;/p&gt;
&lt;p&gt;You are given a list of &lt;code&gt;deadends&lt;/code&gt; dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.&lt;/p&gt;
&lt;p&gt;Given a &lt;code&gt;target&lt;/code&gt; representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;0201&amp;quot;,&amp;quot;0101&amp;quot;,&amp;quot;0102&amp;quot;,&amp;quot;1212&amp;quot;,&amp;quot;2002&amp;quot;], target = &amp;quot;0202&amp;quot;
Output: 6
Explanation:
A sequence of valid moves would be &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;1000&amp;quot; -&amp;gt; &amp;quot;1100&amp;quot; -&amp;gt; &amp;quot;1200&amp;quot; -&amp;gt; &amp;quot;1201&amp;quot; -&amp;gt; &amp;quot;1202&amp;quot; -&amp;gt; &amp;quot;0202&amp;quot;.
Note that a sequence like &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;0001&amp;quot; -&amp;gt; &amp;quot;0002&amp;quot; -&amp;gt; &amp;quot;0102&amp;quot; -&amp;gt; &amp;quot;0202&amp;quot; would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end &amp;quot;0102&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;8888&amp;quot;], target = &amp;quot;0009&amp;quot;
Output: 1
Explanation:
We can turn the last wheel in reverse to move from &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;0009&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;8887&amp;quot;,&amp;quot;8889&amp;quot;,&amp;quot;8878&amp;quot;,&amp;quot;8898&amp;quot;,&amp;quot;8788&amp;quot;,&amp;quot;8988&amp;quot;,&amp;quot;7888&amp;quot;,&amp;quot;9888&amp;quot;], target = &amp;quot;8888&amp;quot;
Output: -1
Explanation:
We can&#39;t reach the target without getting stuck.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 4:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;0000&amp;quot;], target = &amp;quot;8888&amp;quot;
Output: -1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= deadends.length &amp;lt;= 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deadends[i].length == 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target.length == 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;target will not be in the list &lt;code&gt;deadends&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt; and &lt;code&gt;deadends[i]&lt;/code&gt; consist of digits only.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解--双向-bfs&#34;&gt;题解  双向 BFS&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;类似题：&lt;a href=&#34;https://github.com/grandyang/leetcode/issues/126&#34;&gt;LeetCode 127 Word Ladder II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到有 &lt;code&gt;deadends&lt;/code&gt; 其实就比较明显了——这是个走迷宫问题，而且因为有四位密码，所以其实是个四维迷宫。维数并不会增加解法的复杂程度，倒是会严重增加敲代码的繁琐程度。一开始是打算真的和迷宫一样，用四维数组做的，后来发现参数实在太多了，光敲一个位置就要 &lt;code&gt;mem[i0][i1][i2][i3]&lt;/code&gt; 这样来一遍，实在有点头皮发麻，改用 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 来做记忆化了。&lt;/p&gt;
&lt;p&gt;还是当作迷宫来解，因此思想是 BFS ，因为入口和出口都是唯一确定的，前后都可以作为 BFS 的起点，因此可以通过双向 BFS 来收缩搜索范围。&lt;/p&gt;
&lt;p&gt;首先把 &lt;code&gt;deadends&lt;/code&gt; 存到一个 &lt;code&gt;HashSet&lt;/code&gt; 里，方便查验。BFS 需要前后两个队列，分别维护一个记忆化搜索表，记录到 &lt;code&gt;key&lt;/code&gt; 位置的步长。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt; Deque&amp;lt;String&amp;gt; d1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(),
						  d2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
Map&amp;lt;String, Integer&amp;gt; m1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(), 
									 m2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
d1.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(s);
m1.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(s, 0);
d2.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(t);
m2.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(t, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后就是 BFS 了，一直搜到队列空为止。为了尽量收缩双向 BFS 的搜索范围，每次&lt;!-- raw HTML omitted --&gt;从更小的队列取元素进行搜索&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!d1.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !d2.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; t = -1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (d1.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;lt;= d2.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
        t = update(d1, m1, m2);
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        t = update(d2, m2, m1);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (t != -1) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; t;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次搜索要搜相邻的八个位置，也就是每一位的前后两个数字。原数字是 &lt;code&gt;char[i]&lt;/code&gt; 的话，以十为模加一或加九就行了——&lt;code&gt;(char) (&#39;0&#39; + ((chars[i] - &#39;0&#39; + offset) % 10))&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;新状态的检查包括这样一些原则——&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新位置不能是 &lt;code&gt;deadend&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新位置不能已经去过（在同一队列中），同一队列两次经过同一位置步长一定不会变短，也就不需要考虑了&lt;/li&gt;
&lt;li&gt;在满足前两个前提下，如果能在反向记忆中找到相同状态，那一定是最短路径，直接输出&lt;/li&gt;
&lt;li&gt;不在反向记忆中，就加入到当前记忆队列中，从而引起下一轮 BFS&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ori = chars[i];
chars[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;) (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + ((chars[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + offset) % 10));
String go = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(chars);
chars[i] = ori;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(go))
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go))
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go)) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt; = step + 1 + ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(go);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
}
fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(go, step + 1);
fs.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(go);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完整代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; res;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] offset = {1, 9};
Set&amp;lt;String&amp;gt; deadEnds;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;openLock_remastered&lt;/span&gt;(String[] dead, String target) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (target.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;))
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#228b22&#34;&gt;// 虽然这里 IDE 会推荐让 Arrays 来把 String[] 转换成 Collection,但这样做对速度没有好处。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;// IDE 上测出来差别不大，但到了 LeetCode 上居然能让整题多耗将近一倍时间，百思不得其解。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (String str: dead)
        deadEnds.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(str);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (deadEnds.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;))
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    Deque&amp;lt;String&amp;gt; front = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    Map&amp;lt;String, Integer&amp;gt; front_map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    Deque&amp;lt;String&amp;gt; back = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    Map&amp;lt;String, Integer&amp;gt; back_map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    front.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;);
    front_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;, 0);
    back.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(target);
    back_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(target, 0);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!front.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !back.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (front.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;lt; back.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (update(front, front_map, back_map))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt;;
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (update(back, back_map, front_map))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;update&lt;/span&gt;(Deque&amp;lt;String&amp;gt; fs, Map&amp;lt;String, Integer&amp;gt; fs_map, Map&amp;lt;String, Integer&amp;gt; ot_map) {
    String cur = fs.&lt;span style=&#34;color:#658b00&#34;&gt;pollFirst&lt;/span&gt;();
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] chars = cur.&lt;span style=&#34;color:#658b00&#34;&gt;toCharArray&lt;/span&gt;();
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; step = fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(cur);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; offset : &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;offset&lt;/span&gt;) {
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ori = chars[i];
            &lt;span style=&#34;color:#228b22&#34;&gt;// 在原 char[] 上改了，取完 String 再转回去，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// 会比 clone() 新的要快很多
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;					 chars[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;) (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + ((chars[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + offset) % 10));
					 String go = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(chars);
					 chars[i] = ori;	
          
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(go))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go)) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt; = step + 1 + ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(go);
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            }
            fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(go, step + 1);
            fs.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(go);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;题解--astar-算法&#34;&gt;题解  AStar 算法&lt;/h3&gt;
&lt;p&gt;作者：AC_OIer
链接：https://leetcode-cn.com/problems/open-the-lock/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-wyr9/&lt;/p&gt;
&lt;p&gt;可以直接根据本题规则来设计 A* 的「启发式函数」。&lt;/p&gt;
&lt;p&gt;比如对于两个状态 a 和 b 可直接计算出「理论最小转换次数」：不同字符的转换成本之和 。&lt;/p&gt;
&lt;p&gt;需要注意的是：由于我们衡量某个字符 str 的估值是以目标字符串 target 为基准，因此我们只能确保 target 出队时为「距离最短」，而不能确保中间节点出队时「距离最短」，因此我们不能单纯根据某个节点是否「曾经入队」而决定是否入队，还要结合当前节点的「最小距离」是否被更新而决定是否入队。&lt;/p&gt;
&lt;p&gt;这一点十分关键，在代码层面上体现在 map.get(str).step &amp;gt; poll.step + 1 的判断上。&lt;/p&gt;
&lt;p&gt;注意：本题用 A* 过了，但通常我们需要先「确保有解」，A* 的启发搜索才会发挥真正价值。而本题，除非 t 本身在 deadends 中，其余情况我们无法很好提前判断「是否有解」。对于无解的情况 A* 效果不如「双向 BFS」。&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Solution&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Node&lt;/span&gt; {
        String str;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; val, step;
       &lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  str : 对应字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  val : 估值（与目标字符串 target 的最小转换成本）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  step: 对应字符串是经过多少步转换而来
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        */&lt;/span&gt;
        Node(String _str, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; _val, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; _step) {
            str = _str;
            val = _val;
            step = _step;
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;f&lt;/span&gt;(String str) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ans = 0;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++) {
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; cur = str.&lt;span style=&#34;color:#658b00&#34;&gt;charAt&lt;/span&gt;(i) - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, target = t.&lt;span style=&#34;color:#658b00&#34;&gt;charAt&lt;/span&gt;(i) - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; a = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(cur, target), b = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(cur, target);
            &lt;span style=&#34;color:#228b22&#34;&gt;// 在「正向转」和「反向转」之间取 min
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; min = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(b - a, a + 10 - b);
            ans += min;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;
    }
    String s, t;
    Set&amp;lt;String&amp;gt; set = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;openLock&lt;/span&gt;(String[] ds, String _t) {
        s = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;;
        t = _t;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (s.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(t)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (String d : ds) set.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(d);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (set.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(s)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
        
        PriorityQueue&amp;lt;Node&amp;gt; q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;((a,b)-&amp;gt;a.&lt;span style=&#34;color:#658b00&#34;&gt;val&lt;/span&gt;-b.&lt;span style=&#34;color:#658b00&#34;&gt;val&lt;/span&gt;);
        Map&amp;lt;String, Node&amp;gt; map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
        Node root = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Node(s, f(s), 0);
        q.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(root);
        map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(s, root);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
            Node poll = q.&lt;span style=&#34;color:#658b00&#34;&gt;poll&lt;/span&gt;();
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] pcs = poll.&lt;span style=&#34;color:#658b00&#34;&gt;str&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;toCharArray&lt;/span&gt;();
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; step = poll.&lt;span style=&#34;color:#658b00&#34;&gt;step&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (poll.&lt;span style=&#34;color:#658b00&#34;&gt;str&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(t)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; step;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = -1; j &amp;lt;= 1; j++) {
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (j == 0) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; cur = pcs[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; next = (cur + j) % 10;
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (next == -1) next = 9;

                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] clone = pcs.&lt;span style=&#34;color:#658b00&#34;&gt;clone&lt;/span&gt;();
                    clone[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;)(next + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;);
                    String str = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(clone);

                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (set.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(str)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
                    &lt;span style=&#34;color:#228b22&#34;&gt;// 如果 str 还没搜索过，或者 str 的「最短距离」被更新，则入队
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(str) || map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(str).&lt;span style=&#34;color:#658b00&#34;&gt;step&lt;/span&gt; &amp;gt; step + 1) {
                        Node node = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Node(str, step + 1 + f(str), step + 1);
                        map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(str, node);
                        q.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(node);
                    }
                }
            }
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-752-open_the_lock/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
        <link>https://winterorch.github.io/posts/leetcode-jianzhi-056/</link>
        <pubDate>Sun, 20 Jun 2021 21:03:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-jianzhi-056/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-jianzhi-056/ -&lt;h1 id=&#34;剑指-offer-56---i-数组中数字出现的次数httpsleetcode-cncomproblemsshu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/&#34;&gt;剑指 Offer 56 - I. 数组中数字出现的次数&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2 &amp;lt;= nums.length &amp;lt;= 10000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解&#34;&gt;题解&lt;/h3&gt;
&lt;p&gt;时空复杂度已经很明显提示了，要用位运算，异或消除掉出现过两次的数字&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num : nums)
    n ^= num;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果只有一个出现一次的数字，那答案已经出来了。然而这题有两个数字 &lt;code&gt;x, y&lt;/code&gt;，得到的 &lt;code&gt;n&lt;/code&gt; 是两者的异或 &lt;code&gt;n = x ^ y&lt;/code&gt; 。因为 &lt;code&gt;x != y&lt;/code&gt; ，&lt;code&gt;n&lt;/code&gt; 必定有至少一个非零位，接下来肯定得围绕着这个非零位作文章。&lt;/p&gt;
&lt;p&gt;而这个非零位有什么用呢？它告诉我们，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 中有一个 (&lt;code&gt;x&lt;/code&gt;) 在该比特位上非零，另一个 (&lt;code&gt;y&lt;/code&gt;) 为零。前面知道，通过异或只能得出唯一一个出现一次的数字，而现在有两个数字，那思路应当是——把这两个数字区分开来，分成具有不同特点的两组，这样就能分别求出这两个数字了。而现在，这个用来区分的特点有了——在 &lt;code&gt;n&lt;/code&gt; 最低非零位上是否为零。&lt;/p&gt;
&lt;p&gt;因此，接下来要做的就是——再遍历一遍原数组，在 &lt;code&gt;n&lt;/code&gt; 最低非零位上跟据是否为零放到两个 &lt;code&gt;int&lt;/code&gt; 上去异或。&lt;/p&gt;
&lt;p&gt;完整答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;singleNumbers&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x = 0, y = 0, n = 0, m = 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num : nums)               &lt;span style=&#34;color:#228b22&#34;&gt;// 1. 遍历异或
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        n ^= num;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;((n &amp;amp; m) == 0)               &lt;span style=&#34;color:#228b22&#34;&gt;// 2. 循环左移，计算 m
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        m &amp;lt;&amp;lt;= 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num: nums) {              &lt;span style=&#34;color:#228b22&#34;&gt;// 3. 遍历 nums 分组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;((num &amp;amp; m) != 0)
            x ^= num;                 &lt;span style=&#34;color:#228b22&#34;&gt;// 4. 当 num &amp;amp; m != 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
            y ^= num;                 &lt;span style=&#34;color:#228b22&#34;&gt;// 4. 当 num &amp;amp; m == 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] {x, y};          &lt;span style=&#34;color:#228b22&#34;&gt;// 5. 返回出现一次的数字
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-jianzhi-056/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Spring下常用注释.</title>
        <link>https://winterorch.github.io/posts/java-spring-annotation-collection/</link>
        <pubDate>Wed, 16 Jun 2021 14:25:05 -0400</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-spring-annotation-collection/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-spring-annotation-collection/ -&lt;p&gt;首先，在 Spring 4.X 之后（不用 Spring Boot 的话）使用注释需要添加 aop 依赖。虽然不需要这么做了，还是有助于了解 Spring Boot 到底为我们做了什么。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-aop&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;{springframework.version}&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而且需要在 XML 中添加约束并在 &lt;code&gt;context&lt;/code&gt; 中配置扫描范围。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#1e889b&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;beans&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;xmlns=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.springframework.org/schema/beans&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#658b00&#34;&gt;xmlns:xsi=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#658b00&#34;&gt;xmlns:context=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.springframework.org/schema/context&amp;#34;&lt;/span&gt;
      &lt;span style=&#34;color:#658b00&#34;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;http://www.springframework.org/schema/beans
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;       http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;       http://www.springframework.org/schema/context
&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;       http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;gt;&lt;/span&gt;

	&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;context:annotation-config/&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;配置扫描范围&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&amp;lt;!--指定注解扫描包--&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;context:component-scan&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;base-package=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;com.yourpackage&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来按类别整理一些最常用的注释。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;bean-的扫描&#34;&gt;&lt;strong&gt;Bean 的扫描&lt;/strong&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@ComponentScan&lt;/code&gt;：通过注释方式配置扫描范围，将其下的 &lt;code&gt;@Component&lt;/code&gt; 组件（包括&lt;code&gt;@Controller&lt;/code&gt;、&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Repository&lt;/code&gt;）纳入 IOC 容器. 只能作用于配置类，且 Spring Boot 的入口类不能被纳入到扫描范围中.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Spring Boot 默认的扫描范围是启动类所在包开始，当前包及子包下的所有文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@ComponentScan&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cc.mrbird.demo&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebConfig&lt;/span&gt; {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;可以通过 &lt;code&gt;excludeFilters&lt;/code&gt; 来排除一些组件的扫描，通过 &lt;code&gt;@Filter&lt;/code&gt; 注释完成&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@ComponentScan&lt;/span&gt;(value = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cc.mrbird.demo&amp;#34;&lt;/span&gt;,
        excludeFilters = {
          			&lt;span style=&#34;color:#228b22&#34;&gt;// 将注解为 Controller 和 Repository 的类排除
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#707a7c&#34;&gt;@Filter&lt;/span&gt;(type = FilterType.&lt;span style=&#34;color:#658b00&#34;&gt;ANNOTATION&lt;/span&gt;,
                        classes = {Controller.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;, Repository.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;}),
          			&lt;span style=&#34;color:#228b22&#34;&gt;// 排除所有 User 类（及子类、实现类）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#707a7c&#34;&gt;@Filter&lt;/span&gt;(type = FilterType.&lt;span style=&#34;color:#658b00&#34;&gt;ASSIGNABLE_TYPE&lt;/span&gt;, classes = User.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
        })
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebConfig&lt;/span&gt; {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上所示，可以跟据&lt;strong&gt;注释&lt;/strong&gt;或直接指定排除相应&lt;strong&gt;类型&lt;/strong&gt;（包括其子类、实现类）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;includeFilters&lt;/code&gt;的作用和&lt;code&gt;excludeFilters&lt;/code&gt;相反，其指定的是哪些组件需要被扫描：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@ComponentScan&lt;/span&gt;(value = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cc.mrbird.demo&amp;#34;&lt;/span&gt;,
        includeFilters = {
          			&lt;span style=&#34;color:#228b22&#34;&gt;// 仅纳入注释为 Service 的类
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#707a7c&#34;&gt;@Filter&lt;/span&gt;(type = FilterType.&lt;span style=&#34;color:#658b00&#34;&gt;ANNOTATION&lt;/span&gt;, classes = Service.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
        }, useDefaultFilters = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebConfig&lt;/span&gt; {

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过实现 &lt;code&gt;org.springframework.core.type.filter.TypeFilter&lt;/code&gt;接口可以自定义扫描策略，通过实现 &lt;code&gt;match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)&lt;/code&gt; 方法，返回 &lt;code&gt;true&lt;/code&gt; 说明匹配成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;bean-的注册&#34;&gt;&lt;strong&gt;Bean 的注册&lt;/strong&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Bean&lt;/code&gt;, &lt;code&gt;@Component&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Bean&lt;/code&gt;：通过注解向 IOC 容器注册默认为方法名的 Bean，也可以通过 &lt;code&gt;@Bean(&amp;quot;{name}&amp;quot;)&lt;/code&gt; 来重新命名&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Configuration&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebConfig&lt;/span&gt; {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Bean&lt;/span&gt;()
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; User &lt;span style=&#34;color:#008b45&#34;&gt;user&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; User(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;mrbirdy&amp;#34;&lt;/span&gt;, 18);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;实现了 &lt;code&gt;FactoryBean&amp;lt;T&amp;gt;&lt;/code&gt; 接口的 Bean 是一类特殊的 Bean&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;CherryFactoryBean&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; FactoryBean&amp;lt;Cherry&amp;gt; {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Cherry &lt;span style=&#34;color:#008b45&#34;&gt;getObject&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Cherry();
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; getObjectType() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; Cherry.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;;
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;isSingleton&lt;/span&gt;() {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果 &lt;code&gt;isSingleton()&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则每次会调用 &lt;code&gt;getObject()&lt;/code&gt; 从中获取 Bean。&lt;/p&gt;
&lt;p&gt;通过加上前缀 &lt;code&gt;&amp;amp;&lt;/code&gt; 从工厂中取出对应的 Bean&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Object cherryFactoryBean = context.&lt;span style=&#34;color:#658b00&#34;&gt;getBean&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;&amp;amp;cherryFactoryBean&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Component&lt;/code&gt;：&lt;code&gt;component-scan&lt;/code&gt; 指定的扫描路径下所有被&lt;code&gt;@Controller&lt;/code&gt;、&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@Repository&lt;/code&gt;和&lt;code&gt;@Component&lt;/code&gt;注解标注的类都会被纳入IOC容器中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Component&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#228b22&#34;&gt;// 相当于配置文件中 &amp;lt;bean id=&amp;#34;user&amp;#34; class=&amp;#34;当前注解的类&amp;#34;/&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;User&lt;/span&gt; {
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; String name = ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;说明该类被Spring管理。&lt;code&gt;Component&lt;/code&gt; 类的有参构造方法会被默认用作依赖注入，所以相比在成员变量上加 &lt;code&gt;@Autowire&lt;/code&gt; 来注入依赖，更合适的方法是通过构造方法注入。&lt;/p&gt;
&lt;p&gt;衍生注解：按照MVC三层架构分层&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Repository&lt;/code&gt;：用于DAO层，数据库操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Service&lt;/code&gt;：用于Service层，复杂逻辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Controller&lt;/code&gt;：用于Controller层，接收用户请求并调用Service层返回数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;连同&lt;code&gt;@Component&lt;/code&gt;，四个注解功能一样，都代表将某个类注册到Spring中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;bean-的加载&#34;&gt;Bean 的加载&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Scope&lt;/code&gt;, &lt;code&gt;@Lazy&lt;/code&gt;, &lt;code&gt;@Conditional&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Scope&lt;/code&gt;：改变组件的作用域（默认 &lt;code&gt;singleton&lt;/code&gt;）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;singleton&lt;/code&gt;：单实例（默认）,在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取（&lt;code&gt;map.get()&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;：多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt;：一个请求对应一个实例；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session&lt;/code&gt;：同一个session对应一个实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Lazy&lt;/code&gt;：懒加载（针对 &lt;code&gt;singleton&lt;/code&gt; ）&lt;/p&gt;
&lt;p&gt;懒加载的单例不会马上调用方法创建对象并注册，只有当第一次被使用时才会调用方法创建对象并加入容器中。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Conditional&lt;/code&gt;：条件加载，类似于前面 &lt;code&gt;@ComponentScan&lt;/code&gt; 中的 &lt;code&gt;Filter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;@Conditional&lt;/code&gt;注解我们可以指定组件注册的条件，即满足特定条件才将组件纳入到 IOC 容器中。&lt;/p&gt;
&lt;p&gt;在使用该注解之前，我们需要创建一个类，实现&lt;code&gt;Condition&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MyCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该接口包含一个&lt;code&gt;matches&lt;/code&gt;方法，包含两个入参:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ConditionContext&lt;/code&gt;：上下文信息；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AnnotatedTypeMetadata&lt;/code&gt;：注解信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;简单完善一下这个实现类:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;MyCondition&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; Condition {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;matches&lt;/span&gt;(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String osName = context.&lt;span style=&#34;color:#658b00&#34;&gt;getEnvironment&lt;/span&gt;().&lt;span style=&#34;color:#658b00&#34;&gt;getProperty&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;os.name&amp;#34;&lt;/span&gt;);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; osName != &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; osName.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;Windows&amp;#34;&lt;/span&gt;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接着将这个条件添加到User Bean注册的地方：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Bean&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Conditional&lt;/span&gt;(MyCondition.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; User &lt;span style=&#34;color:#008b45&#34;&gt;user&lt;/span&gt;() {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; User(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;mrbird&amp;#34;&lt;/span&gt;, 18);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在Windows环境下，User这个组件将被成功注册，如果是别的操作系统，这个组件将不会被注册到IOC容器中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;属性注入&#34;&gt;属性注入&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Value&lt;/code&gt;, &lt;code&gt;@ConfigurationProperties&lt;/code&gt;, &lt;code&gt;@PropertySource&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Value&lt;/code&gt;:	Property注入&lt;/p&gt;
&lt;p&gt;可以直接用在成员变量上，也可以用在Setter上&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是 &lt;code&gt;@value&lt;/code&gt;这种方式是不被推荐的，Spring 比较建议的是下面几种读取配置信息的方式。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt;: Properties 读取并与 bean 绑定&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;LibraryProperties&lt;/code&gt; 类上加了 &lt;code&gt;@Component&lt;/code&gt; 注解，我们可以像使用普通 bean 一样将其注入到类中使用。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.boot.context.properties.ConfigurationProperties&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.context.annotation.Configuration&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.stereotype.Component&lt;/span&gt;;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;java.util.List&lt;/span&gt;;

&lt;span style=&#34;color:#707a7c&#34;&gt;@Component&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@ConfigurationProperties&lt;/span&gt;(prefix = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;library&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;LibraryProperties&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String location;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; List&amp;lt;Book&amp;gt; books;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Book&lt;/span&gt; {
        String name;
        String description;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相应的配置文件内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;library:
  location: 湖北武汉加油中国加油
  books:
    - name: 天才基本法
      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。
    - name: 时间的秩序
      description: 为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。
    - name: 了不起的我
      description: 如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？ 如何走出人生的艰难时刻？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后就可以通过 &lt;code&gt;private final LibraryProperties library&lt;/code&gt; 注入 Property 对象了。&lt;/p&gt;
&lt;p&gt;题外话：&lt;code&gt;InitializingBean&lt;/code&gt; 接口下的 &lt;code&gt;afterPropertiesSet()&lt;/code&gt; 方法可以作为一个 Property 注入后的 AOP 使用，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ReadConfigPropertiesApplication&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; InitializingBean {

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; LibraryProperties library;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;ReadConfigPropertiesApplication&lt;/span&gt;(LibraryProperties library) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;library&lt;/span&gt; = library;
    }

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
        SpringApplication.&lt;span style=&#34;color:#658b00&#34;&gt;run&lt;/span&gt;(ReadConfigPropertiesApplication.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;, args);
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;afterPropertiesSet&lt;/span&gt;() {
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(library.&lt;span style=&#34;color:#658b00&#34;&gt;getLocation&lt;/span&gt;());
        System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(library.&lt;span style=&#34;color:#658b00&#34;&gt;getBooks&lt;/span&gt;());    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;如果 Property类上不加 &lt;code&gt;Component&lt;/code&gt; ，就需要在 SpringBootApplication 上加 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 来注册 Bean ，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@EnableConfigurationProperties&lt;/span&gt;(ProfileProperties.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;ReadConfigPropertiesApplication&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; InitializingBean {
 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; ProfileProperties profileProperties;

 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;ReadConfigPropertiesApplication&lt;/span&gt;(ProfileProperties profileProperties) {
     &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;profileProperties&lt;/span&gt; = profileProperties;
 }

 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) {
     SpringApplication.&lt;span style=&#34;color:#658b00&#34;&gt;run&lt;/span&gt;(ReadConfigPropertiesApplication.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;, args);
 }

 &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
 &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;afterPropertiesSet&lt;/span&gt;() {
     System.&lt;span style=&#34;color:#658b00&#34;&gt;out&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;println&lt;/span&gt;(profileProperties.&lt;span style=&#34;color:#658b00&#34;&gt;toString&lt;/span&gt;());
 }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@PropertySource&lt;/code&gt;: 有单独文件的 properties 可以通过 &lt;code&gt;@PropertySource&lt;/code&gt; 来读取&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.beans.factory.annotation.Value&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.context.annotation.PropertySource&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#008b45;text-decoration:underline&#34;&gt;org.springframework.stereotype.Component&lt;/span&gt;;

&lt;span style=&#34;color:#707a7c&#34;&gt;@Component&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@PropertySource&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;classpath:website.properties&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;WebSite&lt;/span&gt; {
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Value&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;${url}&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String url;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;校验注解&#34;&gt;校验注解&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;这里可以参考 &lt;a href=&#34;https://snailclimb.gitee.io/springboot-guide/#/./docs/spring-bean-validation&#34;&gt;Spring Boot 指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;JSR 提供的校验注解&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Null&lt;/code&gt; 被注释的元素必须为 null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotNull&lt;/code&gt; 被注释的元素必须不为 null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AssertTrue&lt;/code&gt; 被注释的元素必须为 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@AssertFalse&lt;/code&gt; 被注释的元素必须为 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Min(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须大于等于指定的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Max(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须小于等于指定的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DecimalMin(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须大于等于指定的最小值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@DecimalMax(value)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须小于等于指定的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Size(max=, min=)&lt;/code&gt; 被注释的元素的大小必须在指定的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Digits (integer, fraction)&lt;/code&gt; 被注释的元素必须是一个数字，其值必须在可接受的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Past&lt;/code&gt; 被注释的元素必须是一个过去的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Future&lt;/code&gt; 被注释的元素必须是一个将来的日期&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pattern(regex=,flag=)&lt;/code&gt; 被注释的元素必须符合指定的正则表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Person&lt;/span&gt; {

    &lt;span style=&#34;color:#707a7c&#34;&gt;@NotNull&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;classId 不能为空&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String classId;

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Size&lt;/span&gt;(max = 33)
    &lt;span style=&#34;color:#707a7c&#34;&gt;@NotNull&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;name 不能为空&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String name;

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Pattern&lt;/span&gt;(regexp = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;((^Man$|^Woman$|^UGM$))&amp;#34;&lt;/span&gt;, message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;sex 值不在可选范围&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#707a7c&#34;&gt;@NotNull&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;sex 不能为空&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String sex;

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Email&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;email 格式不正确&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#707a7c&#34;&gt;@NotNull&lt;/span&gt;(message = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;email 不能为空&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String email;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Hibernate Validator 提供的校验注解&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@NotBlank(message =)&lt;/code&gt; 验证字符串非 null，且长度必须大于 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Email&lt;/code&gt; 被注释的元素必须是电子邮箱地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Length(min=,max=)&lt;/code&gt; 被注释的字符串的大小必须在指定的范围内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@NotEmpty&lt;/code&gt; 被注释的字符串的必须非空&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Range(min=,max=,message=)&lt;/code&gt; 被注释的元素必须在合适的范围内&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;自动装配&#34;&gt;自动装配&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Autowired&lt;/code&gt;, &lt;code&gt;@Resource&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;@Autowired&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动装配，先&lt;code&gt;byType&lt;/code&gt;再&lt;code&gt;byName&lt;/code&gt;，如果不能唯一自动装配，则需要&lt;code&gt;@Qualifier(value=&amp;quot;xxx&amp;quot;)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在成员变量上实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;User&lt;/span&gt; {
   &lt;span style=&#34;color:#707a7c&#34;&gt;@Autowired&lt;/span&gt;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Cat cat;
   &lt;span style=&#34;color:#707a7c&#34;&gt;@Autowired&lt;/span&gt;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Dog dog;
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; String str;

   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Cat &lt;span style=&#34;color:#008b45&#34;&gt;getCat&lt;/span&gt;() {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; cat;
  }
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; Dog &lt;span style=&#34;color:#008b45&#34;&gt;getDog&lt;/span&gt;() {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; dog;
  }
   &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; String &lt;span style=&#34;color:#008b45&#34;&gt;getStr&lt;/span&gt;() {
       &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; str;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后在XML中配置Bean&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;context:annotation-config/&amp;gt;&lt;/span&gt;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dog&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;com.kuang.pojo.Dog&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cat&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;com.kuang.pojo.Cat&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;&amp;lt;bean&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;id=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;user&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#658b00&#34;&gt;class=&lt;/span&gt;&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;com.kuang.pojo.User&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Qualifer()&lt;/code&gt;：如果bean名字不为类的默认名字，则要加&lt;code&gt;@Qualifer&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Autowired&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Qualifier&lt;/span&gt;(value = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;cat2&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Cat cat;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Autowired&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@Qualifier&lt;/span&gt;(value = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;dog2&amp;#34;&lt;/span&gt;)
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; Dog dog;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;  
&amp;lt;/br&amp;gt;
  
- #### `@Resource`

  自动装配，先`byName`再`byType`，如果`name`属性指定，则只会按照名称进行装配.

  默认按照名称进行装配，名称可以通过name属性进行指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配

  ```java
  public class User {
     //如果允许对象为null，设置required = false,默认为true
     @Resource(name = &amp;quot;cat2&amp;quot;)
     private Cat cat;
     @Resource
     private Dog dog;
     private String str;
  }
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 Service 的实现类中使用，将方法标注为 SQL 事务.&lt;/p&gt;
&lt;p&gt;首先需要在入口类上加入 &lt;code&gt;@EnableTransactionManagement&lt;/code&gt; 注解以开启事务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@EnableTransactionManagement&lt;/span&gt;
&lt;span style=&#34;color:#707a7c&#34;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;TransactionApplication&lt;/span&gt; {

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;main&lt;/span&gt;(String[] args) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throws&lt;/span&gt; Exception {
        SpringApplication.&lt;span style=&#34;color:#658b00&#34;&gt;run&lt;/span&gt;(TransactionApplication.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;, args);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后再 &lt;code&gt;@Service&lt;/code&gt; 中标注事务：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Service&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;UserServiceImpl&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; UserService {

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; UserMapper userMapper;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;UserServiceImpl&lt;/span&gt;(UserMapper userMapper) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;userMapper&lt;/span&gt; = userMapper;
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Transactional&lt;/span&gt;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUser&lt;/span&gt;(User user) {
        userMapper.&lt;span style=&#34;color:#658b00&#34;&gt;save&lt;/span&gt;(user);
        &lt;span style=&#34;color:#228b22&#34;&gt;// 测试事务回滚
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!StringUtils.&lt;span style=&#34;color:#658b00&#34;&gt;hasText&lt;/span&gt;(user.&lt;span style=&#34;color:#658b00&#34;&gt;getUsername&lt;/span&gt;())) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; RuntimeException(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username不能为空&amp;#34;&lt;/span&gt;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果生效，当用户名为空（这里用的是 &lt;code&gt;org.springframework.util&lt;/code&gt; 包下的 &lt;code&gt;hasText()&lt;/code&gt; 方法，要求字符串不为 &lt;code&gt;null&lt;/code&gt; 、长度大于0、不全为空），则会捕获到异常而进行回滚。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;@Transactional&lt;/code&gt; 同样利用的是 Spring 的 AOP 机制, 这里有两个坑.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意点一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;如果抛出的异常&lt;strong&gt;不是 &lt;code&gt;RuntimeException&lt;/code&gt; 或者 &lt;code&gt;Error&lt;/code&gt; ，也不是 &lt;code&gt;@Transactional&lt;/code&gt; 注解指定的回滚异常类型&lt;/strong&gt;，&lt;strong&gt;则不会进行事务回滚&lt;/strong&gt;。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;所以在自定义需要回滚的异常时，要么继承 &lt;code&gt;RuntimeException&lt;/code&gt; ，要么直接在注释上标出来：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Transactional&lt;/span&gt;(rollbackFor = Exception.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;)
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUser&lt;/span&gt;(User user) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throws&lt;/span&gt; Exception {
        userMapper.&lt;span style=&#34;color:#658b00&#34;&gt;save&lt;/span&gt;(user);
        &lt;span style=&#34;color:#228b22&#34;&gt;// 测试事务回滚
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!StringUtils.&lt;span style=&#34;color:#658b00&#34;&gt;hasText&lt;/span&gt;(user.&lt;span style=&#34;color:#658b00&#34;&gt;getUsername&lt;/span&gt;())) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Exception(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username不能为空&amp;#34;&lt;/span&gt;);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;strong&gt;注意点二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们在相同 &lt;code&gt;Service&lt;/code&gt; 下的&lt;strong&gt;非事务方法中，对事务方法进行调用，事务同样不会生效&lt;/strong&gt;。如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Service&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;UserServiceImpl&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;implements&lt;/span&gt; UserService {

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;final&lt;/span&gt; UserMapper userMapper;

    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;UserServiceImpl&lt;/span&gt;(UserMapper userMapper) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;userMapper&lt;/span&gt; = userMapper;
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUserTest&lt;/span&gt;(User user) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;saveUser&lt;/span&gt;(user);
    }

    &lt;span style=&#34;color:#707a7c&#34;&gt;@Transactional&lt;/span&gt;
    &lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUser&lt;/span&gt;(User user) {
        userMapper.&lt;span style=&#34;color:#658b00&#34;&gt;save&lt;/span&gt;(user);
        &lt;span style=&#34;color:#228b22&#34;&gt;// 测试事务回滚
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!StringUtils.&lt;span style=&#34;color:#658b00&#34;&gt;hasText&lt;/span&gt;(user.&lt;span style=&#34;color:#658b00&#34;&gt;getUsername&lt;/span&gt;())) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ParamInvalidException(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;username不能为空&amp;#34;&lt;/span&gt;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为 Spring 事务控制通过 AOP 代理实现，通过代理目标对象来增强目标方法，而如果用 &lt;code&gt;this&lt;/code&gt; 调用方法，&lt;code&gt;this&lt;/code&gt; 绕过了代理类（实际上是代理类绕过原类，&lt;code&gt;this&lt;/code&gt; 无视了代理类），直接用了类本身，从而没有触发事务。&lt;/p&gt;
&lt;p&gt;要让代理类重新生效有两种方法&lt;/p&gt;
&lt;p&gt;1、 从 IOC 中获取 Bean 后再调用：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUserTest&lt;/span&gt;(User user) {
    UserService userService = context.&lt;span style=&#34;color:#658b00&#34;&gt;getBean&lt;/span&gt;(UserService.&lt;span style=&#34;color:#658b00&#34;&gt;class&lt;/span&gt;);
    userService.&lt;span style=&#34;color:#658b00&#34;&gt;saveUser&lt;/span&gt;(user);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;2、 直接从 AOP 上下文取代理对象进行调用（需要引入 AOP Starter 依赖），且需要再在 SpringBoot 入口类中通过注解&lt;code&gt;@EnableAspectJAutoProxy(exposeProxy = true)&lt;/code&gt;将当前代理对象暴露到 AOP 上下文中（通过 &lt;code&gt;AopContext&lt;/code&gt; 的 &lt;code&gt;ThreadLocal&lt;/code&gt; 实现）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#707a7c&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;saveUserTest&lt;/span&gt;(User user) {
    UserService userService = (UserService) AopContext.&lt;span style=&#34;color:#658b00&#34;&gt;currentProxy&lt;/span&gt;();
    userService.&lt;span style=&#34;color:#658b00&#34;&gt;saveUser&lt;/span&gt;(user);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;总之是有种为了舍近求远又额外兜了一大圈的感觉，个人认为写事务就不要代入编程优雅方面的考虑了，没必要在方法单一职责上那么较真。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/java-spring-annotation-collection/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>接口与抽象类的区别</title>
        <link>https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/</link>
        <pubDate>Wed, 02 Jun 2021 20:04:58 +0130</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/ -&lt;p&gt;先简单过一下接口语法中的注意点。&lt;/p&gt;
&lt;h3 id=&#34;注意点&#34;&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口中的变量隐式指定为 &lt;code&gt;public static final&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口中的方法会被隐式指定为 &lt;code&gt;public abstract&lt;/code&gt; （JDK 1.9 后允许 private，其它修饰符会报错）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这也决定了接口中所有方法都必须被实现，当然这一要求有两种特殊的满足方式——抽象类实现接口，那么接口方法不一定要实现，可以由抽象类的子类实现；JDK 1.8 后有默认实现的接口方法也不必被实现类显式实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口不能有构造方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 1.8 后，接口可以有静态方法和方法体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 1.8 后，接口方法可以有默认方法，用 &lt;code&gt;default&lt;/code&gt; 关键字修饰&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与抽象类语法上的区别&#34;&gt;与抽象类语法上的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个类可以实现多个接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个接口可以继承多个其它接口&lt;/p&gt;
&lt;p&gt;Java 接口是对行为的抽象，一个行为本身可以看作多个行为的耦合&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Hockey&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; Sports, Event
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口与抽象类区别&#34;&gt;接口与抽象类区别&lt;/h2&gt;
&lt;p&gt;接口和抽象类语法上的不同在之前两个文档中都已经接释清楚了，这里主要看两者思想上的不同。&lt;/p&gt;
&lt;p&gt;摘取一些《Effective Java》中的说法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接口是对行为的抽象，达到 &lt;strong&gt;API 定义与实现分类&lt;/strong&gt; 的目的，因此支持多实现。甚至可以用没有任何方法的接口，作为 Marker Interface，目的仅仅是进行声明。但是用接口导出常量是不合适的使用，接口应当尽量减少细节泄露，常量应当由类保管。&lt;/p&gt;
&lt;p&gt;相较之下，抽象类的主要目的是 &lt;strong&gt;代码重用&lt;/strong&gt;，本质是不能实例化的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重点有两个——抽象类和接口的本质、目的都不同。&lt;/p&gt;
&lt;h3 id=&#34;本质&#34;&gt;本质&lt;/h3&gt;
&lt;p&gt;抽象类本质是类，因此不能多继承。C++ 允许多继承而 Java 不允许，这体现两者多态思想上的差别。我们知道 Java 继承其实叫 &lt;code&gt;extends&lt;/code&gt; ，严格来讲不叫“继承”，因为在 Java 中，继承首先是一种 &lt;code&gt;is-a&lt;/code&gt; 关系，即 &lt;code&gt;Student&lt;/code&gt; 要继承 &lt;code&gt;Person&lt;/code&gt; ，首先要满足 “&lt;code&gt;Student&lt;/code&gt; &lt;code&gt;is a&lt;/code&gt; &lt;code&gt;Person&lt;/code&gt;” 。这很好理解，按照里氏替换原则 (Liskov Substitution)，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类进行替换。因此这显然不是中文里面继承的语义，因为中文里“儿子继承父亲”，但儿子不可能是父亲，两者有本质区别。&lt;/p&gt;
&lt;p&gt;然后，Java 为什么只允许单继承就很好理解了。如果我想让 A 同时继承 B 和 C，那说明 A is B, A is C，那 B 和 C 之间自然应当满足某种继承关系，三者应当是一个继承链的关系而非继承树的关系，通过单继承也可以表示清楚，并不需要让 A 同时继承 B 和 C。更不用说 C++ 为了实现多继承，其实也带来菱形继承问题，可能造成内存浪费和数据冗余。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C++中因为允许多继承，可能会因为&lt;strong&gt;菱形继承&lt;/strong&gt;造成内存浪费和数据冗余（如两个类BC分别继承同一基类A，再从这两个类派生出一个类D时会有冗余成员），因此最好使用虚继承。虚继承下，D实例内存地址中，BC虚继承来的A部分会通过一个指针分别指向一张虚基表（准确来讲是指向其中的虚基表偏移指针的存储地址，然后通过该指针取出偏移量），从虚基表中取出从基类A虚继承来成员在D内存中的偏移地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;曾看到有博客认为 C++ 多继承机制较为合理，给出的理由是“人可以有父母，那类也应当可以多继承”。结合前文内容，这个理由显然没有什么道理，但是我认为却很好地反映了 Java 中接口的思想。我们知道，对于生物而言，父和母显然是不等价的，母完成了作为母的职责，父完成了作为父的职责，然后才有“子”，因此与其类比为继承，不如类比为接口实现更妥当，因为父、母实际上在这里归根结底是&lt;strong&gt;行为的抽象&lt;/strong&gt;，父类必须实现接口 &lt;code&gt;CanBeFather&lt;/code&gt;，母类必须实现接口 &lt;code&gt;CanBeMother&lt;/code&gt;，这是一种行为关系。这一接口在使用过程中屏蔽了其它底层细节，无论父母是什么学历、有什么资产，这一过程中都不关注，也没有影响，这便是类功能上的解耦，通过一个用来将行为抽象化的接口完成了。&lt;/p&gt;
&lt;h3 id=&#34;目的&#34;&gt;目的&lt;/h3&gt;
&lt;p&gt;目的上面其实也说了，《Effective Java》总结的很到位，接口是对行为的抽象，达到 &lt;strong&gt;API 定义与实现分类&lt;/strong&gt; 的目的。如果一个类可以有多个行为、实现多个功能，那它当然可以实现多个接口。&lt;/p&gt;
&lt;p&gt;而抽象类更多还是用来减少冗余代码，换句话说——提高代码质量、提高可读性、降低维护难度……&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-继承与里氏替换原则&#34;&gt;Java 继承与里氏替换原则&lt;/h2&gt;
&lt;p&gt;Java中子类重写父类方法时&lt;!-- raw HTML omitted --&gt;不能抛出父类中没有抛出的异常&lt;!-- raw HTML omitted --&gt;，编译会不过，不抛是完全可以的。同时，该方法在子类中的访问级别也不能低于超类中的访问级别。&lt;!-- raw HTML omitted --&gt;这两项规则确保可使用超类实例的地方也能使用子类实例，符合&lt;strong&gt;里氏替换原则&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt;只能被隐藏（静态及非静态），不能被覆盖&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态方法&lt;/strong&gt;只能被隐藏，不能覆盖&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态方法&lt;/strong&gt;只能用静态方法隐藏，&lt;strong&gt;非静态方法&lt;/strong&gt;只能用非静态方法覆盖（否则编译不过）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终方法&lt;/strong&gt;不能覆盖。私有方法（private）实际会被隐式指定为 final ，所以同样不能覆盖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象方法&lt;/strong&gt;必须覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时要注意的是关于构造方法的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类实例化对象时，如果子类构造方法没有显式调用父类构造方法，默认调用 &lt;code&gt;super()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子类要使用父类有参构造方法，使用 &lt;code&gt;super(...)&lt;/code&gt; 形式，且 &lt;code&gt;super()&lt;/code&gt; 必须是子类构造方法中第一行语句&lt;/li&gt;
&lt;li&gt;父类没有不带参构造方法，子类构造方法中必须显示调用父类其它构造方法，否则编译不过&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>计算机网络 传输层</title>
        <link>https://winterorch.github.io/posts/computer_network-transport_layer/</link>
        <pubDate>Wed, 02 Jun 2021 09:14:28 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/computer_network-transport_layer/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/computer_network-transport_layer/ -&lt;p&gt;网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tcp-与-udp-协议区别&#34;&gt;TCP 与 UDP 协议区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;连接&lt;/th&gt;
&lt;th&gt;传输可靠性&lt;/th&gt;
&lt;th&gt;传输形式&lt;/th&gt;
&lt;th&gt;传输效率&lt;/th&gt;
&lt;th&gt;所需资源&lt;/th&gt;
&lt;th&gt;应用场景&lt;/th&gt;
&lt;th&gt;首部字节&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TCP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;可靠&lt;/td&gt;
&lt;td&gt;字节流&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;多&lt;/td&gt;
&lt;td&gt;要求数据可靠性&lt;/td&gt;
&lt;td&gt;20 - 60&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;UDP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;td&gt;不可靠&lt;/td&gt;
&lt;td&gt;数据报文段&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;少&lt;/td&gt;
&lt;td&gt;要求通信效率&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tcptransmission-control-protocol&#34;&gt;TCP（Transmission Control Protocol）&lt;/h2&gt;
&lt;p&gt;TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_01.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认号&lt;/strong&gt;   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据偏移&lt;/strong&gt;   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认 ACK&lt;/strong&gt;   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步 SYN&lt;/strong&gt;   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;终止 FIN&lt;/strong&gt;   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口&lt;/strong&gt;   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一tcp-三次握手和四次挥手&#34;&gt;一、TCP 三次握手和四次挥手&lt;/h3&gt;
&lt;p&gt;可靠，TCP 协议的设计都是为了可靠无误&lt;/p&gt;
&lt;h4 id=&#34;11-三次握手&#34;&gt;1.1 三次握手&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/984872f6f3fd869be7b447fa70ace6b992fa9b599d8352b810a2d4893acb901c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/984872f6f3fd869be7b447fa70ace6b992fa9b599d8352b810a2d4893acb901c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67&#34; alt=&#34;TCP三次握手&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端–发送带有 SYN 标志的数据包–一次握手–服务端&lt;/li&gt;
&lt;li&gt;服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端&lt;/li&gt;
&lt;li&gt;客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么这么设计，可以从三次握手后双方获得的信息入手，对于发送方而言：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;自己发送正常&lt;/th&gt;
&lt;th&gt;自己接收正常&lt;/th&gt;
&lt;th&gt;对方发送正常&lt;/th&gt;
&lt;th&gt;对方接收正常&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于接收方而言：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;自己发送正常&lt;/th&gt;
&lt;th&gt;自己接收正常&lt;/th&gt;
&lt;th&gt;对方发送正常&lt;/th&gt;
&lt;th&gt;对方接收正常&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;要接收双方都能完整确认双方接收功能正常，三次握手缺一不可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;第2次握手传回了ACK，为什么还要传回SYN？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;12-四次挥手&#34;&gt;1.2 四次挥手&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;断开一个 TCP 连接则需要“四次挥手”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器-关闭与客户端的连接，发送一个FIN给客户端&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TIME_WAIT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;传达信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A: FIN&lt;/td&gt;
&lt;td&gt;A：我没有数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B：ack&lt;/td&gt;
&lt;td&gt;B：我知道你没数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B：FIN&lt;/td&gt;
&lt;td&gt;B：我没有数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A：ack&lt;/td&gt;
&lt;td&gt;A：我知道你没数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;二tcp-如何保证可靠传输&#34;&gt;二、TCP 如何保证可靠传输&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;**分块：**应用数据被分割成 TCP 认为最适合发送的数据块。&lt;/li&gt;
&lt;li&gt;**有序：**TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验和：&lt;/strong&gt; TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。&lt;/li&gt;
&lt;li&gt;**去重：**TCP 的接收端会丢弃重复的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量控制：&lt;/strong&gt; TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞控制：&lt;/strong&gt; 当网络拥塞时，减少数据的发送。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARQ协议：&lt;/strong&gt; 通过确认和超时机制实现可靠信息传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超时重传：&lt;/strong&gt; 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;21-arq&#34;&gt;2.1 ARQ&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;自动重传请求&lt;/strong&gt;（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。&lt;/p&gt;
&lt;h5 id=&#34;停止等待arq协议&#34;&gt;&lt;strong&gt;停止等待ARQ协议&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;每发完一个分组就停止发送，等待对方确认（回复ACK）。如果超时还没有收到 ACK 确认，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 简单&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 信道利用率低，等待时间长&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;连续arq协议&#34;&gt;&lt;strong&gt;连续ARQ协议&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 信道利用率高，容易实现，即使确认丢失，也不必重传。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-滑动窗口和流量控制&#34;&gt;2.2 滑动窗口和流量控制&lt;/h4&gt;
&lt;p&gt;窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。&lt;/strong&gt; 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。&lt;/p&gt;
&lt;h4 id=&#34;23-拥塞控制&#34;&gt;2.3 拥塞控制&lt;/h4&gt;
&lt;p&gt;拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。&lt;/p&gt;
&lt;p&gt;为了进行拥塞控制，TCP 发送方要维持一个 &lt;strong&gt;拥塞窗口(cwnd)&lt;/strong&gt; 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 窗口基于&lt;strong&gt;字节&lt;/strong&gt;，但这里拥塞窗口的大小单位是&lt;strong&gt;报文段&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP的拥塞控制采用了四种算法，即 &lt;strong&gt;慢开始&lt;/strong&gt; 、 &lt;strong&gt;拥塞避免&lt;/strong&gt; 、&lt;strong&gt;快重传&lt;/strong&gt; 和 &lt;strong&gt;快恢复&lt;/strong&gt;。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，谈论拥塞控制的前提是不会发生流量控制，即接收方有足够大的接收缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_03.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;慢开始：&lt;/strong&gt; 为防止立即注入大量数据导致拥塞，先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。&lt;code&gt;cwnd&lt;/code&gt; 初始值为 1，每经过一个传播轮次，&lt;code&gt;cwnd&lt;/code&gt; 加倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在慢开始阶段出现超时，将令 &lt;code&gt;ssthresh = cwnd / 2&lt;/code&gt; 并重新执行慢开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拥塞避免：&lt;/strong&gt; 拥塞避免算法的思路是让拥塞窗口 &lt;code&gt;cwnd&lt;/code&gt; 缓慢增大，即每经过一个往返时间RTT就把发送方的 &lt;code&gt;cwnd&lt;/code&gt; 加 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;快重传与快恢复：&lt;/strong&gt; 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定下一个报文段丢失，立即重传丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。&lt;/p&gt;
&lt;p&gt;例如收到三个 M&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;，则 M&lt;!-- raw HTML omitted --&gt;3&lt;!-- raw HTML omitted --&gt; 丢失，立即重传 M&lt;!-- raw HTML omitted --&gt;3&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种情况下，丢失个别报文段不认作网络拥塞，因此执行快恢复，令 &lt;code&gt;ssthresh = cwnd / 2&lt;/code&gt; ，&lt;code&gt;cwnd = ssthresh&lt;/code&gt; ，此时&lt;!-- raw HTML omitted --&gt;直接进入拥塞避免&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;慢开始和快恢复的快慢，指的是 &lt;code&gt;cwnd&lt;/code&gt; 的起始值而非增长速率。慢开始 &lt;code&gt;cwnd&lt;/code&gt; 设定为 1，而快恢复 &lt;code&gt;cwnd&lt;/code&gt; 设定为 &lt;code&gt;ssthresh&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;udpuser-datagram-protocol&#34;&gt;UDP（User Datagram Protocol）&lt;/h2&gt;
&lt;p&gt;用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_04.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。&lt;/p&gt;
- https://winterorch.github.io/posts/computer_network-transport_layer/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
        <link>https://winterorch.github.io/posts/leetcode-jianzhi-059/</link>
        <pubDate>Tue, 01 Jun 2021 17:45:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-jianzhi-059/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-jianzhi-059/ -&lt;h1 id=&#34;剑指-offer-59---i-滑动窗口的最大值httpsleetcode-cncomproblemshua-dong-chuang-kou-de-zui-da-zhi-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/&#34;&gt;剑指 Offer 59 - I. 滑动窗口的最大值&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt; 和滑动窗口的大小 &lt;code&gt;k&lt;/code&gt;，请找出所有滑动窗口里的最大值。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:&lt;/p&gt;
&lt;p&gt;滑动窗口的位置                最大值&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1  3  -1] -3  5  3  6  7       3
1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以假设 &lt;em&gt;k&lt;/em&gt; 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解一-单调队列&#34;&gt;题解一 单调队列&lt;/h3&gt;
&lt;p&gt;要求滑动窗口内的最大值，首先想到的是双向队列，一边推窗一边保持最大元素在队首。由于要确保窗口长度，队列中存的是下标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;maxSlidingWindow&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] res = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt; - k + 1];
    Deque&amp;lt;Integer&amp;gt; deque = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!deque.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekFirst&lt;/span&gt;() == i - k) {
            deque.&lt;span style=&#34;color:#658b00&#34;&gt;removeFirst&lt;/span&gt;();
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!deque.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; nums[deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekLast&lt;/span&gt;()] &amp;lt; nums[i]) {
            deque.&lt;span style=&#34;color:#658b00&#34;&gt;removeLast&lt;/span&gt;();
        }
        deque.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(i);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i &amp;gt;= k - 1) {
            res[i - k + 1] = nums[deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekFirst&lt;/span&gt;()];
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;题解二--双向遍历&#34;&gt;题解二  双向遍历&lt;/h3&gt;
&lt;p&gt;如果通过固定队列长度可以来限制搜索范围，通过双向遍历也可以。不依靠队列的话有个问题，最大值会不断传播，如果 [0] 处是数组最大值，这一最大值可以一直传播到队尾。那我们必须进行适当的划分，让最大值最远传播 k 个数字（包含自己）。&lt;/p&gt;
&lt;p&gt;我们直接将队列分成一段段长为 &lt;code&gt;k&lt;/code&gt; 的区间，每一段区间中，第一次遍历取得前半段（&lt;code&gt;[0.. i % k]&lt;/code&gt;）上的最大值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; ++i) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % k == 0) {
        prefixMax[i] = nums[i];
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        prefixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(prefixMax[i - 1], nums[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后从后向前进行一次遍历，取得后半段（&lt;code&gt;[i % k .. k - 1]&lt;/code&gt;）上的最大值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = n - 1; i &amp;gt;= 0; --i) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i == n - 1 || (i + 1) % k == 0) {
        suffixMax[i] = nums[i];
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        suffixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i + 1], nums[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，我们要取以 &lt;code&gt;i&lt;/code&gt; 为起点长度为 &lt;code&gt;k&lt;/code&gt; 的窗口的最大值，实际要取的就是当前区间上 &lt;code&gt;[i % k .. k - 1]&lt;/code&gt; 上的最大值，和下一区间 &lt;code&gt;[0 .. (i - 1 + k) % k]&lt;/code&gt; 上的最大值。&lt;/p&gt;
&lt;p&gt;完整答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;maxSlidingWindow&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (n == 0) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[0];
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] prefixMax = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] suffixMax = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % k == 0) {
            prefixMax[i] = nums[i];
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            prefixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(prefixMax[i - 1], nums[i]);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = n - 1; i &amp;gt;= 0; --i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i == n - 1 || (i + 1) % k == 0) {
            suffixMax[i] = nums[i];
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            suffixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i + 1], nums[i]);
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] ans = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n - k + 1];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt;= n - k; ++i) {
        ans[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i], prefixMax[i + k - 1]);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-jianzhi-059/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>计算机网络 应用层</title>
        <link>https://winterorch.github.io/posts/computer_network-application_layer/</link>
        <pubDate>Mon, 31 May 2021 23:04:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/computer_network-application_layer/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/computer_network-application_layer/ -&lt;h3 id=&#34;常用端口及协议&#34;&gt;&lt;strong&gt;常用端口及协议&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;应用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;协议&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;端口号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;传输层&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;域名解析&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DNS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;53&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP/TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;长度超过 512 字节时使用 TCP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;动态主机配置协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DHCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;67/68&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简单网络管理协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SNMP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;161/162&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20/21&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;控制连接 21，数据连接 20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;远程终端协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TELNET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超文本传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;80&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简单邮件传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SMTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;邮件读取协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;POP3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;110&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网际报文存取协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IMAP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;143&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超文本传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTPS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;443&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;域名系统&#34;&gt;&lt;strong&gt;域名系统&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;DNS ( Domain Name System ) 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。&lt;/p&gt;
&lt;p&gt;域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_01.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;dns-使用-udptcp&#34;&gt;DNS 使用 UDP/TCP&lt;/h4&gt;
&lt;p&gt;DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这样 DNS 服务器负载更低，响应更快，不过这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。一般在两种情况下会使用 TCP 进行传输：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域传送&lt;/p&gt;
&lt;p&gt;辅域名服务器会定时（一般三小时）向主域名服务器查询变动，如有变动则需要区域传送来同步数据，这一过程数据量很大，且对可靠性有一定要求，因此使用 TCP&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一种比较少见的情况——客户端可以指定向 DNS 服务器查询时用 TCP，但很多 DNS 服务器都配置为仅支持 UDP 查询。&lt;/p&gt;
&lt;h4 id=&#34;dns-缓存&#34;&gt;DNS 缓存&lt;/h4&gt;
&lt;p&gt;DNS 有多级缓存，按离浏览器距离，有浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;文件传送协议&#34;&gt;&lt;strong&gt;文件传送协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;FTP ( File Transfer Protocol ) 使用 TCP 进行连接，它需要两个连接来传送一个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。&lt;/li&gt;
&lt;li&gt;数据连接：用来传送一个文件数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_03.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;动态主机配置协议&#34;&gt;&lt;strong&gt;动态主机配置协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;自动配置 IP 地址等信息，DHCP ( Dynamic Host Configuration Protocol ) 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。&lt;/p&gt;
&lt;p&gt;DHCP 工作过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。&lt;/li&gt;
&lt;li&gt;DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。&lt;/li&gt;
&lt;li&gt;如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。&lt;/li&gt;
&lt;li&gt;DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_04.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;远程登录协议&#34;&gt;&lt;strong&gt;远程登录协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。&lt;/p&gt;
&lt;p&gt;TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;电子邮件协议&#34;&gt;&lt;strong&gt;电子邮件协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。&lt;/p&gt;
&lt;p&gt;邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_05.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SMTP&lt;/p&gt;
&lt;p&gt;SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_06.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;POP3&lt;/p&gt;
&lt;p&gt;POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IMAP&lt;/p&gt;
&lt;p&gt;IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;http--https&#34;&gt;&lt;strong&gt;HTTP / HTTPS&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;原因&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1XX&lt;/td&gt;
&lt;td&gt;Informational（信息性）&lt;/td&gt;
&lt;td&gt;接收的请求正在处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2XX&lt;/td&gt;
&lt;td&gt;Success（成功）&lt;/td&gt;
&lt;td&gt;请求正常处理完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3XX&lt;/td&gt;
&lt;td&gt;Redirection（重定向）&lt;/td&gt;
&lt;td&gt;需要进行附加操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4XX&lt;/td&gt;
&lt;td&gt;Client Error（客户端错误）&lt;/td&gt;
&lt;td&gt;服务器无法处理请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5XX&lt;/td&gt;
&lt;td&gt;Server Error（服务器错误）&lt;/td&gt;
&lt;td&gt;服务器处理请求出错&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;HTTP/1.1 起默认使用长连接，用以保持连接特性，并支持请求的流水线 (Pipelining) 处理。实现长连接需要客户端和服务端都支持长连接。使用长连接的 HTTP 协议会在响应头加入这行代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;Connection:keep-alive
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;网页打开后，客户端与服务器间用于传输 HTTP 数据的 TCP 连接不会关闭，再次访问服务器时会继续使用。连接的保持时间由服务器设定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 本身是无状态协议，因此 Session 机制通过服务端记录用户状态。服务端为特定用户创建特定 Session 后用以标识和跟踪用户。&lt;/p&gt;
&lt;p&gt;大部分情况下，服务端通过在 Cookie 中附加 Session ID 来跟踪，并将 Session 存在缓存或数据库中。如果 Cookie 被禁用，也可以利用 URL 重写附在 URL 路径后面。&lt;/p&gt;
&lt;p&gt;不过诸如 Spring Security 等安全框架中采用 Token 认证，服务器通过&lt;code&gt;Payload&lt;/code&gt;、&lt;code&gt;Header&lt;/code&gt;和一个密钥(&lt;code&gt;secret&lt;/code&gt;)创建令牌（&lt;code&gt;Token&lt;/code&gt;）并将 &lt;code&gt;Token&lt;/code&gt; 发送给客户端，客户端将 &lt;code&gt;Token&lt;/code&gt; 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 &lt;code&gt;Authorization&lt;/code&gt;字段中：&lt;code&gt; Authorization: Bearer Token&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展：HTTP 协议的优化&lt;/p&gt;
&lt;p&gt;参考阅读材料： &lt;a href=&#34;https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?&#34;&gt;https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTTP1.1 引入了更多缓存控制策略，并允许对某个资源的部分请求，新增了 24 个错误状态响应码，请求和响应消息都支持 Host 头域（这使得多个主机可以共享一个IP，一台物理服务器从而可以存在多个虚拟主机），最重要的——支持了&lt;strong&gt;长连接&lt;/strong&gt;和请求的&lt;strong&gt;流水线处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2012年 Google 提出 SPDY 方案，通过多路复用 (Multiplexing) 提高 TCP 连接利用率（因为浏览器一般对同一域名有最大连接数限制），为每个 &lt;code&gt;Request&lt;/code&gt; 设置优先级（展示内容可以优先加载，优化了用户体验），加了首部压缩协议，并强制使用 HTTPS 保障安全，服务端也可以主动推动（例如客户端请求 &lt;code&gt;style.css&lt;/code&gt; 文件时，服务端可以将相关的 &lt;code&gt;style.js&lt;/code&gt; 也推送过去）。&lt;/p&gt;
&lt;p&gt;SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTPS 运行在 SSL/TLS 上，而 SSL/TLS 运行在 TCP 上，所有传输内容都经过对称加密，对称密钥用服务器方的证书进行了非对称加密。因此 HTTPS 消耗服务器资源比 HTTP 多。&lt;/p&gt;
&lt;p&gt;CA ( Certification Authority ) 负责签发证书，并且能够验证域名所属——通过 DNS 记录或指定 URI 下放置的特殊文件供 CA 通过外网访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果网站证书被 CA 私自发给了第三方，那第三方就能够利用证书实施中间人攻击了，因此 CA 信用非常重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;web-页面请求过程&#34;&gt;&lt;strong&gt;Web 页面请求过程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;也算是比较常见的面试题吧&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DHCP 配置主机信息&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:FF，将广播到与交换机连接的所有设备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ARP 解析 MAC 地址&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;DNS 解析域名&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;HTTP 请求页面 (TCP、HTTP)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/computer_network-application_layer/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
  </channel>
</rss> 