<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图拉国营噄茶馆</title>
    <link>https://winterorch.github.io/</link>
    <description>Recent content on 图拉国营噄茶馆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</copyright>
    <lastBuildDate>Thu, 24 Jun 2021 19:03:58 +0530</lastBuildDate>
    
        <atom:link href="https://winterorch.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    
        <item>
        <title>Spring 依赖注入注解的区分</title>
        <link>https://winterorch.github.io/posts/java-spring-annotation-di_methods/</link>
        <pubDate>Thu, 24 Jun 2021 19:03:58 +0530</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-spring-annotation-di_methods/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-spring-annotation-di_methods/ -&lt;p&gt;Spring 支持的依赖注入有 &lt;code&gt;@Autowired&lt;/code&gt; &lt;code&gt;@Resource&lt;/code&gt; &lt;code&gt;@Inject&lt;/code&gt; 三种&lt;/p&gt;
&lt;h3 id=&#34;autowired&#34;&gt;@Autowired&lt;/h3&gt;
&lt;p&gt;来自 &lt;code&gt;org.springframwork.beans.factory.annotation.Autowired&lt;/code&gt; ，装配顺序为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按 &lt;code&gt;type&lt;/code&gt; 在上下文中查找匹配的 bean&lt;/li&gt;
&lt;li&gt;如果有多个 bean，则按照 &lt;code&gt;name&lt;/code&gt; 进行匹配
&lt;ul&gt;
&lt;li&gt;如有 &lt;code&gt;@Qualifier&lt;/code&gt; ，则按指定的 name 进行匹配&lt;/li&gt;
&lt;li&gt;如没有，则按变量名进行匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;匹配不到就报错&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;@Autowired(required=false)&lt;/code&gt; 则注入失败不抛异常&lt;/p&gt;
&lt;h3 id=&#34;inject&#34;&gt;@Inject&lt;/h3&gt;
&lt;p&gt;Spring 环境下和 &lt;code&gt;@Autowired&lt;/code&gt; 相同，都依赖 &lt;code&gt;AutowiredAnnotationBeanPostProcess&lt;/code&gt; 进行处理，但不能 &lt;code&gt;(required=false)&lt;/code&gt;。&lt;code&gt;@Inject&lt;/code&gt; 由 JSR-330 定义，可以切换到谷歌的 DI 框架——Guice。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@Inject&lt;/code&gt; 在 Java EE 包内，SE 环境需要单独引入。&lt;/p&gt;
&lt;h3 id=&#34;resource&#34;&gt;@Resource&lt;/h3&gt;
&lt;p&gt;JSR-250 定义。在 &lt;code&gt;CommonAnnotationBeanPostProcessor&lt;/code&gt; 实现处理。同样有 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt;。装配顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如同时指定 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; ，从上下文找到唯一匹配 bean 进行装配，找不到抛异常&lt;/li&gt;
&lt;li&gt;如指定 &lt;code&gt;name&lt;/code&gt; ，则到上下文找 &lt;code&gt;id&lt;/code&gt; 匹配的 bean 进行装配，找不到抛异常&lt;/li&gt;
&lt;li&gt;如指定 &lt;code&gt;type&lt;/code&gt; ，则到上下文找类型匹配的唯一 bean 进行装配，找不到或找到不唯一都会抛异常&lt;/li&gt;
&lt;li&gt;如果都没有指定，则默认按 &lt;code&gt;byName&lt;/code&gt; 方式装配，找不到再按 &lt;code&gt;byType&lt;/code&gt; 进行装配&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;IDEA 使用 &lt;code&gt;@Autowired&lt;/code&gt; 时很常见警告 Field injection is not recommended。&lt;/p&gt;
&lt;p&gt;Spring 团队建议永远使用构造方法，也就是 &lt;code&gt;c-args&lt;/code&gt; 进行依赖注入。IDEA 对这一警告的默认修改方式也是——创建一个构造器进行依赖注入。并且，跟据 Spring 团队建议，对必须的依赖，应当使用断言进行确认&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Assert.&lt;span style=&#34;color:#658b00&#34;&gt;notNull&lt;/span&gt;(svc, &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;svc must not be null&amp;#34;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为什么不能用成员依赖注入呢？&lt;/p&gt;
&lt;p&gt;field 注入虽然简洁，但存在问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于添加依赖过于简单（加个注释），我们很容易无意识地向一个类注入大量依赖，这违反了单一职责原理，因为我们过去通过构造器进行注入，而要是你的构造器出现大量入参，那很容易意识到自己的代码结构不对劲。打个比方——原本要数着钞票买东西的，一下子变成移动支付，点一下付钱了，就容易到了月底为账单发愁，因为我们金钱意识变薄弱了。解决方法就是——继续用构造器注入，因此对于强制依赖，Spring推荐用 &lt;code&gt;c-args&lt;/code&gt; 注入。&lt;/li&gt;
&lt;li&gt;依赖注入与容器本身耦合了，即——类唯一的正常工作方式就是通过容器反射进行实例化，这就像是集成测试一样，不像个健康的类，就像一个人原本你把饭给他就能自己吃，现在非要注射进去一样。为了让类能在容器外使用，自然还是要用 &lt;code&gt;c-args&lt;/code&gt; 和 &lt;code&gt;s-args&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;属性注入不能用来注入 &lt;code&gt;final&lt;/code&gt; 变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;因此 Spring 给出建议：&lt;code&gt;constructor-based&lt;/code&gt; 和 &lt;code&gt;setter-based&lt;/code&gt; DI 可以混用，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;强制依赖就用 &lt;code&gt;constructor-based&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很好理解，类离开强制依赖就无法工作，这和构造方法职能相吻合，也能注入 &lt;code&gt;final&lt;/code&gt; 变量。构造器可以保证这些变量的值不会是 null 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选、可变依赖用 &lt;code&gt;setter-based&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setter&lt;/code&gt; 值应被用于注入非必须依赖，这些依赖可以很方便地被改变或重新注入，否则会需要大量的 null 检查。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/java-spring-annotation-di_methods/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>LeetCode 752 - 打开转盘锁</title>
        <link>https://winterorch.github.io/posts/leetcode-752-open_the_lock/</link>
        <pubDate>Thu, 24 Jun 2021 15:11:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-752-open_the_lock/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-752-open_the_lock/ -&lt;h1 id=&#34;leetcode-752-open-the-lock&#34;&gt;[LeetCode] 752. Open the Lock&lt;/h1&gt;
&lt;p&gt;You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: &lt;code&gt;&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;&lt;/code&gt;. The wheels can rotate freely and wrap around: for example we can turn &lt;code&gt;&#39;9&#39;&lt;/code&gt; to be &lt;code&gt;&#39;0&#39;&lt;/code&gt;, or &lt;code&gt;&#39;0&#39;&lt;/code&gt; to be &lt;code&gt;&#39;9&#39;&lt;/code&gt;. Each move consists of turning one wheel one slot.&lt;/p&gt;
&lt;p&gt;The lock initially starts at &lt;code&gt;&#39;0000&#39;&lt;/code&gt;, a string representing the state of the 4 wheels.&lt;/p&gt;
&lt;p&gt;You are given a list of &lt;code&gt;deadends&lt;/code&gt; dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.&lt;/p&gt;
&lt;p&gt;Given a &lt;code&gt;target&lt;/code&gt; representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;0201&amp;quot;,&amp;quot;0101&amp;quot;,&amp;quot;0102&amp;quot;,&amp;quot;1212&amp;quot;,&amp;quot;2002&amp;quot;], target = &amp;quot;0202&amp;quot;
Output: 6
Explanation:
A sequence of valid moves would be &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;1000&amp;quot; -&amp;gt; &amp;quot;1100&amp;quot; -&amp;gt; &amp;quot;1200&amp;quot; -&amp;gt; &amp;quot;1201&amp;quot; -&amp;gt; &amp;quot;1202&amp;quot; -&amp;gt; &amp;quot;0202&amp;quot;.
Note that a sequence like &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;0001&amp;quot; -&amp;gt; &amp;quot;0002&amp;quot; -&amp;gt; &amp;quot;0102&amp;quot; -&amp;gt; &amp;quot;0202&amp;quot; would be invalid,
because the wheels of the lock become stuck after the display becomes the dead end &amp;quot;0102&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 2:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;8888&amp;quot;], target = &amp;quot;0009&amp;quot;
Output: 1
Explanation:
We can turn the last wheel in reverse to move from &amp;quot;0000&amp;quot; -&amp;gt; &amp;quot;0009&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 3:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;8887&amp;quot;,&amp;quot;8889&amp;quot;,&amp;quot;8878&amp;quot;,&amp;quot;8898&amp;quot;,&amp;quot;8788&amp;quot;,&amp;quot;8988&amp;quot;,&amp;quot;7888&amp;quot;,&amp;quot;9888&amp;quot;], target = &amp;quot;8888&amp;quot;
Output: -1
Explanation:
We can&#39;t reach the target without getting stuck.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Example 4:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Input: deadends = [&amp;quot;0000&amp;quot;], target = &amp;quot;8888&amp;quot;
Output: -1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= deadends.length &amp;lt;= 500&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deadends[i].length == 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target.length == 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;target will not be in the list &lt;code&gt;deadends&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;target&lt;/code&gt; and &lt;code&gt;deadends[i]&lt;/code&gt; consist of digits only.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解--双向-bfs&#34;&gt;题解  双向 BFS&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;类似题：&lt;a href=&#34;https://github.com/grandyang/leetcode/issues/126&#34;&gt;LeetCode 127 Word Ladder II&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到有 &lt;code&gt;deadends&lt;/code&gt; 其实就比较明显了——这是个走迷宫问题，而且因为有四位密码，所以其实是个四维迷宫。维数并不会增加解法的复杂程度，倒是会严重增加敲代码的繁琐程度。一开始是打算真的和迷宫一样，用四维数组做的，后来发现参数实在太多了，光敲一个位置就要 &lt;code&gt;mem[i0][i1][i2][i3]&lt;/code&gt; 这样来一遍，实在有点头皮发麻，改用 &lt;code&gt;String&lt;/code&gt; 和 &lt;code&gt;Map&lt;/code&gt; 来做记忆化了。&lt;/p&gt;
&lt;p&gt;还是当作迷宫来解，因此思想是 BFS ，因为入口和出口都是唯一确定的，前后都可以作为 BFS 的起点，因此可以通过双向 BFS 来收缩搜索范围。&lt;/p&gt;
&lt;p&gt;首先把 &lt;code&gt;deadends&lt;/code&gt; 存到一个 &lt;code&gt;HashSet&lt;/code&gt; 里，方便查验。BFS 需要前后两个队列，分别维护一个记忆化搜索表，记录到 &lt;code&gt;key&lt;/code&gt; 位置的步长。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt; Deque&amp;lt;String&amp;gt; d1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(),
						  d2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
Map&amp;lt;String, Integer&amp;gt; m1 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;(), 
									 m2 = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
d1.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(s);
m1.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(s, 0);
d2.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(t);
m2.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(t, 0);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后就是 BFS 了，一直搜到队列空为止。为了尽量收缩双向 BFS 的搜索范围，每次&lt;!-- raw HTML omitted --&gt;从更小的队列取元素进行搜索&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!d1.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !d2.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; t = -1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (d1.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;lt;= d2.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
        t = update(d1, m1, m2);
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        t = update(d2, m2, m1);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (t != -1) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; t;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;每次搜索要搜相邻的八个位置，也就是每一位的前后两个数字。原数字是 &lt;code&gt;char[i]&lt;/code&gt; 的话，以十为模加一或加九就行了——&lt;code&gt;(char) (&#39;0&#39; + ((chars[i] - &#39;0&#39; + offset) % 10))&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;新状态的检查包括这样一些原则——&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新位置不能是 &lt;code&gt;deadend&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新位置不能已经去过（在同一队列中），同一队列两次经过同一位置步长一定不会变短，也就不需要考虑了&lt;/li&gt;
&lt;li&gt;在满足前两个前提下，如果能在反向记忆中找到相同状态，那一定是最短路径，直接输出&lt;/li&gt;
&lt;li&gt;不在反向记忆中，就加入到当前记忆队列中，从而引起下一轮 BFS&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ori = chars[i];
chars[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;) (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + ((chars[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + offset) % 10));
String go = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(chars);
chars[i] = ori;

&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(go))
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go))
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go)) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt; = step + 1 + ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(go);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
}
fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(go, step + 1);
fs.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(go);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;完整代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; res;
&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] offset = {1, 9};
Set&amp;lt;String&amp;gt; deadEnds;
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;openLock_remastered&lt;/span&gt;(String[] dead, String target) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (target.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;))
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt; = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#228b22&#34;&gt;// 虽然这里 IDE 会推荐让 Arrays 来把 String[] 转换成 Collection,但这样做对速度没有好处。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#228b22&#34;&gt;// IDE 上测出来差别不大，但到了 LeetCode 上居然能让整题多耗将近一倍时间，百思不得其解。
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (String str: dead)
        deadEnds.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(str);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (deadEnds.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;))
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    Deque&amp;lt;String&amp;gt; front = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    Map&amp;lt;String, Integer&amp;gt; front_map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    Deque&amp;lt;String&amp;gt; back = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    Map&amp;lt;String, Integer&amp;gt; back_map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
    front.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;);
    front_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;, 0);
    back.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(target);
    back_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(target, 0);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!front.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; !back.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (front.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;() &amp;lt; back.&lt;span style=&#34;color:#658b00&#34;&gt;size&lt;/span&gt;()) {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (update(front, front_map, back_map))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt;;
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (update(back, back_map, front_map))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt;;
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
}
&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;boolean&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;update&lt;/span&gt;(Deque&amp;lt;String&amp;gt; fs, Map&amp;lt;String, Integer&amp;gt; fs_map, Map&amp;lt;String, Integer&amp;gt; ot_map) {
    String cur = fs.&lt;span style=&#34;color:#658b00&#34;&gt;pollFirst&lt;/span&gt;();
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] chars = cur.&lt;span style=&#34;color:#658b00&#34;&gt;toCharArray&lt;/span&gt;();
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; step = fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(cur);
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; offset : &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;offset&lt;/span&gt;) {
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt; ori = chars[i];
            &lt;span style=&#34;color:#228b22&#34;&gt;// 在原 char[] 上改了，取完 String 再转回去，
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#228b22&#34;&gt;// 会比 clone() 新的要快很多
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;					 chars[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;) (&lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + ((chars[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt; + offset) % 10));
					 String go = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(chars);
					 chars[i] = ori;	
          
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;deadEnds&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(go))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go))
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(go)) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;res&lt;/span&gt; = step + 1 + ot_map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(go);
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;true&lt;/span&gt;;
            }
            fs_map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(go, step + 1);
            fs.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(go);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;false&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h3 id=&#34;题解--astar-算法&#34;&gt;题解  AStar 算法&lt;/h3&gt;
&lt;p&gt;作者：AC_OIer
链接：https://leetcode-cn.com/problems/open-the-lock/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-wyr9/&lt;/p&gt;
&lt;p&gt;可以直接根据本题规则来设计 A* 的「启发式函数」。&lt;/p&gt;
&lt;p&gt;比如对于两个状态 a 和 b 可直接计算出「理论最小转换次数」：不同字符的转换成本之和 。&lt;/p&gt;
&lt;p&gt;需要注意的是：由于我们衡量某个字符 str 的估值是以目标字符串 target 为基准，因此我们只能确保 target 出队时为「距离最短」，而不能确保中间节点出队时「距离最短」，因此我们不能单纯根据某个节点是否「曾经入队」而决定是否入队，还要结合当前节点的「最小距离」是否被更新而决定是否入队。&lt;/p&gt;
&lt;p&gt;这一点十分关键，在代码层面上体现在 map.get(str).step &amp;gt; poll.step + 1 的判断上。&lt;/p&gt;
&lt;p&gt;注意：本题用 A* 过了，但通常我们需要先「确保有解」，A* 的启发搜索才会发挥真正价值。而本题，除非 t 本身在 deadends 中，其余情况我们无法很好提前判断「是否有解」。对于无解的情况 A* 效果不如「双向 BFS」。&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Solution&lt;/span&gt; {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Node&lt;/span&gt; {
        String str;
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; val, step;
       &lt;span style=&#34;color:#228b22&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  str : 对应字符串
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  val : 估值（与目标字符串 target 的最小转换成本）
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        *  step: 对应字符串是经过多少步转换而来
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;        */&lt;/span&gt;
        Node(String _str, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; _val, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; _step) {
            str = _str;
            val = _val;
            step = _step;
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;f&lt;/span&gt;(String str) {
        &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; ans = 0;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++) {
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; cur = str.&lt;span style=&#34;color:#658b00&#34;&gt;charAt&lt;/span&gt;(i) - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;, target = t.&lt;span style=&#34;color:#658b00&#34;&gt;charAt&lt;/span&gt;(i) - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; a = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(cur, target), b = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(cur, target);
            &lt;span style=&#34;color:#228b22&#34;&gt;// 在「正向转」和「反向转」之间取 min
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; min = Math.&lt;span style=&#34;color:#658b00&#34;&gt;min&lt;/span&gt;(b - a, a + 10 - b);
            ans += min;
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;
    }
    String s, t;
    Set&amp;lt;String&amp;gt; set = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#008b45&#34;&gt;openLock&lt;/span&gt;(String[] ds, String _t) {
        s = &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#34;0000&amp;#34;&lt;/span&gt;;
        t = _t;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (s.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(t)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; 0;
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (String d : ds) set.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(d);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (set.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(s)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
        
        PriorityQueue&amp;lt;Node&amp;gt; q = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;((a,b)-&amp;gt;a.&lt;span style=&#34;color:#658b00&#34;&gt;val&lt;/span&gt;-b.&lt;span style=&#34;color:#658b00&#34;&gt;val&lt;/span&gt;);
        Map&amp;lt;String, Node&amp;gt; map = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();
        Node root = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Node(s, f(s), 0);
        q.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(root);
        map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(s, root);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!q.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;()) {
            Node poll = q.&lt;span style=&#34;color:#658b00&#34;&gt;poll&lt;/span&gt;();
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] pcs = poll.&lt;span style=&#34;color:#658b00&#34;&gt;str&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;toCharArray&lt;/span&gt;();
            &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; step = poll.&lt;span style=&#34;color:#658b00&#34;&gt;step&lt;/span&gt;;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (poll.&lt;span style=&#34;color:#658b00&#34;&gt;str&lt;/span&gt;.&lt;span style=&#34;color:#658b00&#34;&gt;equals&lt;/span&gt;(t)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; step;
            &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 4; i++) {
                &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; j = -1; j &amp;lt;= 1; j++) {
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (j == 0) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; cur = pcs[i] - &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;;
                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; next = (cur + j) % 10;
                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (next == -1) next = 9;

                    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;[] clone = pcs.&lt;span style=&#34;color:#658b00&#34;&gt;clone&lt;/span&gt;();
                    clone[i] = (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;char&lt;/span&gt;)(next + &lt;span style=&#34;color:#cd5555&#34;&gt;&amp;#39;0&amp;#39;&lt;/span&gt;);
                    String str = String.&lt;span style=&#34;color:#658b00&#34;&gt;valueOf&lt;/span&gt;(clone);

                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (set.&lt;span style=&#34;color:#658b00&#34;&gt;contains&lt;/span&gt;(str)) &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
                    &lt;span style=&#34;color:#228b22&#34;&gt;// 如果 str 还没搜索过，或者 str 的「最短距离」被更新，则入队
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;                    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!map.&lt;span style=&#34;color:#658b00&#34;&gt;containsKey&lt;/span&gt;(str) || map.&lt;span style=&#34;color:#658b00&#34;&gt;get&lt;/span&gt;(str).&lt;span style=&#34;color:#658b00&#34;&gt;step&lt;/span&gt; &amp;gt; step + 1) {
                        Node node = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; Node(str, step + 1 + f(str), step + 1);
                        map.&lt;span style=&#34;color:#658b00&#34;&gt;put&lt;/span&gt;(str, node);
                        q.&lt;span style=&#34;color:#658b00&#34;&gt;add&lt;/span&gt;(node);
                    }
                }
            }
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-752-open_the_lock/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
        <link>https://winterorch.github.io/posts/leetcode-jianzhi-056/</link>
        <pubDate>Sun, 20 Jun 2021 21:03:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-jianzhi-056/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-jianzhi-056/ -&lt;h1 id=&#34;剑指-offer-56---i-数组中数字出现的次数httpsleetcode-cncomproblemsshu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/&#34;&gt;剑指 Offer 56 - I. 数组中数字出现的次数&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2 &amp;lt;= nums.length &amp;lt;= 10000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解&#34;&gt;题解&lt;/h3&gt;
&lt;p&gt;时空复杂度已经很明显提示了，要用位运算，异或消除掉出现过两次的数字&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num : nums)
    n ^= num;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果只有一个出现一次的数字，那答案已经出来了。然而这题有两个数字 &lt;code&gt;x, y&lt;/code&gt;，得到的 &lt;code&gt;n&lt;/code&gt; 是两者的异或 &lt;code&gt;n = x ^ y&lt;/code&gt; 。因为 &lt;code&gt;x != y&lt;/code&gt; ，&lt;code&gt;n&lt;/code&gt; 必定有至少一个非零位，接下来肯定得围绕着这个非零位作文章。&lt;/p&gt;
&lt;p&gt;而这个非零位有什么用呢？它告诉我们，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 中有一个 (&lt;code&gt;x&lt;/code&gt;) 在该比特位上非零，另一个 (&lt;code&gt;y&lt;/code&gt;) 为零。前面知道，通过异或只能得出唯一一个出现一次的数字，而现在有两个数字，那思路应当是——把这两个数字区分开来，分成具有不同特点的两组，这样就能分别求出这两个数字了。而现在，这个用来区分的特点有了——在 &lt;code&gt;n&lt;/code&gt; 最低非零位上是否为零。&lt;/p&gt;
&lt;p&gt;因此，接下来要做的就是——再遍历一遍原数组，在 &lt;code&gt;n&lt;/code&gt; 最低非零位上跟据是否为零放到两个 &lt;code&gt;int&lt;/code&gt; 上去异或。&lt;/p&gt;
&lt;p&gt;完整答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;singleNumbers&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; x = 0, y = 0, n = 0, m = 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num : nums)               &lt;span style=&#34;color:#228b22&#34;&gt;// 1. 遍历异或
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        n ^= num;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt;((n &amp;amp; m) == 0)               &lt;span style=&#34;color:#228b22&#34;&gt;// 2. 循环左移，计算 m
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        m &amp;lt;&amp;lt;= 1;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; num: nums) {              &lt;span style=&#34;color:#228b22&#34;&gt;// 3. 遍历 nums 分组
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt;((num &amp;amp; m) != 0)
            x ^= num;                 &lt;span style=&#34;color:#228b22&#34;&gt;// 4. 当 num &amp;amp; m != 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt;
            y ^= num;                 &lt;span style=&#34;color:#228b22&#34;&gt;// 4. 当 num &amp;amp; m == 0
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] {x, y};          &lt;span style=&#34;color:#228b22&#34;&gt;// 5. 返回出现一次的数字
&lt;/span&gt;&lt;span style=&#34;color:#228b22&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-jianzhi-056/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>接口与抽象类的区别</title>
        <link>https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/</link>
        <pubDate>Wed, 02 Jun 2021 20:04:58 +0130</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/ -&lt;p&gt;先简单过一下接口语法中的注意点。&lt;/p&gt;
&lt;h3 id=&#34;注意点&#34;&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;接口中的变量隐式指定为 &lt;code&gt;public static final&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口中的方法会被隐式指定为 &lt;code&gt;public abstract&lt;/code&gt; （JDK 1.9 后允许 private，其它修饰符会报错）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这也决定了接口中所有方法都必须被实现，当然这一要求有两种特殊的满足方式——抽象类实现接口，那么接口方法不一定要实现，可以由抽象类的子类实现；JDK 1.8 后有默认实现的接口方法也不必被实现类显式实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接口不能有构造方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 1.8 后，接口可以有静态方法和方法体&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 1.8 后，接口方法可以有默认方法，用 &lt;code&gt;default&lt;/code&gt; 关键字修饰&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与抽象类语法上的区别&#34;&gt;与抽象类语法上的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个类可以实现多个接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个接口可以继承多个其它接口&lt;/p&gt;
&lt;p&gt;Java 接口是对行为的抽象，一个行为本身可以看作多个行为的耦合&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;interface&lt;/span&gt; &lt;span style=&#34;color:#008b45;font-weight:bold&#34;&gt;Hockey&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;extends&lt;/span&gt; Sports, Event
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;接口与抽象类区别&#34;&gt;接口与抽象类区别&lt;/h2&gt;
&lt;p&gt;接口和抽象类语法上的不同在之前两个文档中都已经接释清楚了，这里主要看两者思想上的不同。&lt;/p&gt;
&lt;p&gt;摘取一些《Effective Java》中的说法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;接口是对行为的抽象，达到 &lt;strong&gt;API 定义与实现分类&lt;/strong&gt; 的目的，因此支持多实现。甚至可以用没有任何方法的接口，作为 Marker Interface，目的仅仅是进行声明。但是用接口导出常量是不合适的使用，接口应当尽量减少细节泄露，常量应当由类保管。&lt;/p&gt;
&lt;p&gt;相较之下，抽象类的主要目的是 &lt;strong&gt;代码重用&lt;/strong&gt;，本质是不能实例化的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重点有两个——抽象类和接口的本质、目的都不同。&lt;/p&gt;
&lt;h3 id=&#34;本质&#34;&gt;本质&lt;/h3&gt;
&lt;p&gt;抽象类本质是类，因此不能多继承。C++ 允许多继承而 Java 不允许，这体现两者多态思想上的差别。我们知道 Java 继承其实叫 &lt;code&gt;extends&lt;/code&gt; ，严格来讲不叫“继承”，因为在 Java 中，继承首先是一种 &lt;code&gt;is-a&lt;/code&gt; 关系，即 &lt;code&gt;Student&lt;/code&gt; 要继承 &lt;code&gt;Person&lt;/code&gt; ，首先要满足 “&lt;code&gt;Student&lt;/code&gt; &lt;code&gt;is a&lt;/code&gt; &lt;code&gt;Person&lt;/code&gt;” 。这很好理解，按照里氏替换原则 (Liskov Substitution)，进行继承关系抽象时，凡是可以用父类或者基类的地方，都可以用子类进行替换。因此这显然不是中文里面继承的语义，因为中文里“儿子继承父亲”，但儿子不可能是父亲，两者有本质区别。&lt;/p&gt;
&lt;p&gt;然后，Java 为什么只允许单继承就很好理解了。如果我想让 A 同时继承 B 和 C，那说明 A is B, A is C，那 B 和 C 之间自然应当满足某种继承关系，三者应当是一个继承链的关系而非继承树的关系，通过单继承也可以表示清楚，并不需要让 A 同时继承 B 和 C。更不用说 C++ 为了实现多继承，其实也带来菱形继承问题，可能造成内存浪费和数据冗余。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;C++中因为允许多继承，可能会因为&lt;strong&gt;菱形继承&lt;/strong&gt;造成内存浪费和数据冗余（如两个类BC分别继承同一基类A，再从这两个类派生出一个类D时会有冗余成员），因此最好使用虚继承。虚继承下，D实例内存地址中，BC虚继承来的A部分会通过一个指针分别指向一张虚基表（准确来讲是指向其中的虚基表偏移指针的存储地址，然后通过该指针取出偏移量），从虚基表中取出从基类A虚继承来成员在D内存中的偏移地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;曾看到有博客认为 C++ 多继承机制较为合理，给出的理由是“人可以有父母，那类也应当可以多继承”。结合前文内容，这个理由显然没有什么道理，但是我认为却很好地反映了 Java 中接口的思想。我们知道，对于生物而言，父和母显然是不等价的，母完成了作为母的职责，父完成了作为父的职责，然后才有“子”，因此与其类比为继承，不如类比为接口实现更妥当，因为父、母实际上在这里归根结底是&lt;strong&gt;行为的抽象&lt;/strong&gt;，父类必须实现接口 &lt;code&gt;CanBeFather&lt;/code&gt;，母类必须实现接口 &lt;code&gt;CanBeMother&lt;/code&gt;，这是一种行为关系。这一接口在使用过程中屏蔽了其它底层细节，无论父母是什么学历、有什么资产，这一过程中都不关注，也没有影响，这便是类功能上的解耦，通过一个用来将行为抽象化的接口完成了。&lt;/p&gt;
&lt;h3 id=&#34;目的&#34;&gt;目的&lt;/h3&gt;
&lt;p&gt;目的上面其实也说了，《Effective Java》总结的很到位，接口是对行为的抽象，达到 &lt;strong&gt;API 定义与实现分类&lt;/strong&gt; 的目的。如果一个类可以有多个行为、实现多个功能，那它当然可以实现多个接口。&lt;/p&gt;
&lt;p&gt;而抽象类更多还是用来减少冗余代码，换句话说——提高代码质量、提高可读性、降低维护难度……&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;java-继承与里氏替换原则&#34;&gt;Java 继承与里氏替换原则&lt;/h2&gt;
&lt;p&gt;Java中子类重写父类方法时&lt;!-- raw HTML omitted --&gt;不能抛出父类中没有抛出的异常&lt;!-- raw HTML omitted --&gt;，编译会不过，不抛是完全可以的。同时，该方法在子类中的访问级别也不能低于超类中的访问级别。&lt;!-- raw HTML omitted --&gt;这两项规则确保可使用超类实例的地方也能使用子类实例，符合&lt;strong&gt;里氏替换原则&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;变量&lt;/strong&gt;只能被隐藏（静态及非静态），不能被覆盖&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态方法&lt;/strong&gt;只能被隐藏，不能覆盖&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态方法&lt;/strong&gt;只能用静态方法隐藏，&lt;strong&gt;非静态方法&lt;/strong&gt;只能用非静态方法覆盖（否则编译不过）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终方法&lt;/strong&gt;不能覆盖。私有方法（private）实际会被隐式指定为 final ，所以同样不能覆盖。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象方法&lt;/strong&gt;必须覆盖&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时要注意的是关于构造方法的内容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类实例化对象时，如果子类构造方法没有显式调用父类构造方法，默认调用 &lt;code&gt;super()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子类要使用父类有参构造方法，使用 &lt;code&gt;super(...)&lt;/code&gt; 形式，且 &lt;code&gt;super()&lt;/code&gt; 必须是子类构造方法中第一行语句&lt;/li&gt;
&lt;li&gt;父类没有不带参构造方法，子类构造方法中必须显示调用父类其它构造方法，否则编译不过&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>计算机网络 传输层</title>
        <link>https://winterorch.github.io/posts/computer_network-transport_layer/</link>
        <pubDate>Wed, 02 Jun 2021 09:14:28 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/computer_network-transport_layer/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/computer_network-transport_layer/ -&lt;p&gt;网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tcp-与-udp-协议区别&#34;&gt;TCP 与 UDP 协议区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;连接&lt;/th&gt;
&lt;th&gt;传输可靠性&lt;/th&gt;
&lt;th&gt;传输形式&lt;/th&gt;
&lt;th&gt;传输效率&lt;/th&gt;
&lt;th&gt;所需资源&lt;/th&gt;
&lt;th&gt;应用场景&lt;/th&gt;
&lt;th&gt;首部字节&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TCP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;面向连接&lt;/td&gt;
&lt;td&gt;可靠&lt;/td&gt;
&lt;td&gt;字节流&lt;/td&gt;
&lt;td&gt;低&lt;/td&gt;
&lt;td&gt;多&lt;/td&gt;
&lt;td&gt;要求数据可靠性&lt;/td&gt;
&lt;td&gt;20 - 60&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;UDP&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;无连接&lt;/td&gt;
&lt;td&gt;不可靠&lt;/td&gt;
&lt;td&gt;数据报文段&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;少&lt;/td&gt;
&lt;td&gt;要求通信效率&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tcptransmission-control-protocol&#34;&gt;TCP（Transmission Control Protocol）&lt;/h2&gt;
&lt;p&gt;TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_01.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认号&lt;/strong&gt;   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据偏移&lt;/strong&gt;   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认 ACK&lt;/strong&gt;   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;同步 SYN&lt;/strong&gt;   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;终止 FIN&lt;/strong&gt;   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口&lt;/strong&gt;   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;一tcp-三次握手和四次挥手&#34;&gt;一、TCP 三次握手和四次挥手&lt;/h3&gt;
&lt;p&gt;可靠，TCP 协议的设计都是为了可靠无误&lt;/p&gt;
&lt;h4 id=&#34;11-三次握手&#34;&gt;1.1 三次握手&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/984872f6f3fd869be7b447fa70ace6b992fa9b599d8352b810a2d4893acb901c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/984872f6f3fd869be7b447fa70ace6b992fa9b599d8352b810a2d4893acb901c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67&#34; alt=&#34;TCP三次握手&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端–发送带有 SYN 标志的数据包–一次握手–服务端&lt;/li&gt;
&lt;li&gt;服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端&lt;/li&gt;
&lt;li&gt;客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么这么设计，可以从三次握手后双方获得的信息入手，对于发送方而言：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;自己发送正常&lt;/th&gt;
&lt;th&gt;自己接收正常&lt;/th&gt;
&lt;th&gt;对方发送正常&lt;/th&gt;
&lt;th&gt;对方接收正常&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于接收方而言：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;自己发送正常&lt;/th&gt;
&lt;th&gt;自己接收正常&lt;/th&gt;
&lt;th&gt;对方发送正常&lt;/th&gt;
&lt;th&gt;对方接收正常&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二次&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三次&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;td&gt;确认&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;要接收双方都能完整确认双方接收功能正常，三次握手缺一不可。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;第2次握手传回了ACK，为什么还要传回SYN？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;12-四次挥手&#34;&gt;1.2 四次挥手&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;断开一个 TCP 连接则需要“四次挥手”：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器-关闭与客户端的连接，发送一个FIN给客户端&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;TIME_WAIT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;传达信息&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A: FIN&lt;/td&gt;
&lt;td&gt;A：我没有数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B：ack&lt;/td&gt;
&lt;td&gt;B：我知道你没数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B：FIN&lt;/td&gt;
&lt;td&gt;B：我没有数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;A：ack&lt;/td&gt;
&lt;td&gt;A：我知道你没数据要传了&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;二tcp-如何保证可靠传输&#34;&gt;二、TCP 如何保证可靠传输&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;**分块：**应用数据被分割成 TCP 认为最适合发送的数据块。&lt;/li&gt;
&lt;li&gt;**有序：**TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;校验和：&lt;/strong&gt; TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。&lt;/li&gt;
&lt;li&gt;**去重：**TCP 的接收端会丢弃重复的数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流量控制：&lt;/strong&gt; TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拥塞控制：&lt;/strong&gt; 当网络拥塞时，减少数据的发送。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARQ协议：&lt;/strong&gt; 通过确认和超时机制实现可靠信息传输。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;超时重传：&lt;/strong&gt; 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;21-arq&#34;&gt;2.1 ARQ&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;自动重传请求&lt;/strong&gt;（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。&lt;/p&gt;
&lt;h5 id=&#34;停止等待arq协议&#34;&gt;&lt;strong&gt;停止等待ARQ协议&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;每发完一个分组就停止发送，等待对方确认（回复ACK）。如果超时还没有收到 ACK 确认，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 简单&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 信道利用率低，等待时间长&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;连续arq协议&#34;&gt;&lt;strong&gt;连续ARQ协议&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; 信道利用率高，容易实现，即使确认丢失，也不必重传。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;22-滑动窗口和流量控制&#34;&gt;2.2 滑动窗口和流量控制&lt;/h4&gt;
&lt;p&gt;窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。&lt;/strong&gt; 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。&lt;/p&gt;
&lt;h4 id=&#34;23-拥塞控制&#34;&gt;2.3 拥塞控制&lt;/h4&gt;
&lt;p&gt;拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。&lt;/p&gt;
&lt;p&gt;为了进行拥塞控制，TCP 发送方要维持一个 &lt;strong&gt;拥塞窗口(cwnd)&lt;/strong&gt; 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 窗口基于&lt;strong&gt;字节&lt;/strong&gt;，但这里拥塞窗口的大小单位是&lt;strong&gt;报文段&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;TCP的拥塞控制采用了四种算法，即 &lt;strong&gt;慢开始&lt;/strong&gt; 、 &lt;strong&gt;拥塞避免&lt;/strong&gt; 、&lt;strong&gt;快重传&lt;/strong&gt; 和 &lt;strong&gt;快恢复&lt;/strong&gt;。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，谈论拥塞控制的前提是不会发生流量控制，即接收方有足够大的接收缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_03.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;慢开始：&lt;/strong&gt; 为防止立即注入大量数据导致拥塞，先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。&lt;code&gt;cwnd&lt;/code&gt; 初始值为 1，每经过一个传播轮次，&lt;code&gt;cwnd&lt;/code&gt; 加倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果在慢开始阶段出现超时，将令 &lt;code&gt;ssthresh = cwnd / 2&lt;/code&gt; 并重新执行慢开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;拥塞避免：&lt;/strong&gt; 拥塞避免算法的思路是让拥塞窗口 &lt;code&gt;cwnd&lt;/code&gt; 缓慢增大，即每经过一个往返时间RTT就把发送方的 &lt;code&gt;cwnd&lt;/code&gt; 加 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;快重传与快恢复：&lt;/strong&gt; 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定下一个报文段丢失，立即重传丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。&lt;/p&gt;
&lt;p&gt;例如收到三个 M&lt;!-- raw HTML omitted --&gt;2&lt;!-- raw HTML omitted --&gt;，则 M&lt;!-- raw HTML omitted --&gt;3&lt;!-- raw HTML omitted --&gt; 丢失，立即重传 M&lt;!-- raw HTML omitted --&gt;3&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这种情况下，丢失个别报文段不认作网络拥塞，因此执行快恢复，令 &lt;code&gt;ssthresh = cwnd / 2&lt;/code&gt; ，&lt;code&gt;cwnd = ssthresh&lt;/code&gt; ，此时&lt;!-- raw HTML omitted --&gt;直接进入拥塞避免&lt;!-- raw HTML omitted --&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;慢开始和快恢复的快慢，指的是 &lt;code&gt;cwnd&lt;/code&gt; 的起始值而非增长速率。慢开始 &lt;code&gt;cwnd&lt;/code&gt; 设定为 1，而快恢复 &lt;code&gt;cwnd&lt;/code&gt; 设定为 &lt;code&gt;ssthresh&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;udpuser-datagram-protocol&#34;&gt;UDP（User Datagram Protocol）&lt;/h2&gt;
&lt;p&gt;用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-transport_layer_04.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。&lt;/p&gt;
- https://winterorch.github.io/posts/computer_network-transport_layer/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
        <link>https://winterorch.github.io/posts/leetcode-jianzhi-059/</link>
        <pubDate>Tue, 01 Jun 2021 17:45:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/leetcode-jianzhi-059/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/leetcode-jianzhi-059/ -&lt;h1 id=&#34;剑指-offer-59---i-滑动窗口的最大值httpsleetcode-cncomproblemshua-dong-chuang-kou-de-zui-da-zhi-lcof&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/&#34;&gt;剑指 Offer 59 - I. 滑动窗口的最大值&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt; 和滑动窗口的大小 &lt;code&gt;k&lt;/code&gt;，请找出所有滑动窗口里的最大值。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:&lt;/p&gt;
&lt;p&gt;滑动窗口的位置                最大值&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;[1  3  -1] -3  5  3  6  7       3
1 [3  -1  -3] 5  3  6  7       3
1  3 [-1  -3  5] 3  6  7       5
1  3  -1 [-3  5  3] 6  7       5
1  3  -1  -3 [5  3  6] 7       6
1  3  -1  -3  5 [3  6  7]      7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以假设 &lt;em&gt;k&lt;/em&gt; 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;题解一-单调队列&#34;&gt;题解一 单调队列&lt;/h3&gt;
&lt;p&gt;要求滑动窗口内的最大值，首先想到的是双向队列，一边推窗一边保持最大元素在队首。由于要确保窗口长度，队列中存的是下标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;maxSlidingWindow&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] res = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt; - k + 1];
    Deque&amp;lt;Integer&amp;gt; deque = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (!deque.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekFirst&lt;/span&gt;() == i - k) {
            deque.&lt;span style=&#34;color:#658b00&#34;&gt;removeFirst&lt;/span&gt;();
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;while&lt;/span&gt; (!deque.&lt;span style=&#34;color:#658b00&#34;&gt;isEmpty&lt;/span&gt;() &amp;amp;&amp;amp; nums[deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekLast&lt;/span&gt;()] &amp;lt; nums[i]) {
            deque.&lt;span style=&#34;color:#658b00&#34;&gt;removeLast&lt;/span&gt;();
        }
        deque.&lt;span style=&#34;color:#658b00&#34;&gt;addLast&lt;/span&gt;(i);
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i &amp;gt;= k - 1) {
            res[i - k + 1] = nums[deque.&lt;span style=&#34;color:#658b00&#34;&gt;peekFirst&lt;/span&gt;()];
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; res;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;题解二--双向遍历&#34;&gt;题解二  双向遍历&lt;/h3&gt;
&lt;p&gt;如果通过固定队列长度可以来限制搜索范围，通过双向遍历也可以。不依靠队列的话有个问题，最大值会不断传播，如果 [0] 处是数组最大值，这一最大值可以一直传播到队尾。那我们必须进行适当的划分，让最大值最远传播 k 个数字（包含自己）。&lt;/p&gt;
&lt;p&gt;我们直接将队列分成一段段长为 &lt;code&gt;k&lt;/code&gt; 的区间，每一段区间中，第一次遍历取得前半段（&lt;code&gt;[0.. i % k]&lt;/code&gt;）上的最大值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; ++i) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % k == 0) {
        prefixMax[i] = nums[i];
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        prefixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(prefixMax[i - 1], nums[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后从后向前进行一次遍历，取得后半段（&lt;code&gt;[i % k .. k - 1]&lt;/code&gt;）上的最大值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = n - 1; i &amp;gt;= 0; --i) {
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i == n - 1 || (i + 1) % k == 0) {
        suffixMax[i] = nums[i];
    } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
        suffixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i + 1], nums[i]);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后，我们要取以 &lt;code&gt;i&lt;/code&gt; 为起点长度为 &lt;code&gt;k&lt;/code&gt; 的窗口的最大值，实际要取的就是当前区间上 &lt;code&gt;[i % k .. k - 1]&lt;/code&gt; 上的最大值，和下一区间 &lt;code&gt;[0 .. (i - 1 + k) % k]&lt;/code&gt; 上的最大值。&lt;/p&gt;
&lt;p&gt;完整答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] &lt;span style=&#34;color:#008b45&#34;&gt;maxSlidingWindow&lt;/span&gt;(&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] nums, &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; k) {
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; n = nums.&lt;span style=&#34;color:#658b00&#34;&gt;length&lt;/span&gt;;
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (n == 0) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[0];
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] prefixMax = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] suffixMax = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt; n; ++i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i % k == 0) {
            prefixMax[i] = nums[i];
        }
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            prefixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(prefixMax[i - 1], nums[i]);
        }
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = n - 1; i &amp;gt;= 0; --i) {
        &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;if&lt;/span&gt; (i == n - 1 || (i + 1) % k == 0) {
            suffixMax[i] = nums[i];
        } &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            suffixMax[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i + 1], nums[i]);
        }
    }
    &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[] ans = &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt;[n - k + 1];
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#00688b;font-weight:bold&#34;&gt;int&lt;/span&gt; i = 0; i &amp;lt;= n - k; ++i) {
        ans[i] = Math.&lt;span style=&#34;color:#658b00&#34;&gt;max&lt;/span&gt;(suffixMax[i], prefixMax[i + k - 1]);
    }
    &lt;span style=&#34;color:#8b008b;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;- https://winterorch.github.io/posts/leetcode-jianzhi-059/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>计算机网络 应用层</title>
        <link>https://winterorch.github.io/posts/computer_network-application_layer/</link>
        <pubDate>Mon, 31 May 2021 23:04:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/computer_network-application_layer/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/computer_network-application_layer/ -&lt;h3 id=&#34;常用端口及协议&#34;&gt;&lt;strong&gt;常用端口及协议&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;应用&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;协议&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;端口号&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;传输层&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;域名解析&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DNS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;53&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP/TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;长度超过 512 字节时使用 TCP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;动态主机配置协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DHCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;67/68&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简单网络管理协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SNMP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;161/162&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;UDP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;文件传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;FTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;20/21&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;控制连接 21，数据连接 20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;远程终端协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TELNET&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;23&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超文本传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;80&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;简单邮件传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SMTP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;25&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;邮件读取协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;POP3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;110&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网际报文存取协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;IMAP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;143&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;超文本传送协议&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;HTTPS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;443&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;TCP&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h3 id=&#34;域名系统&#34;&gt;&lt;strong&gt;域名系统&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;DNS ( Domain Name System ) 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。&lt;/p&gt;
&lt;p&gt;域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_01.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;dns-使用-udptcp&#34;&gt;DNS 使用 UDP/TCP&lt;/h4&gt;
&lt;p&gt;DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这样 DNS 服务器负载更低，响应更快，不过这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。一般在两种情况下会使用 TCP 进行传输：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区域传送&lt;/p&gt;
&lt;p&gt;辅域名服务器会定时（一般三小时）向主域名服务器查询变动，如有变动则需要区域传送来同步数据，这一过程数据量很大，且对可靠性有一定要求，因此使用 TCP&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有一种比较少见的情况——客户端可以指定向 DNS 服务器查询时用 TCP，但很多 DNS 服务器都配置为仅支持 UDP 查询。&lt;/p&gt;
&lt;h4 id=&#34;dns-缓存&#34;&gt;DNS 缓存&lt;/h4&gt;
&lt;p&gt;DNS 有多级缓存，按离浏览器距离，有浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;文件传送协议&#34;&gt;&lt;strong&gt;文件传送协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;FTP ( File Transfer Protocol ) 使用 TCP 进行连接，它需要两个连接来传送一个文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。&lt;/li&gt;
&lt;li&gt;数据连接：用来传送一个文件数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_03.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;动态主机配置协议&#34;&gt;&lt;strong&gt;动态主机配置协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;自动配置 IP 地址等信息，DHCP ( Dynamic Host Configuration Protocol ) 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。&lt;/p&gt;
&lt;p&gt;DHCP 工作过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。&lt;/li&gt;
&lt;li&gt;DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。&lt;/li&gt;
&lt;li&gt;如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。&lt;/li&gt;
&lt;li&gt;DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_04.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;远程登录协议&#34;&gt;&lt;strong&gt;远程登录协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。&lt;/p&gt;
&lt;p&gt;TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;电子邮件协议&#34;&gt;&lt;strong&gt;电子邮件协议&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。&lt;/p&gt;
&lt;p&gt;邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_05.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;SMTP&lt;/p&gt;
&lt;p&gt;SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/computer_network-application_layer_06.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;POP3&lt;/p&gt;
&lt;p&gt;POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IMAP&lt;/p&gt;
&lt;p&gt;IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;http--https&#34;&gt;&lt;strong&gt;HTTP / HTTPS&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;状态码：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;原因&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1XX&lt;/td&gt;
&lt;td&gt;Informational（信息性）&lt;/td&gt;
&lt;td&gt;接收的请求正在处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2XX&lt;/td&gt;
&lt;td&gt;Success（成功）&lt;/td&gt;
&lt;td&gt;请求正常处理完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3XX&lt;/td&gt;
&lt;td&gt;Redirection（重定向）&lt;/td&gt;
&lt;td&gt;需要进行附加操作以完成请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4XX&lt;/td&gt;
&lt;td&gt;Client Error（客户端错误）&lt;/td&gt;
&lt;td&gt;服务器无法处理请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5XX&lt;/td&gt;
&lt;td&gt;Server Error（服务器错误）&lt;/td&gt;
&lt;td&gt;服务器处理请求出错&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;HTTP/1.1 起默认使用长连接，用以保持连接特性，并支持请求的流水线 (Pipelining) 处理。实现长连接需要客户端和服务端都支持长连接。使用长连接的 HTTP 协议会在响应头加入这行代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-http&#34; data-lang=&#34;http&#34;&gt;&lt;span style=&#34;color:#a61717;background-color:#e3d2d2&#34;&gt;Connection:keep-alive
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;网页打开后，客户端与服务器间用于传输 HTTP 数据的 TCP 连接不会关闭，再次访问服务器时会继续使用。连接的保持时间由服务器设定。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTTP 本身是无状态协议，因此 Session 机制通过服务端记录用户状态。服务端为特定用户创建特定 Session 后用以标识和跟踪用户。&lt;/p&gt;
&lt;p&gt;大部分情况下，服务端通过在 Cookie 中附加 Session ID 来跟踪，并将 Session 存在缓存或数据库中。如果 Cookie 被禁用，也可以利用 URL 重写附在 URL 路径后面。&lt;/p&gt;
&lt;p&gt;不过诸如 Spring Security 等安全框架中采用 Token 认证，服务器通过&lt;code&gt;Payload&lt;/code&gt;、&lt;code&gt;Header&lt;/code&gt;和一个密钥(&lt;code&gt;secret&lt;/code&gt;)创建令牌（&lt;code&gt;Token&lt;/code&gt;）并将 &lt;code&gt;Token&lt;/code&gt; 发送给客户端，客户端将 &lt;code&gt;Token&lt;/code&gt; 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 &lt;code&gt;Authorization&lt;/code&gt;字段中：&lt;code&gt; Authorization: Bearer Token&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;扩展：HTTP 协议的优化&lt;/p&gt;
&lt;p&gt;参考阅读材料： &lt;a href=&#34;https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?&#34;&gt;https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTTP1.1 引入了更多缓存控制策略，并允许对某个资源的部分请求，新增了 24 个错误状态响应码，请求和响应消息都支持 Host 头域（这使得多个主机可以共享一个IP，一台物理服务器从而可以存在多个虚拟主机），最重要的——支持了&lt;strong&gt;长连接&lt;/strong&gt;和请求的&lt;strong&gt;流水线处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2012年 Google 提出 SPDY 方案，通过多路复用 (Multiplexing) 提高 TCP 连接利用率（因为浏览器一般对同一域名有最大连接数限制），为每个 &lt;code&gt;Request&lt;/code&gt; 设置优先级（展示内容可以优先加载，优化了用户体验），加了首部压缩协议，并强制使用 HTTPS 保障安全，服务端也可以主动推动（例如客户端请求 &lt;code&gt;style.css&lt;/code&gt; 文件时，服务端可以将相关的 &lt;code&gt;style.js&lt;/code&gt; 也推送过去）。&lt;/p&gt;
&lt;p&gt;SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTPS 运行在 SSL/TLS 上，而 SSL/TLS 运行在 TCP 上，所有传输内容都经过对称加密，对称密钥用服务器方的证书进行了非对称加密。因此 HTTPS 消耗服务器资源比 HTTP 多。&lt;/p&gt;
&lt;p&gt;CA ( Certification Authority ) 负责签发证书，并且能够验证域名所属——通过 DNS 记录或指定 URI 下放置的特殊文件供 CA 通过外网访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果网站证书被 CA 私自发给了第三方，那第三方就能够利用证书实施中间人攻击了，因此 CA 信用非常重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;web-页面请求过程&#34;&gt;&lt;strong&gt;Web 页面请求过程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;也算是比较常见的面试题吧&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DHCP 配置主机信息&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:FF，将广播到与交换机连接的所有设备。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ARP 解析 MAC 地址&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:&amp;lt;zero-width space&amp;gt;FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;DNS 解析域名&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;HTTP 请求页面 (TCP、HTTP)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
- https://winterorch.github.io/posts/computer_network-application_layer/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>Java 抽象类</title>
        <link>https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/</link>
        <pubDate>Sun, 30 May 2021 20:01:58 +0530</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/ -&lt;h3 id=&#34;语法&#34;&gt;&lt;strong&gt;语法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;抽象类中可以存在&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造方法&lt;/li&gt;
&lt;li&gt;抽象方法&lt;/li&gt;
&lt;li&gt;非抽象方法&lt;/li&gt;
&lt;li&gt;成员变量&lt;/li&gt;
&lt;li&gt;静态成员变量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结：除了不能被实例化，抽象类几乎具有普通类的所有特性。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;注意点&#34;&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;抽象类&lt;strong&gt;不能被实例化&lt;/strong&gt;，如果试图实例化抽象类，编译无法通过&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类中&lt;strong&gt;可以有构造方法&lt;/strong&gt;，但是构造方法不能为抽象方法，其中原因见 [为什么构造函数不能为抽象]&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;抽象类及其实现的构造方法也必须遵循一般继承中的构造方法规范，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类实例化对象时，如果子类构造方法没有显式调用父类构造方法，默认调用 &lt;code&gt;super()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子类要使用父类有参构造方法，使用 &lt;code&gt;super(...)&lt;/code&gt; 形式，且 &lt;code&gt;super()&lt;/code&gt; 必须是子类构造方法中第一行语句&lt;/li&gt;
&lt;li&gt;父类没有不带参构造方法（只定义了有参构造方法而没有定义无参的），子类构造方法中必须显示调用父类其它构造方法，否则编译不过&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类中的&lt;strong&gt;静态方法也不能为抽象方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类中的抽象方法&lt;strong&gt;只能声明&lt;/strong&gt;，&lt;strong&gt;不能有具体实现&lt;/strong&gt;，这与接口不同（接口方法在 JDK 1.8 后也可以有默认实现），具体原因见  [为什么抽象方法不能有实现而接口方法可以]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;有端联想&#34;&gt;&lt;strong&gt;有端联想&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;抽象类总结了几个比较有嚼劲的问题&lt;/p&gt;
&lt;h4 id=&#34;1-为什么构造函数不能为抽象&#34;&gt;1. 为什么构造函数不能为抽象&lt;/h4&gt;
&lt;p&gt;Java 抽象函数 和 C++ 虚函数 是等价概念，因此这里直接从 C++ 的角度找答案了。结论就是——构造函数从语言和逻辑来看都不能为虚函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从内存结构角度来看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚函数对应虚函数表 vtable ，表为类所有，但虚函数表指针为每个对象所有，在构造函数运行时进行空间分配，因此构造函数无法在未创建虚表指针的情况下调用虚表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;从语言逻辑角度来看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构造函数目的是初始化实例，我们知道抽象类和虚基类都没有实例化的需求，将构造函数定义为虚函数是没有意义的。&lt;/p&gt;
&lt;p&gt;可以先回顾一下虚函数的作用过程——通过指针或者引用来调用虚函数的时候能够调用到子类的对应成员函数。而构造函数是在创建对象时自动调用的，调用这一函数的指针或引用所对应的对象还不存在，也就决定了构造函数不能是虚函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-为什么抽象方法不能有实现而接口方法可以&#34;&gt;2. 为什么抽象方法不能有实现而接口方法可以&lt;/h4&gt;
&lt;p&gt;JDK 1.8 以前两者都不能有实现，这对接口的实现造成了一些麻烦，因为很多时候我们希望接口方法能有一些默认实现，从而减少其实现类中的重复代码；更多的时候，我们实现接口也并不需要用到其中所有方法，但没有默认实现导致我们不得不在实现一个接口时实现其中所有方法（因此出现了很多用于适配接口与实现类的 &lt;code&gt;Adapter&lt;/code&gt; 类），哪怕根本不会用到。综上，JDK 1.8 以后接口也可以有默认实现了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这其实让我联想到数据库设计范式对数据库粒度的苛求。按照规范来说，如果有类在实现接口过程中存在用不到的方法，那说明接口的粒度仍不够小——对行为的定义不够细，但从另一方面来讲，追求完美的接口粒度又会使代码晦涩难懂，且不够灵活。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是抽象类中从一开始就不存在这个问题——因为抽象类并不只能包含抽象方法，还能包含普通方法，而 Java 中普通方法本身就是“虚函数”，允许子类重写。那么如果想要一个默认实现，直接写普通方法就行了。Java 语言设计抽象类的目的本就是方便代码重用，但在设计接口之初并没有把这一需求囊括进来。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;抽象方法&lt;/strong&gt;，仅用于标识子类&lt;strong&gt;必须实现&lt;/strong&gt;的方法（&lt;!-- raw HTML omitted --&gt;有一种特殊情况除外，就是&lt;strong&gt;子类也是抽象类&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;）。&lt;/p&gt;
- https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>JVM GC</title>
        <link>https://winterorch.github.io/posts/java-jvm-ram_and_gc/</link>
        <pubDate>Wed, 17 Mar 2021 22:03:58 +0630</pubDate>
        
        <guid>https://winterorch.github.io/posts/java-jvm-ram_and_gc/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/java-jvm-ram_and_gc/ -&lt;h3 id=&#34;一垃圾收集算法&#34;&gt;一、垃圾收集算法&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;下面这张图中存在 Permanent Space ，因此明显是基于 JDK 1.8 以前版本画的，在之后版本，元空间取代了永久代成为了 HotSpot 对方法区的实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/java-jvm-ram_and_gc_01.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;跟据 &lt;code&gt;Object&lt;/code&gt; 生命周期分为三个层次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Young Generation&lt;/li&gt;
&lt;li&gt;Old Generation&lt;/li&gt;
&lt;li&gt;Permanent Generation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Young Generation 包括 Eden 区和两个存活区（From 和 To），采用“停止-复制（Stop-and-copy）”清理法。大部分对象在 Eden 区域分配，一次新生代垃圾回收后如果对象还存活，则升1岁进入 &lt;code&gt;s0&lt;/code&gt; 或 &lt;code&gt;s1&lt;/code&gt; ，清理 Eden 和使用过的一块 Survivor。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证内存利用率有 90%。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Eden 区满时执行 Minor GC 清理可销毁对象，将不可销毁的迁移至其中一个存活区，而将另一个存活区直接清空，下一次 GC 时两个存活区角色交换，交换次数超过 15 （&lt;code&gt;MaxTenuringThreshold&lt;/code&gt;）的进入 Old Generation。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;复制算法（young代GC算法）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该算法会将内存区域分为两个大小一样的区域。GC回收时，遍历当前使用区域，只将正在引用的对象复制到另一个区域，因此复制成本较低，且复制过程中还会进行内存整理，不会出现“碎片”问题。缺点就是：需要两个大小一样的内存区域和生命周期短的对象。所以该算法不适合大内存对象和长生命周期的对象，适用于young代的SO/S1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Hotspot 的动态年龄阈值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hotspot遍历对象时按年龄从小到大对其所占用大小进行累积，当累积的某个年龄大小超过了 &lt;code&gt;survivor&lt;/code&gt; 区一半，取年龄与 &lt;code&gt;MaxTenuringThreshold&lt;/code&gt; 中更小的作为新年龄阈值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Old Generation 通过“标记-整理”算法，标记处仍存活对象，并将所有存活对象向一端移动以保证内存连续，清理掉剩余部分内存。当进入的对象超过剩余空间大小，则触发 Full GC。“标记-整理”好处是不需要额外内存区域。&lt;/p&gt;
&lt;p&gt;Permanent Generation 主要存放字节码、字符串常量池、静态变量、可持久化数据等。每次发生 Full GC 时，同时也会销毁 Permanent Generation 中的可销毁对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;永久代&lt;/strong&gt;实际上是HotSpot JVM对JVM方法区的实现。由于永久代内存经常不够或发生内存泄露，造成OOM(PermGen)，从JDK8开始废弃了永久代，替换为了&lt;strong&gt;本地内存&lt;/strong&gt;(native memory) 中的 Metaspace。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;元空间&lt;/strong&gt;与永久代最大区别在于它不在虚拟机中，而是使用&lt;!-- raw HTML omitted --&gt;本地内存&lt;!-- raw HTML omitted --&gt;。两者都是对JVM规范中方法区的实现，用于存储类的信息、常量池、方法数据、方法代码等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字符串常量从JDK1.7开始由永久代转移到堆中(Java heap space)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://images2015.cnblogs.com/blog/584866/201704/584866-20170426154633834-741444326.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;二经典垃圾收集器&#34;&gt;二、经典垃圾收集器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/440ec4093732dc8fe7a3092666f15a7f2c4303b97499a517562e5f868fa6c967/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63363235626161302d646465362d343439652d393364662d6333613637663266343330662e6a7067&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HotSpot 中的&lt;strong&gt;安全点&lt;/strong&gt;一般设置在方法调用、循环跳转、异常跳转等地方，只在安全点位置建立根节点枚举，强制到大安全点后才暂停，进行垃圾收集。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HotSpot 中有7个垃圾收集器，连线表示可以配合使用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;h5 id=&#34;serial&#34;&gt;&lt;strong&gt;Serial&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;串行的单线程收集器，简单高效。&lt;!-- raw HTML omitted --&gt;在 Client 场景下为默认 Young Generation 收集器&lt;!-- raw HTML omitted --&gt;，单线程收集效率高。Server 场景用于和 Parallel Scavenge 搭配使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;parnew&#34;&gt;&lt;strong&gt;ParNew&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;Serial 的多线程版本。&lt;!-- raw HTML omitted --&gt;在 Server 场景下为默认 Young Generation 收集器&lt;!-- raw HTML omitted --&gt;，可以与 CMS 配合使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;parallel-scavenge&#34;&gt;&lt;strong&gt;Parallel Scavenge&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;多线程。以“吞吐量”为优先考虑，即 CPU 运行用户代码的时间占总时间比值最高，CPU 用于垃圾回收的时间占总时间比值最低，而非其它垃圾收集器“尽可能缩短垃圾收集时用户线程的停顿时间”的目标，垃圾回收较为频繁。&lt;/p&gt;
&lt;p&gt;CPU效率更高，也适合后台运算任务，不适合对停顿和响应敏感的交互式程序。&lt;/p&gt;
&lt;p&gt;JVM中有配置以打开 GC 中新生代大小、Eden、S区自适应调节策略。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;serial-old-收集器&#34;&gt;&lt;strong&gt;Serial Old&lt;/strong&gt; 收集器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/619f88e2830cee0ebd2cc5ca6a3ecd63e7b9ab419a91537e5ed8868ef0fd34c9/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30386633326664332d663733362d346136372d383163612d3239356232613739373266322e6a7067&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。&lt;/li&gt;
&lt;li&gt;作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;parallel-old-收集器&#34;&gt;&lt;strong&gt;Parallel Old 收集器&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://camo.githubusercontent.com/224de5079435a84b00846daf60b5c0e07283cea0cd03873c511f874246d2f17d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373866653433312d616638382d346139352d613839352d3963336238303131376465332e6a7067&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;是 Parallel Scavenge 收集器的老年代版本。&lt;/p&gt;
&lt;p&gt;在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;cms&#34;&gt;&lt;strong&gt;CMS&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/06b53c4f9160093c891076bd6e65b31fccdbbe03fa7b23e754c7ba6e7835abda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/06b53c4f9160093c891076bd6e65b31fccdbbe03fa7b23e754c7ba6e7835abda/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36326537373939372d363935372d346236382d386431322d6266643630396262326336382e6a7067&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。&lt;/p&gt;
&lt;p&gt;分为以下四个流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;：仅仅只是标记一下 GC Roots 能直接关联（一级连接，不遍历）到的对象，同时遍历新生代可直达地老年对象，速度很快，需要停顿。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重新标记&lt;/strong&gt;：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发清除&lt;/strong&gt;： 清理删除掉标记阶段判断已经死亡的对象，不需要停顿。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。&lt;/p&gt;
&lt;p&gt;具有以下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;吞吐量低：对处理器资源敏感，低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。因此 CMS 适用于四核以上的处理器。&lt;/li&gt;
&lt;li&gt;无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。&lt;/li&gt;
&lt;li&gt;标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h5 id=&#34;g1&#34;&gt;&lt;strong&gt;G1&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;G1（Garbage-First），它是一款面向&lt;strong&gt;服务端应用&lt;/strong&gt;的垃圾收集器，在&lt;strong&gt;多 CPU 和大内存的场景&lt;/strong&gt;下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。&lt;/p&gt;
&lt;p&gt;堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/31d36dcfe1b2abac1d55a8dc342a117bcfe2d41c7f5a2e415f308c5735b2123e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34636637313161382d376162322d343135322d623835632d6435633232363733333830372e706e67&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/31d36dcfe1b2abac1d55a8dc342a117bcfe2d41c7f5a2e415f308c5735b2123e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34636637313161382d376162322d343135322d623835632d6435633232363733333830372e706e67&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;G1 把堆划分成多个大小相等的&lt;strong&gt;独立区域&lt;/strong&gt;（Region），新生代和老年代不再物理隔离。&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/ac21bcb938d3b10ec2be009a0d2aa6317163cf3af46106771f1bf5ca058ca544/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/ac21bcb938d3b10ec2be009a0d2aa6317163cf3af46106771f1bf5ca058ca544/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39626264646565622d653933392d343166302d386538652d3262316130616137653061372e706e67&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。&lt;/p&gt;
&lt;p&gt;每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;但是这样设计也存在副作用，region 大小固定为 1MB 到 32 MB 间的 2的幂值数，尽量能划 2048 个左右同等大小的 region 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;因为大小固定，和大对象很难保证一致，容易造成空间浪费，也很容易令大对象很难找到连续空间存放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://camo.githubusercontent.com/0f51e01c02ef3917df9a072b579a5004ae6f429dce742c32ba56d5c0de4da356/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067&#34;&gt;&lt;img src=&#34;https://camo.githubusercontent.com/0f51e01c02ef3917df9a072b579a5004ae6f429dce742c32ba56d5c0de4da356/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393965653737312d633536662d343766622d393134382d6330303336363935623566652e6a7067&#34; alt=&#34;img&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;初始标记&lt;/strong&gt;：&lt;strong&gt;短暂停顿线程&lt;/strong&gt;以标记 GC Roots 直接关联到的对象，并修改 TAMS (Next Top at Mark Start) 值，让下一并发阶段能在正确 Region 中创建新对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发标记&lt;/strong&gt;：从 GC Roots 开始对堆对象进行可达性分析，递归扫描堆中的对象图，找出存活的对象，&lt;!-- raw HTML omitted --&gt;耗时长，但可以&lt;strong&gt;并发&lt;/strong&gt;执行&lt;!-- raw HTML omitted --&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最终标记&lt;/strong&gt;：为了修正在并发标记阶段遗留的因用户程序继续运作而导致变动的标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要&lt;strong&gt;短暂停顿&lt;/strong&gt;线程，但是可并行执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;筛选回收&lt;/strong&gt;：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC &lt;strong&gt;停顿&lt;/strong&gt;时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具备如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。&lt;/li&gt;
&lt;li&gt;可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;除经典垃圾收集器外还有 Shenandoah 收集器（CAS并发）、ZGC 收集器（通过染色体指针减少GC中内存屏障的使用）等低延迟垃圾收集器，见以下博客&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/qq_31709249/article/details/106711606&#34;&gt;https://blog.csdn.net/qq_31709249/article/details/106711606&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;三内存分配与回收策略&#34;&gt;三、内存分配与回收策略&lt;/h3&gt;
&lt;p&gt;Minor GC 和 Full GC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。&lt;/li&gt;
&lt;li&gt;Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;内存分配策略&#34;&gt;内存分配策略&lt;/h4&gt;
&lt;h5 id=&#34;1-对象优先在-eden-分配&#34;&gt;1. 对象优先在 Eden 分配&lt;/h5&gt;
&lt;p&gt;大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-Xmx：&lt;/strong&gt; 最大堆大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-Xms：&lt;/strong&gt; 最小堆大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-Xmn：&lt;/strong&gt; 年轻代堆大小&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;-XXSurvivorRatio：&lt;/strong&gt; 年轻代中Eden区与Survivor区的大小比值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;2-大对象直接进入老年代&#34;&gt;2. 大对象直接进入老年代&lt;/h5&gt;
&lt;p&gt;大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。&lt;/p&gt;
&lt;p&gt;经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;3-长期存活的对象进入老年代&#34;&gt;3. 长期存活的对象进入老年代&lt;/h5&gt;
&lt;p&gt;为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-XX:MaxTenuringThreshold 用来定义对象进入老年期的年龄阈值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;4-动态对象年龄判定&#34;&gt;4. 动态对象年龄判定&lt;/h5&gt;
&lt;p&gt;虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。&lt;/p&gt;
&lt;h5 id=&#34;5-空间分配担保&#34;&gt;5. 空间分配担保&lt;/h5&gt;
&lt;p&gt;在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。&lt;/p&gt;
&lt;p&gt;如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;JDK 6 Update 24 后，如果老年代连续空间大于新生代对象总大小或历次晋升的平均大小，则直接 Minor GC，否则 Full GC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;full-gc-的触发条件&#34;&gt;Full GC 的触发条件&lt;/h4&gt;
&lt;p&gt;对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;调用 System.gc()&lt;/p&gt;
&lt;p&gt;只是建议虚拟机执行 Full GC，但是虚拟机&lt;strong&gt;不一定真正去执行&lt;/strong&gt;。&lt;strong&gt;不建议&lt;/strong&gt;使用这种方式，而是让虚拟机管理内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老年代空间不足&lt;/p&gt;
&lt;p&gt;老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。&lt;/p&gt;
&lt;p&gt;为了避免以上原因引起的 Full GC，&lt;!-- raw HTML omitted --&gt;应当尽量不要创建过大的对象以及数组&lt;!-- raw HTML omitted --&gt;。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空间分配担保失败&lt;/p&gt;
&lt;p&gt;使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK 1.7 及以前的永久代空间不足&lt;/p&gt;
&lt;p&gt;在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。&lt;/p&gt;
&lt;p&gt;当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。&lt;/p&gt;
&lt;p&gt;为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Concurrent Mode Failure&lt;/p&gt;
&lt;p&gt;执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;四可销毁对象&#34;&gt;四、可销毁对象&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Java 虚拟机不使用引用计数算法，因为两个对象如果循环引用，则引用计数器永远无法为 0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;可达性分析&#34;&gt;可达性分析&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://winterorch.github.io/images/blog/java-jvm-ram_and_gc_02.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;根搜索方法，将所有 Java 对象构成“搜索树”结构，有一个根节点 &lt;code&gt;root&lt;/code&gt;，每次从根节点触发进行搜索，遍历完后，不存在的变量成为可销毁对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;root&lt;/code&gt; 包括所有正在运行线程栈上的引用变量、所有全局变量、所有 &lt;code&gt;ClassLoader&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&#34;类的卸载&#34;&gt;类的卸载&lt;/h4&gt;
&lt;p&gt;类卸载必须满足很多条件，最基本的有：所有实例都被回收；&lt;code&gt;ClassLoader&lt;/code&gt;已被回收；对应的&lt;code&gt;Class&lt;/code&gt;对象没有在任何地方被引用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;8u40 以后 G1 增加并默认开启 &lt;code&gt;ClassUnloadingWithConcurrentMark&lt;/code&gt; ，在并发标记阶段结束后，JVM 直接进行类卸载。&lt;/p&gt;
&lt;/blockquote&gt;
- https://winterorch.github.io/posts/java-jvm-ram_and_gc/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
    
        <item>
        <title>中文文本测试</title>
        <link>https://winterorch.github.io/posts/chinese/</link>
        <pubDate>Thu, 14 Nov 2019 11:25:05 -0400</pubDate>
        
        <guid>https://winterorch.github.io/posts/chinese/</guid>
        <description>图拉国营噄茶馆 https://winterorch.github.io/posts/chinese/ -&lt;p&gt;　　这样看来， 邓拓在不经意间这样说过，越是没有本领的就越加自命不凡。这不禁令我深思。 我们不得不面对一个非常尴尬的事实，那就是， 一般来说， 所谓中午吃什么，关键是中午吃什么需要如何写。 伏尔泰说过一句富有哲理的话，坚持意志伟大的事业需要始终不渝的精神。这启发了我， 那么， 对我个人而言，中午吃什么不仅仅是一个重大的事件，还可能会改变我的人生。 这样看来， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 一般来讲，我们都必须务必慎重的考虑考虑。 黑格尔说过一句富有哲理的话，只有永远躺在泥坑里的人，才不会再掉进坑里。这启发了我， 我们不得不面对一个非常尴尬的事实，那就是， 既然如何， 在这种困难的抉择下，本人思来想去，寝食难安。&lt;/p&gt;
&lt;p&gt;　　我认为， 而这些并不是完全重要，更加重要的问题是， 了解清楚中午吃什么到底是一种怎么样的存在，是解决一切问题的关键。 中午吃什么因何而发生？ 而这些并不是完全重要，更加重要的问题是， 卢梭在不经意间这样说过，浪费时间是一桩大罪过。这启发了我， 既然如此， 从这个角度来看， 歌德在不经意间这样说过，意志坚强的人能把世界放在手中像泥块一样任意揉捏。我希望诸位也能好好地体会这句话。 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 莎士比亚在不经意间这样说过，人的一生是短的，但如果卑劣地过这一生，就太长了。带着这句话，我们还要更加慎重的审视这个问题： 带着这些问题，我们来审视一下中午吃什么。 中午吃什么因何而发生？ 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 布尔沃曾经说过，要掌握书，莫被书掌握；要为生而读，莫为读而生。这似乎解答了我的疑惑。 而这些并不是完全重要，更加重要的问题是， 生活中，若中午吃什么出现了，我们就不得不考虑它出现了的事实。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 带着这些问题，我们来审视一下中午吃什么。 生活中，若中午吃什么出现了，我们就不得不考虑它出现了的事实。 我认为， 一般来说， 中午吃什么，到底应该如何实现。 我们不得不面对一个非常尴尬的事实，那就是， 所谓中午吃什么，关键是中午吃什么需要如何写。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 现在，解决中午吃什么的问题，是非常非常重要的。&lt;/p&gt;
&lt;p&gt;　　我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 可是，即使是这样，中午吃什么的出现仍然代表了一定的意义。 带着这些问题，我们来审视一下中午吃什么。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我认为， 问题的关键究竟为何？ 非洲曾经提到过，最灵繁的人也看不见自己的背脊。这启发了我， 易卜生说过一句富有哲理的话，伟大的事业，需要决心，能力，组织和责任感。这似乎解答了我的疑惑。 一般来说， 在这种困难的抉择下，本人思来想去，寝食难安。 中午吃什么，到底应该如何实现。 经过上述讨论， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 中午吃什么因何而发生？ 
带着这些问题，我们来审视一下中午吃什么。 对我个人而言，中午吃什么不仅仅是一个重大的事件，还可能会改变我的人生。&lt;/p&gt;
- https://winterorch.github.io/posts/chinese/ - WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</description>
        </item>
    
    
  </channel>
</rss> 