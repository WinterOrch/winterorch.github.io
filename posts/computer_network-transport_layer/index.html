<!DOCTYPE html>
<html><head>
<title>计算机网络 传输层</title>




<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="description" content="传输层提供进程间逻辑通信，向高层屏蔽网络层细节，在两个传输层实体之间建立端到端的逻辑信道">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">



<meta property="og:title" content="计算机网络 传输层" />
<meta property="og:description" content="传输层提供进程间逻辑通信，向高层屏蔽网络层细节，在两个传输层实体之间建立端到端的逻辑信道" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://winterorch.github.io/posts/computer_network-transport_layer/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-02T09:14:28&#43;06:30" />
<meta property="article:modified_time" content="2021-06-02T09:14:28&#43;06:30" /><meta property="og:site_name" content="My Blog" />






<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机网络 传输层"/>
<meta name="twitter:description" content="传输层提供进程间逻辑通信，向高层屏蔽网络层细节，在两个传输层实体之间建立端到端的逻辑信道"/>







<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>


  






<link rel="stylesheet" href="https://winterorch.github.io/scss/journal.min.d4108c26a8f8dd3abc1cba5d3bd8b9d4b834ea3c0710b78fa3010b8942ce9d9b.css" integrity="sha256-1BCMJqj43Tq8HLpdO9i51Lg06jwHELePowELiULOnZs=" media="screen">



<link rel="stylesheet" href="https://winterorch.github.io/scss/dark-mode.min.eb84b98ab2384f8334bfcaa9ab8f0a2dec872fe34abf8cd2bb451663742c8349.css" integrity="sha256-64S5irI4T4M0v8qpq48KLeyHL&#43;NKv4zSu0UWY3Qsg0k=" media="screen">


<script src="/js/loadCSS.js"></script>
<script>
  loadCSS("https://fonts.googleapis.com/css?family=Fira+Mono|Material+Icons");
</script>




  
    <script src="/js/toc.js"></script>
  















<script>console.log("Hello from 'layouts/partials/extended_head.html'")</script>

</head>
<body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://winterorch.github.io">
    
        <div class="nav-title">
            图拉国营噄茶馆
        </div>
        
        <div class="nav-subtitle">
            WinterOrch&#39;s Blog
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
            
            
                
            
            
            
            <a class="a-block nav-link-item active" href="/posts">
                归档
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/categories">
                分类
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/tags">
                标签
            </a>
            
        
            
            
            
            
            
            <a class="a-block nav-link-item false" href="/index.xml">
                RSS
            </a>
            
        
    </div>

    

    <div class="nav-footer">
        
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://amazingrise.net">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	WinterOrch. 本站遵循 CC-BY-NC 4.0 协议
	

    </div>
    
</div><div ref="extraContainer" class="extra-container">
    
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- 目录 -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#tcp-%e4%b8%8e-udp-%e5%8d%8f%e8%ae%ae%e5%8c%ba%e5%88%ab" onclick="onNavClick(`#tcp-与-udp-协议区别-nav`)" id="tcp-与-udp-协议区别-nav">
									TCP 与 UDP 协议区别
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#tcptransmission-control-protocol" onclick="onNavClick(`#tcptransmission-control-protocol-nav`)" id="tcptransmission-control-protocol-nav">
									TCP（Transmission Control Protocol）
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e4%b8%80tcp-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%92%8c%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" onclick="onNavClick(`#一tcp-三次握手和四次挥手-nav`)" id="一tcp-三次握手和四次挥手-nav">
									一、TCP 三次握手和四次挥手
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#11-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" onclick="onNavClick(`#11-三次握手-nav`)" id="11-三次握手-nav">
									1.1 三次握手
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#12-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" onclick="onNavClick(`#12-四次挥手-nav`)" id="12-四次挥手-nav">
									1.2 四次挥手
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e4%ba%8ctcp-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93" onclick="onNavClick(`#二tcp-如何保证可靠传输-nav`)" id="二tcp-如何保证可靠传输-nav">
									二、TCP 如何保证可靠传输
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#21-arq" onclick="onNavClick(`#21-arq-nav`)" id="21-arq-nav">
									2.1 ARQ
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#22-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e5%92%8c%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" onclick="onNavClick(`#22-滑动窗口和流量控制-nav`)" id="22-滑动窗口和流量控制-nav">
									2.2 滑动窗口和流量控制
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#23-%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" onclick="onNavClick(`#23-拥塞控制-nav`)" id="23-拥塞控制-nav">
									2.3 拥塞控制
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#udpuser-datagram-protocol" onclick="onNavClick(`#udpuser-datagram-protocol-nav`)" id="udpuser-datagram-protocol-nav">
									UDP（User Datagram Protocol）
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
        <a class="pagination-action" v-on:click="toggleDarkMode">
            <i class="material-icons pagination-action-icon" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons pagination-action-icon" v-else="isDarkMode">
                brightness_7
            </i>
        </a>
        
        
    </div>
</div>
<div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
            
                
                
                
                    
                
                
                
                <a class="a-block drawer-menu-item active" href="/posts">
                    归档
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/categories">
                    分类
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/tags">
                    标签
                </a>
                
            
                
                
                
                
                
                <a class="a-block drawer-menu-item false" href="/index.xml">
                    RSS
                </a>
                
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- 目录 -</center>
		
		
		<ul>
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#tcp-%e4%b8%8e-udp-%e5%8d%8f%e8%ae%ae%e5%8c%ba%e5%88%ab" onclick="onNavClick(`#tcp-与-udp-协议区别-nav`)" id="tcp-与-udp-协议区别-nav">
									TCP 与 UDP 协议区别
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#tcptransmission-control-protocol" onclick="onNavClick(`#tcptransmission-control-protocol-nav`)" id="tcptransmission-control-protocol-nav">
									TCP（Transmission Control Protocol）
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#%e4%b8%80tcp-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%92%8c%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" onclick="onNavClick(`#一tcp-三次握手和四次挥手-nav`)" id="一tcp-三次握手和四次挥手-nav">
									一、TCP 三次握手和四次挥手
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#11-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" onclick="onNavClick(`#11-三次握手-nav`)" id="11-三次握手-nav">
									1.1 三次握手
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#12-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" onclick="onNavClick(`#12-四次挥手-nav`)" id="12-四次挥手-nav">
									1.2 四次挥手
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
						
						
						
							<li>
								<a href="#%e4%ba%8ctcp-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93" onclick="onNavClick(`#二tcp-如何保证可靠传输-nav`)" id="二tcp-如何保证可靠传输-nav">
									二、TCP 如何保证可靠传输
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
							
								
									<ul>
								
							
						
						
							<li>
								<a href="#21-arq" onclick="onNavClick(`#21-arq-nav`)" id="21-arq-nav">
									2.1 ARQ
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#22-%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3%e5%92%8c%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" onclick="onNavClick(`#22-滑动窗口和流量控制-nav`)" id="22-滑动窗口和流量控制-nav">
									2.2 滑动窗口和流量控制
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
						
						
							<li>
								<a href="#23-%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6" onclick="onNavClick(`#23-拥塞控制-nav`)" id="23-拥塞控制-nav">
									2.3 拥塞控制
								</a>
							</li>
						
						
					
				
			
				
				
					
						
						
						
							
								</ul>
							
								</ul>
							
						
						
						
							<li>
								<a href="#udpuser-datagram-protocol" onclick="onNavClick(`#udpuser-datagram-protocol-nav`)" id="udpuser-datagram-protocol-nav">
									UDP（User Datagram Protocol）
								</a>
							</li>
						
						
					
				
			
		</ul>
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="https://winterorch.github.io">
            图拉国营噄茶馆
        </a>
        
        <button type="button" class="nav-darkmode-toggle" v-on:click="toggleDarkMode">
            <i class="material-icons" v-if="isDarkMode">
                brightness_4
            </i>
            <i class="material-icons" v-else="isDarkMode">
                brightness_7
            </i>
        </button>
        
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://winterorch.github.io">
        <div class="single-column-header-title">图拉国营噄茶馆</div>
        
        <div class="single-column-header-subtitle">WinterOrch&#39;s Blog</div>
        

    </a>
</div>

            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            
                
            

            <div class="post-head-wrapper"
                
                    
                    
                    style="background-image: url('https://winterorch.github.io/images/feature/abyss/09.jpg')"
                    
                
            >
                <div class="post-title">
                    计算机网络 传输层
                    
                    <div class="post-subtitle">
                        传输层提供进程间逻辑通信，向高层屏蔽网络层细节，在两个传输层实体之间建立端到端的逻辑信道
                    </div>
                    
                    <div class="post-meta">
                        
                        <time itemprop="datePublished">
                            2021-06-02 09:14
                        </time>
                        

                        
                            <i class="material-icons" style="">folder</i>
                                <a href="/categories/%E8%AE%A1%E7%BD%91">计网</a>
                                &nbsp;
                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/computer-network">Computer Network</a>
                                &nbsp;
                            
                        
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                
                <div class="post-body" v-pre>
                
                    <p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p>
<hr>
<h2 id="tcp-与-udp-协议区别">TCP 与 UDP 协议区别</h2>
<table>
<thead>
<tr>
<th></th>
<th>连接</th>
<th>传输可靠性</th>
<th>传输形式</th>
<th>传输效率</th>
<th>所需资源</th>
<th>应用场景</th>
<th>首部字节</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TCP</strong></td>
<td>面向连接</td>
<td>可靠</td>
<td>字节流</td>
<td>低</td>
<td>多</td>
<td>要求数据可靠性</td>
<td>20 - 60</td>
</tr>
<tr>
<td><strong>UDP</strong></td>
<td>无连接</td>
<td>不可靠</td>
<td>数据报文段</td>
<td>高</td>
<td>少</td>
<td>要求通信效率</td>
<td>8</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="tcptransmission-control-protocol">TCP（Transmission Control Protocol）</h2>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<p><img src="/images/blog/computer_network-transport_layer_01.jpg" alt=""></p>
<ul>
<li>
<p><strong>序号</strong>   ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</p>
</li>
<li>
<p><strong>确认号</strong>   ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</p>
</li>
<li>
<p><strong>数据偏移</strong>   ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p>
</li>
<li>
<p><strong>确认 ACK</strong>   ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</p>
</li>
<li>
<p><strong>同步 SYN</strong>   ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</p>
</li>
<li>
<p><strong>终止 FIN</strong>   ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</p>
</li>
<li>
<p><strong>窗口</strong>   ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</p>
</li>
</ul>
<h3 id="一tcp-三次握手和四次挥手">一、TCP 三次握手和四次挥手</h3>
<p>可靠，TCP 协议的设计都是为了可靠无误</p>
<h4 id="11-三次握手">1.1 三次握手</h4>
<p><a href="https://camo.githubusercontent.com/984872f6f3fd869be7b447fa70ace6b992fa9b599d8352b810a2d4893acb901c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67"><img src="https://camo.githubusercontent.com/984872f6f3fd869be7b447fa70ace6b992fa9b599d8352b810a2d4893acb901c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392f372f254534254238253839254536254143254131254536253846254131254536253839253842322e706e67" alt="TCP三次握手"></a></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<p>为什么这么设计，可以从三次握手后双方获得的信息入手，对于发送方而言：</p>
<table>
<thead>
<tr>
<th></th>
<th>自己发送正常</th>
<th>自己接收正常</th>
<th>对方发送正常</th>
<th>对方接收正常</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一次</td>
<td>未知</td>
<td>未知</td>
<td>未知</td>
<td>未知</td>
</tr>
<tr>
<td>第二次</td>
<td>确认</td>
<td>确认</td>
<td>确认</td>
<td>确认</td>
</tr>
<tr>
<td>第三次</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>对于接收方而言：</p>
<table>
<thead>
<tr>
<th></th>
<th>自己发送正常</th>
<th>自己接收正常</th>
<th>对方发送正常</th>
<th>对方接收正常</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一次</td>
<td>未知</td>
<td>确认</td>
<td>确认</td>
<td>未知</td>
</tr>
<tr>
<td>第二次</td>
<td>未知</td>
<td>-</td>
<td>-</td>
<td>未知</td>
</tr>
<tr>
<td>第三次</td>
<td>确认</td>
<td>确认</td>
<td>确认</td>
<td>确认</td>
</tr>
</tbody>
</table>
<p>要接收双方都能完整确认双方接收功能正常，三次握手缺一不可。</p>
<blockquote>
<p><strong>第2次握手传回了ACK，为什么还要传回SYN？</strong></p>
<p>接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”</p>
</blockquote>
<blockquote>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
</blockquote>
<h4 id="12-四次挥手">1.2 四次挥手</h4>
<p><img src="/images/blog/computer_network-transport_layer_02.jpg" alt=""></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>
<p>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</p>
<blockquote>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态</p>
</blockquote>
</li>
<li>
<p>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</p>
</li>
<li>
<p>服务器-关闭与客户端的连接，发送一个FIN给客户端</p>
<blockquote>
<p><strong>TIME_WAIT</strong></p>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p>
<ul>
<li>
<p>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li>
<p>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>传达信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>A: FIN</td>
<td>A：我没有数据要传了</td>
</tr>
<tr>
<td>B：ack</td>
<td>B：我知道你没数据要传了</td>
</tr>
<tr>
<td>B：FIN</td>
<td>B：我没有数据要传了</td>
</tr>
<tr>
<td>A：ack</td>
<td>A：我知道你没数据要传了</td>
</tr>
</tbody>
</table>
<h3 id="二tcp-如何保证可靠传输">二、TCP 如何保证可靠传输</h3>
<ol>
<li>**分块：**应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>**有序：**TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>**去重：**TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ协议：</strong> 通过确认和超时机制实现可靠信息传输。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h4 id="21-arq">2.1 ARQ</h4>
<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p>
<h5 id="停止等待arq协议"><strong>停止等待ARQ协议</strong></h5>
<p>每发完一个分组就停止发送，等待对方确认（回复ACK）。如果超时还没有收到 ACK 确认，需要重新发送，直到收到确认后再发下一个分组。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
<h5 id="连续arq协议"><strong>连续ARQ协议</strong></h5>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
<h4 id="22-滑动窗口和流量控制">2.2 滑动窗口和流量控制</h4>
<p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p>
<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h4 id="23-拥塞控制">2.3 拥塞控制</h4>
<p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。</p>
<blockquote>
<p>TCP 窗口基于<strong>字节</strong>，但这里拥塞窗口的大小单位是<strong>报文段</strong>。</p>
</blockquote>
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<blockquote>
<p>当然，谈论拥塞控制的前提是不会发生流量控制，即接收方有足够大的接收缓存。</p>
</blockquote>
<p><img src="/images/blog/computer_network-transport_layer_03.jpg" alt=""></p>
<ul>
<li>
<p><strong>慢开始：</strong> 为防止立即注入大量数据导致拥塞，先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。<code>cwnd</code> 初始值为 1，每经过一个传播轮次，<code>cwnd</code> 加倍。</p>
<blockquote>
<p>如果在慢开始阶段出现超时，将令 <code>ssthresh = cwnd / 2</code> 并重新执行慢开始</p>
</blockquote>
</li>
<li>
<p><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 <code>cwnd</code> 缓慢增大，即每经过一个往返时间RTT就把发送方的 <code>cwnd</code> 加 1。</p>
</li>
<li>
<p><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定下一个报文段丢失，立即重传丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。</p>
<p>例如收到三个 M<!-- raw HTML omitted -->2<!-- raw HTML omitted -->，则 M<!-- raw HTML omitted -->3<!-- raw HTML omitted --> 丢失，立即重传 M<!-- raw HTML omitted -->3<!-- raw HTML omitted -->。</p>
<blockquote>
<p>这种情况下，丢失个别报文段不认作网络拥塞，因此执行快恢复，令 <code>ssthresh = cwnd / 2</code> ，<code>cwnd = ssthresh</code> ，此时<!-- raw HTML omitted -->直接进入拥塞避免<!-- raw HTML omitted -->。</p>
</blockquote>
<p>当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
</li>
</ul>
<blockquote>
<p>慢开始和快恢复的快慢，指的是 <code>cwnd</code> 的起始值而非增长速率。慢开始 <code>cwnd</code> 设定为 1，而快恢复 <code>cwnd</code> 设定为 <code>ssthresh</code>。</p>
</blockquote>
<hr>
<h2 id="udpuser-datagram-protocol">UDP（User Datagram Protocol）</h2>
<p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</p>
<p><img src="/images/blog/computer_network-transport_layer_04.jpg" alt=""></p>
<p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p>

                    
                    <HR width="100%" id="EOF">
		    <p style="color:#777;">最后修改于 2021-06-02</p>
                    
                </div>
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts">
			下回<br>已经到头啦。
                </a>
                
                
                
                <a class="older-posts" href="https://winterorch.github.io/posts/computer_network-application_layer/">
			上回<br>计算机网络 应用层
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                










            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer">
Hugo Theme <a href="https://github.com/amazingrise/hugo-theme-diary">Diary</a> by <a href="https://amazingrise.net">Rise</a>
<br>
移植自 <a href="https://mak1t0.cc/" target="_blank" rel="noreferrer noopener">Makito</a>'s <a href="https://github.com/SumiMakito/hexo-theme-journal/" target="_blank" rel="noreferrer noopener">Journal.</a> <br>
<br>

&copy;
	
	WinterOrch. 本站遵循 CC-BY-NC 4.0 协议
	
</div>
            </div>
    <script>
let app;

app = new Vue({
    el: '#app',
    data: {
        scrollY: 0,
        navOpacity: 0,
        isDrawerOpen: false,
        mounted: false,
        isDarkMode: false
    },
    methods: {
            sgn(t, x) {
                let k = 1. / (1. - 2 * t);
                if (x <= t) return 0;
                else if (x >= 1 - t) return 1;
                else {
                    return k * (x - t);
                }
            },
            handleScroll() {
                this.scrollY = window.scrollY;
                this.navOpacity = this.sgn(.0, Math.min(1, Math.max(0, window.scrollY / (this.pageHeadHeight() - this.navBarHeight() * 0.8))));
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;

                if (this.navOpacity >= 1) {
                    navBackground.style.opacity = 1;
                    navTitle.style.opacity = 1;
                } else {
                    navBackground.style.opacity = 0;
                    navTitle.style.opacity = 0;
                }
            },
            handleResize() {
                const {navBar, navBackground, navTitle, extraContainer, streamContainer} = this.$refs;
                extraContainer.style.left = (streamContainer.offsetWidth - extraContainer.offsetWidth) + 'px';
            },
            navBarHeight() {
                return this.$refs.navBar.offsetHeight;
            },
            pageHeadHeight() {
                return this.$refs.pageHead.offsetHeight;
            },
            toggleDrawer() {
                this.isDrawerOpen = !this.isDrawerOpen;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            closeDrawer() {
                this.isDrawerOpen = false;
                document.getElementsByTagName('html')[0].style.overflow = this.isDrawerOpen ? 'hidden' : 'unset';
            },
            toggleDarkMode() {
                this.isDarkMode = !this.isDarkMode;
                if (this.isDarkMode==true){
                    document.cookie = "night=1;path=/";
                    document.body.classList.add("night");
                } else {
                    document.cookie = "night=0;path=/";
                    document.body.classList.remove("night");
                }
            },
            debounce(func, wait, options) {
                let lastArgs,
                    lastThis,
                    maxWait,
                    result,
                    timerId,
                    lastCallTime

                let lastInvokeTime = 0
                let leading = false
                let maxing = false
                let trailing = true

                
                const useRAF = (!wait && wait !== 0 && typeof root.requestAnimationFrame === 'function')

                if (typeof func !== 'function') {
                    throw new TypeError('Expected a function')
                }
                function isObject(value) {
                    const type = typeof value
                    return value != null && (type === 'object' || type === 'function')
                }

                wait = +wait || 0
                if (isObject(options)) {
                    leading = !!options.leading
                    maxing = 'maxWait' in options
                    maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait
                    trailing = 'trailing' in options ? !!options.trailing : trailing
                }

                function invokeFunc(time) {
                    const args = lastArgs
                    const thisArg = lastThis

                    lastArgs = lastThis = undefined
                    lastInvokeTime = time
                    result = func.apply(thisArg, args)
                    return result
                }

                function startTimer(pendingFunc, wait) {
                    if (useRAF) {
                    root.cancelAnimationFrame(timerId)
                    return root.requestAnimationFrame(pendingFunc)
                    }
                    return setTimeout(pendingFunc, wait)
                }

                function cancelTimer(id) {
                    if (useRAF) {
                    return root.cancelAnimationFrame(id)
                    }
                    clearTimeout(id)
                }

                function leadingEdge(time) {
                    
                    lastInvokeTime = time
                    
                    timerId = startTimer(timerExpired, wait)
                    
                    return leading ? invokeFunc(time) : result
                }

                function remainingWait(time) {
                    const timeSinceLastCall = time - lastCallTime
                    const timeSinceLastInvoke = time - lastInvokeTime
                    const timeWaiting = wait - timeSinceLastCall

                    return maxing
                    ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)
                    : timeWaiting
                }

                function shouldInvoke(time) {
                    const timeSinceLastCall = time - lastCallTime
                    const timeSinceLastInvoke = time - lastInvokeTime

                    
                    
                    
                    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait))
                }

                function timerExpired() {
                    const time = Date.now()
                    if (shouldInvoke(time)) {
                    return trailingEdge(time)
                    }
                    
                    timerId = startTimer(timerExpired, remainingWait(time))
                }

                function trailingEdge(time) {
                    timerId = undefined

                    
                    
                    if (trailing && lastArgs) {
                    return invokeFunc(time)
                    }
                    lastArgs = lastThis = undefined
                    return result
                }

                function cancel() {
                    if (timerId !== undefined) {
                    cancelTimer(timerId)
                    }
                    lastInvokeTime = 0
                    lastArgs = lastCallTime = lastThis = timerId = undefined
                }

                function flush() {
                    return timerId === undefined ? result : trailingEdge(Date.now())
                }

                function pending() {
                    return timerId !== undefined
                }

                function debounced(...args) {
                    const time = Date.now()
                    const isInvoking = shouldInvoke(time)

                    lastArgs = args
                    lastThis = this
                    lastCallTime = time

                    if (isInvoking) {
                    if (timerId === undefined) {
                        return leadingEdge(lastCallTime)
                    }
                    if (maxing) {
                        
                        timerId = startTimer(timerExpired, wait)
                        return invokeFunc(lastCallTime)
                    }
                    }
                    if (timerId === undefined) {
                    timerId = startTimer(timerExpired, wait)
                    }
                    return result
                }
                debounced.cancel = cancel
                debounced.flush = flush
                debounced.pending = pending
                return debounced
                }

    },
    created() {
        window.addEventListener('scroll', this.handleScroll);
        window.addEventListener('resize', this.handleResize);
        window._nonDesktop = function () {
            let check = false;
            (function (a) {
                if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
            })(navigator.userAgent || navigator.vendor || window.opera);
            return check;
        };
        
        var night = document.cookie.replace(/(?:(?:^|.*;\s*)night\s*\=\s*([^;]*).*$)|^.*$/, "$1");
        if (night==""){
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                
            }
        }else{
            
            if (night=="1") {
                this.toggleDarkMode();
            }
        }
    },
    mounted() {
        this.handleScroll();
        this.handleResize();
        this.mounted = true;

        
        
        

        document.querySelectorAll("table").forEach(function(elem){
            elem.classList.add("table-striped");
            elem.classList.add("table");
            elem.classList.add("table-responsive");
            elem.classList.add("table-hover");
        })

        
        spy();
        window.addEventListener('scroll', this.debounce(spy, 250, { 'maxWait': 250 }), false);
        
        
    },
    destroyed() {
        window.removeEventListener('scroll', this.handleScroll);
        window.removeEventListener('resize', this.handleResize);
    }
});



</script>
    </body>
</html>
