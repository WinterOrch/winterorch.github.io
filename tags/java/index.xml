<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 图拉国营噄茶馆</title>
    <link>https://winterorch.github.io/tags/java/</link>
    <description>Recent content in Java on 图拉国营噄茶馆</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>WinterOrch. 本站遵循 CC-BY-NC 4.0 协议</copyright>
    <lastBuildDate>Thu, 24 Jun 2021 19:03:58 +0530</lastBuildDate><atom:link href="https://winterorch.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Spring 依赖注入注解的区分</title>
      <link>https://winterorch.github.io/posts/java-spring-annotation-di_methods/</link>
      <pubDate>Thu, 24 Jun 2021 19:03:58 +0530</pubDate>
      
      <guid>https://winterorch.github.io/posts/java-spring-annotation-di_methods/</guid>
      <description>Spring 支持的依赖注入有 @Autowired @Resource @Inject 三种
@Autowired 来自 org.springframwork.beans.factory.annotation.Autowired ，装配顺序为：
 按 type 在上下文中查找匹配的 bean 如果有多个 bean，则按照 name 进行匹配  如有 @Qualifier ，则按指定的 name 进行匹配 如没有，则按变量名进行匹配   匹配不到就报错  @Autowired(required=false) 则注入失败不抛异常
@Inject Spring 环境下和 @Autowired 相同，都依赖 AutowiredAnnotationBeanPostProcess 进行处理，但不能 (required=false)。@Inject 由 JSR-330 定义，可以切换到谷歌的 DI 框架——Guice。
@Inject 在 Java EE 包内，SE 环境需要单独引入。
@Resource JSR-250 定义。在 CommonAnnotationBeanPostProcessor 实现处理。同样有 name 和 type。装配顺序：
 如同时指定 name 和 type ，从上下文找到唯一匹配 bean 进行装配，找不到抛异常 如指定 name ，则到上下文找 id 匹配的 bean 进行装配，找不到抛异常 如指定 type ，则到上下文找类型匹配的唯一 bean 进行装配，找不到或找到不唯一都会抛异常 如果都没有指定，则默认按 byName 方式装配，找不到再按 byType 进行装配   IDEA 使用 @Autowired 时很常见警告 Field injection is not recommended。</description>
    </item>
    
    <item>
      <title>Spring下常用注释.</title>
      <link>https://winterorch.github.io/posts/java-spring-annotation-collection/</link>
      <pubDate>Wed, 16 Jun 2021 14:25:05 -0400</pubDate>
      
      <guid>https://winterorch.github.io/posts/java-spring-annotation-collection/</guid>
      <description>首先，在 Spring 4.X 之后（不用 Spring Boot 的话）使用注释需要添加 aop 依赖。虽然不需要这么做了，还是有助于了解 Spring Boot 到底为我们做了什么。
&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-aop --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-aop&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;{springframework.version}&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 而且需要在 XML 中添加约束并在 context 中配置扫描范围。
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;context:annotation-config/&amp;gt; &amp;lt;/beans&amp;gt; 配置扫描范围
&amp;lt;!--指定注解扫描包--&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.yourpackage&amp;#34;/&amp;gt; 接下来按类别整理一些最常用的注释。
Bean 的扫描   @ComponentScan
   @ComponentScan：通过注释方式配置扫描范围，将其下的 @Component 组件（包括@Controller、@Service、@Repository）纳入 IOC 容器. 只能作用于配置类，且 Spring Boot 的入口类不能被纳入到扫描范围中.
 Spring Boot 默认的扫描范围是启动类所在包开始，当前包及子包下的所有文件
 @Configuration @ComponentScan(&amp;#34;cc.mrbird.demo&amp;#34;) public class WebConfig { }  可以通过 excludeFilters 来排除一些组件的扫描，通过 @Filter 注释完成</description>
    </item>
    
    <item>
      <title>接口与抽象类的区别</title>
      <link>https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/</link>
      <pubDate>Wed, 02 Jun 2021 20:04:58 +0130</pubDate>
      
      <guid>https://winterorch.github.io/posts/java-oop-polymorphism-interface_and_abstract/</guid>
      <description>先简单过一下接口语法中的注意点。
注意点   接口中的变量隐式指定为 public static final
  接口中的方法会被隐式指定为 public abstract （JDK 1.9 后允许 private，其它修饰符会报错）
 这也决定了接口中所有方法都必须被实现，当然这一要求有两种特殊的满足方式——抽象类实现接口，那么接口方法不一定要实现，可以由抽象类的子类实现；JDK 1.8 后有默认实现的接口方法也不必被实现类显式实现。
   接口不能有构造方法
  JDK 1.8 后，接口可以有静态方法和方法体
  JDK 1.8 后，接口方法可以有默认方法，用 default 关键字修饰
  与抽象类语法上的区别   一个类可以实现多个接口
  一个接口可以继承多个其它接口
Java 接口是对行为的抽象，一个行为本身可以看作多个行为的耦合
public interface Hockey extends Sports, Event    接口与抽象类区别 接口和抽象类语法上的不同在之前两个文档中都已经接释清楚了，这里主要看两者思想上的不同。
摘取一些《Effective Java》中的说法
 接口是对行为的抽象，达到 API 定义与实现分类 的目的，因此支持多实现。甚至可以用没有任何方法的接口，作为 Marker Interface，目的仅仅是进行声明。但是用接口导出常量是不合适的使用，接口应当尽量减少细节泄露，常量应当由类保管。
相较之下，抽象类的主要目的是 代码重用，本质是不能实例化的类。</description>
    </item>
    
    <item>
      <title>Java 抽象类</title>
      <link>https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/</link>
      <pubDate>Sun, 30 May 2021 20:01:58 +0530</pubDate>
      
      <guid>https://winterorch.github.io/posts/java-oop-polymorphism-abstract_class/</guid>
      <description>语法 抽象类中可以存在
 构造方法 抽象方法 非抽象方法 成员变量 静态成员变量  总结：除了不能被实例化，抽象类几乎具有普通类的所有特性。
 注意点   抽象类不能被实例化，如果试图实例化抽象类，编译无法通过
  抽象类中可以有构造方法，但是构造方法不能为抽象方法，其中原因见 [为什么构造函数不能为抽象]
 抽象类及其实现的构造方法也必须遵循一般继承中的构造方法规范，包括：
 子类实例化对象时，如果子类构造方法没有显式调用父类构造方法，默认调用 super() 子类要使用父类有参构造方法，使用 super(...) 形式，且 super() 必须是子类构造方法中第一行语句 父类没有不带参构造方法（只定义了有参构造方法而没有定义无参的），子类构造方法中必须显示调用父类其它构造方法，否则编译不过     抽象类中的静态方法也不能为抽象方法
  抽象类中的抽象方法只能声明，不能有具体实现，这与接口不同（接口方法在 JDK 1.8 后也可以有默认实现），具体原因见 [为什么抽象方法不能有实现而接口方法可以]
   有端联想 抽象类总结了几个比较有嚼劲的问题
1. 为什么构造函数不能为抽象 Java 抽象函数 和 C++ 虚函数 是等价概念，因此这里直接从 C++ 的角度找答案了。结论就是——构造函数从语言和逻辑来看都不能为虚函数。
  从内存结构角度来看
虚函数对应虚函数表 vtable ，表为类所有，但虚函数表指针为每个对象所有，在构造函数运行时进行空间分配，因此构造函数无法在未创建虚表指针的情况下调用虚表。
  从语言逻辑角度来看
构造函数目的是初始化实例，我们知道抽象类和虚基类都没有实例化的需求，将构造函数定义为虚函数是没有意义的。
可以先回顾一下虚函数的作用过程——通过指针或者引用来调用虚函数的时候能够调用到子类的对应成员函数。而构造函数是在创建对象时自动调用的，调用这一函数的指针或引用所对应的对象还不存在，也就决定了构造函数不能是虚函数。
  2.</description>
    </item>
    
    <item>
      <title>JVM GC</title>
      <link>https://winterorch.github.io/posts/java-jvm-ram_and_gc/</link>
      <pubDate>Wed, 17 Mar 2021 22:03:58 +0630</pubDate>
      
      <guid>https://winterorch.github.io/posts/java-jvm-ram_and_gc/</guid>
      <description>一、垃圾收集算法  下面这张图中存在 Permanent Space ，因此明显是基于 JDK 1.8 以前版本画的，在之后版本，元空间取代了永久代成为了 HotSpot 对方法区的实现
 跟据 Object 生命周期分为三个层次
 Young Generation Old Generation Permanent Generation  Young Generation 包括 Eden 区和两个存活区（From 和 To），采用“停止-复制（Stop-and-copy）”清理法。大部分对象在 Eden 区域分配，一次新生代垃圾回收后如果对象还存活，则升1岁进入 s0 或 s1 ，清理 Eden 和使用过的一块 Survivor。
 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证内存利用率有 90%。
 Eden 区满时执行 Minor GC 清理可销毁对象，将不可销毁的迁移至其中一个存活区，而将另一个存活区直接清空，下一次 GC 时两个存活区角色交换，交换次数超过 15 （MaxTenuringThreshold）的进入 Old Generation。
 复制算法（young代GC算法）
该算法会将内存区域分为两个大小一样的区域。GC回收时，遍历当前使用区域，只将正在引用的对象复制到另一个区域，因此复制成本较低，且复制过程中还会进行内存整理，不会出现“碎片”问题。缺点就是：需要两个大小一样的内存区域和生命周期短的对象。所以该算法不适合大内存对象和长生命周期的对象，适用于young代的SO/S1
  Hotspot 的动态年龄阈值
Hotspot遍历对象时按年龄从小到大对其所占用大小进行累积，当累积的某个年龄大小超过了 survivor 区一半，取年龄与 MaxTenuringThreshold 中更小的作为新年龄阈值</description>
    </item>
    
  </channel>
</rss>
